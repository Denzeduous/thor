target triple = "x86_64-pc-windows-msvc"

target datalayout = "e-m:w-i64:64-f80:128-n8:16:32:64-S128"

%..opaque = type {};
%..string = type {i8*, i64} ; Basic_string
%..rawptr = type i8* ; Basic_rawptr
%..complex32 = type {half, half} ; Basic_complex32
%..complex64 = type {float, float} ; Basic_complex64
%..complex128 = type {double, double} ; Basic_complex128
%..quaternion64 = type {half, half, half, half} ; Basic_quaternion64
%..quaternion128 = type {float, float, float, float} ; Basic_quaternion128
%..quaternion256 = type {double, double, double, double} ; Basic_quaternion256
%..typeid = type i64 ; Basic_typeid
%..any = type {%..rawptr, %..typeid} ; Basic_any
declare void @llvm.dbg.declare(metadata, metadata, metadata) #3 

%runtime.Calling_Convention = type i64
%runtime.Type_Info_Enum_Value = type {[0 x i64], [8 x i8], i64}
%runtime.Platform_Endianness = type i8
%runtime.Type_Info_Named = type {%..string, %runtime.Type_Info*}
%runtime.Type_Info_Integer = type {i8, i8}
%runtime.Type_Info_Rune = type {}
%runtime.Type_Info_Float = type {}
%runtime.Type_Info_Complex = type {}
%runtime.Type_Info_Quaternion = type {}
%runtime.Type_Info_String = type {i8}
%runtime.Type_Info_Boolean = type {}
%runtime.Type_Info_Any = type {}
%runtime.Type_Info_Type_Id = type {}
%runtime.Type_Info_Pointer = type {%runtime.Type_Info*}
%runtime.Type_Info_Procedure = type {%runtime.Type_Info*, %runtime.Type_Info*, i8, i64}
%runtime.Type_Info_Array = type {%runtime.Type_Info*, i64, i64}
%runtime.Type_Info_Dynamic_Array = type {%runtime.Type_Info*, i64}
%runtime.Type_Info_Slice = type {%runtime.Type_Info*, i64}
%runtime.Type_Info_Tuple = type {{%runtime.Type_Info**, i64}, {%..string*, i64}}
%runtime.Type_Info_Struct = type {{%runtime.Type_Info**, i64}, {%..string*, i64}, {i64*, i64}, {i8*, i64}, {%..string*, i64}, i8, i8, i8}
%runtime.Type_Info_Union = type {{%runtime.Type_Info**, i64}, i64, %runtime.Type_Info*, i8, i8}
%runtime.Type_Info_Enum = type {%runtime.Type_Info*, {%..string*, i64}, {%runtime.Type_Info_Enum_Value*, i64}}
%runtime.Type_Info_Map = type {%runtime.Type_Info*, %runtime.Type_Info*, %runtime.Type_Info*}
%runtime.Type_Info_Bit_Field = type {{%..string*, i64}, {i32*, i64}, {i32*, i64}}
%runtime.Type_Info_Bit_Set = type {%runtime.Type_Info*, %runtime.Type_Info*, i64, i64}
%runtime.Type_Info_Opaque = type {%runtime.Type_Info*}
%runtime.Type_Info_Simd_Vector = type {%runtime.Type_Info*, i64, i64, i8}
%runtime.Type_Info = type {i64, i64, %..typeid, {[0 x i64], [88 x i8], i64}}
%runtime.Typeid_Bit_Field = type <{[0 x i64], [8 x i8]}>
%runtime.Source_Code_Location = type {%..string, i64, i64, %..string, i64}
%runtime.Assertion_Failure_Proc = type void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
%runtime.Context = type {%mem.Allocator, %mem.Allocator, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, %log.Logger, i64, i64, i64, i64, %..any, %..rawptr, i64, %..any}
%runtime.Map_Key = type {i64, %..string}
%runtime.Map_Entry_Header = type {%runtime.Map_Key, i64}
%"LinkedList.Node-386.Node\28T\29-6193" = type {i64*, %"LinkedList.Node-386.Node\28T\29-6193"*}
%"LinkedList.LinkedList-387.LinkedList\28int\29-6190" = type {%"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"*, i64}
%LinkedList.LinkedListError = type i64
%fmt.Info = type {i8, i8, i8, i8, i8, i8, i8, i64, i64, i64, i8, i8, %strings.Builder*, %..any, i64}
%mem.Raw_String = type {i8*, i64}
%mem.Raw_Slice = type {%..rawptr, i64}
%mem.Raw_Dynamic_Array = type {%..rawptr, i64, i64, %mem.Allocator}
%mem.Raw_Map = type {{i64*, i64}, %mem.Raw_Dynamic_Array}
%mem.Allocator_Mode = type i8
%mem.Allocator_Proc = type %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
%mem.Allocator = type {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr}
%mem.Scratch_Allocator = type {{i8*, i64}, i64, i64, %mem.Allocator, {%..rawptr*, i64, i64, %mem.Allocator}}
%os.Handle = type i64
%os.Errno = type i64
%utf8.Accept_Range = type {i8, i8}
%log.Level = type i64
%log.Option = type i64
%log.Options = type i8
%log.Logger_Proc = type void (%..rawptr, i64, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*
%log.Logger = type {void (%..rawptr, i64, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr, i8}
%strconv.Int_Flag = type i64
%strconv.Int_Flags = type i8
%strconv.Decimal_Slice = type {{i8*, i64}, i64, i64, i8}
%strconv.Float_Info = type {i64, i64, i64}
%win32.Handle = type %..rawptr
%win32.Bool = type i32
%strings.Builder = type {{i8*, i64, i64, %mem.Allocator}}
%decimal.Decimal = type {[384 x i8], i64, i64, i8, i8}
%strconv.format_digits.Buffer-246 = type {{i8*, i64}, i64}

declare i64 @llvm.cttz.i64(i64, i1) #0 
declare i64 @llvm.ctlz.i64(i64, i1) #0 
declare void @llvm.debugtrap() #0 
declare cc 64 i32 @GetCurrentThreadId() #0 
declare cc 64 %..rawptr @GetStdHandle(i32) #0 
declare cc 64 i32 @WriteFile(%..rawptr, %..rawptr, i32, i32*, %..rawptr) #0 
declare cc 64 i32 @SetHandleInformation(%..rawptr, i32, i32) #0 
declare cc 64 %..rawptr @HeapAlloc(%..rawptr, i32, i64) #0 
declare cc 64 %..rawptr @HeapReAlloc(%..rawptr, i32, %..rawptr, i64) #0 
declare cc 64 i32 @HeapFree(%..rawptr, i32, %..rawptr) #0 
declare cc 64 %..rawptr @GetProcessHeap() #0 
declare i32 @GetLastError() #0 
declare i16 @llvm.bswap.i16(i16) #0 
declare i32 @llvm.bswap.i32(i32) #0 
declare i64 @llvm.bswap.i64(i64) #0 
declare i128 @llvm.bswap.i128(i128) #0 

define <2 x i64> @runtime.udivmod128(<2 x i64> %_.0, <2 x i64> %_.1, i128* %_.2) #0 {
decls-0:
	%0 = alloca i128, align 16
	%1 = alloca i128, align 16
	%2 = alloca i128*, align 16
	%3 = alloca [2 x i64], align 16
	%4 = alloca [2 x i64], align 16
	%5 = alloca [2 x i64], align 16
	%6 = alloca [2 x i64], align 16
	%7 = alloca i32, align 16
	%8 = alloca i32, align 16
	%9 = alloca i128, align 16
	%10 = alloca i128, align 16
	%11 = alloca i128, align 16
	%12 = bitcast <2 x i64> %_.0 to i128
	store i128 %12, i128* %0
	%13 = bitcast <2 x i64> %_.1 to i128
	store i128 %13, i128* %1
	store i128* %_.2, i128** %2
	; n
	%14 = bitcast i128* %0 to [2 x i64]*
	%15 = load [2 x i64], [2 x i64]* %14, align 8
	store [2 x i64] %15, [2 x i64]* %3
	; d
	%16 = bitcast i128* %1 to [2 x i64]*
	%17 = load [2 x i64], [2 x i64]* %16, align 8
	store [2 x i64] %17, [2 x i64]* %4
	; q
	; r
	store [2 x i64] undef, [2 x i64]* %5
	store [2 x i64] undef, [2 x i64]* %6
	; sr
	store i32 0, i32* %7
	; IfStmt
	; IndexExpr
	%18 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%19 = load i64, i64* %18, align 8
	%20 = icmp eq i64 %19, 0
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.done-8

if.then-1:
	; IfStmt
	; IndexExpr
	%23 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%24 = load i64, i64* %23, align 8
	%25 = icmp eq i64 %24, 0
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-2, label %if.done-5

if.then-2:
	; IfStmt
	%28 = load i128*, i128** %2, align 8
	%29 = icmp ne i128* %28, zeroinitializer
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	%32 = load i128*, i128** %2, align 8
	%33 = getelementptr inbounds i128, i128* %32, i64 0
	; IndexExpr
	%34 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%35 = load i64, i64* %34, align 8
	; IndexExpr
	%36 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%37 = load i64, i64* %36, align 8
	%38 = urem i64 %35, %37
	%39 = zext i64 %38 to i128
	store i128 %39, i128* %33
	br label %if.done-4

if.done-4:
	; ReturnStmt
	; IndexExpr
	%40 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%41 = load i64, i64* %40, align 8
	; IndexExpr
	%42 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%43 = load i64, i64* %42, align 8
	%44 = udiv i64 %41, %43
	%45 = zext i64 %44 to i128
	%46 = bitcast i128 %45 to <2 x i64>
	ret <2 x i64> %46

if.done-5:
	; IfStmt
	%47 = load i128*, i128** %2, align 8
	%48 = icmp ne i128* %47, zeroinitializer
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-6, label %if.done-7

if.then-6:
	; AssignStmt
	%51 = load i128*, i128** %2, align 8
	%52 = getelementptr inbounds i128, i128* %51, i64 0
	; IndexExpr
	%53 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%54 = load i64, i64* %53, align 8
	%55 = zext i64 %54 to i128
	store i128 %55, i128* %52
	br label %if.done-7

if.done-7:
	; ReturnStmt
	%56 = bitcast i128 0 to <2 x i64>
	ret <2 x i64> %56

if.done-8:
	; IfStmt
	; IndexExpr
	%57 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%58 = load i64, i64* %57, align 8
	%59 = icmp eq i64 %58, 0
	%60 = zext i1 %59 to i8
	%61 = trunc i8 %60 to i1
	br i1 %61, label %if.then-9, label %if.else-26

if.then-9:
	; IfStmt
	; IndexExpr
	%62 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%63 = load i64, i64* %62, align 8
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-10, label %if.done-13

if.then-10:
	; IfStmt
	%67 = load i128*, i128** %2, align 8
	%68 = icmp ne i128* %67, zeroinitializer
	%69 = zext i1 %68 to i8
	%70 = trunc i8 %69 to i1
	br i1 %70, label %if.then-11, label %if.done-12

if.then-11:
	; AssignStmt
	%71 = load i128*, i128** %2, align 8
	%72 = getelementptr inbounds i128, i128* %71, i64 0
	; IndexExpr
	%73 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%74 = load i64, i64* %73, align 8
	; IndexExpr
	%75 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%76 = load i64, i64* %75, align 8
	%77 = urem i64 %74, %76
	%78 = zext i64 %77 to i128
	store i128 %78, i128* %72
	br label %if.done-12

if.done-12:
	; ReturnStmt
	; IndexExpr
	%79 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%80 = load i64, i64* %79, align 8
	; IndexExpr
	%81 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%82 = load i64, i64* %81, align 8
	%83 = udiv i64 %80, %82
	%84 = zext i64 %83 to i128
	%85 = bitcast i128 %84 to <2 x i64>
	ret <2 x i64> %85

if.done-13:
	; IfStmt
	; IndexExpr
	%86 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%87 = load i64, i64* %86, align 8
	%88 = icmp eq i64 %87, 0
	%89 = zext i1 %88 to i8
	%90 = trunc i8 %89 to i1
	br i1 %90, label %if.then-14, label %if.done-17

if.then-14:
	; IfStmt
	%91 = load i128*, i128** %2, align 8
	%92 = icmp ne i128* %91, zeroinitializer
	%93 = zext i1 %92 to i8
	%94 = trunc i8 %93 to i1
	br i1 %94, label %if.then-15, label %if.done-16

if.then-15:
	; AssignStmt
	; IndexExpr
	%95 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	; IndexExpr
	%96 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%97 = load i64, i64* %96, align 8
	; IndexExpr
	%98 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%99 = load i64, i64* %98, align 8
	%100 = urem i64 %97, %99
	store i64 %100, i64* %95
	; AssignStmt
	; IndexExpr
	%101 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	store i64 0, i64* %101
	; AssignStmt
	%102 = load i128*, i128** %2, align 8
	%103 = getelementptr inbounds i128, i128* %102, i64 0
	%104 = bitcast [2 x i64]* %6 to i128*
	%105 = load i128, i128* %104, align 8
	store i128 %105, i128* %103
	br label %if.done-16

if.done-16:
	; ReturnStmt
	; IndexExpr
	%106 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%107 = load i64, i64* %106, align 8
	; IndexExpr
	%108 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%109 = load i64, i64* %108, align 8
	%110 = udiv i64 %107, %109
	%111 = zext i64 %110 to i128
	%112 = bitcast i128 %111 to <2 x i64>
	ret <2 x i64> %112

if.done-17:
	; IfStmt
	; IndexExpr
	%113 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%114 = load i64, i64* %113, align 8
	; IndexExpr
	%115 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%116 = load i64, i64* %115, align 8
	%117 = sub i64 %116, 1
	%118 = and i64 %114, %117
	%119 = icmp eq i64 %118, 0
	%120 = zext i1 %119 to i8
	%121 = trunc i8 %120 to i1
	br i1 %121, label %if.then-18, label %if.done-21

if.then-18:
	; IfStmt
	%122 = load i128*, i128** %2, align 8
	%123 = icmp ne i128* %122, zeroinitializer
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-19, label %if.done-20

if.then-19:
	; AssignStmt
	; IndexExpr
	%126 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%127 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%128 = load i64, i64* %127, align 8
	store i64 %128, i64* %126
	; AssignStmt
	; IndexExpr
	%129 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	; IndexExpr
	%130 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%131 = load i64, i64* %130, align 8
	; IndexExpr
	%132 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%133 = load i64, i64* %132, align 8
	%134 = sub i64 %133, 1
	%135 = and i64 %131, %134
	store i64 %135, i64* %129
	; AssignStmt
	%136 = load i128*, i128** %2, align 8
	%137 = getelementptr inbounds i128, i128* %136, i64 0
	%138 = bitcast [2 x i64]* %6 to i128*
	%139 = load i128, i128* %138, align 8
	store i128 %139, i128* %137
	br label %if.done-20

if.done-20:
	; ReturnStmt
	; IndexExpr
	%140 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%141 = load i64, i64* %140, align 8
	; IndexExpr
	%142 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%143 = load i64, i64* %142, align 8
	%144 = call i64 @llvm.cttz.i64(i64 %143, i1 false)
	%145 = lshr i64 %141, %144
	%146 = zext i64 %145 to i128
	%147 = bitcast i128 %146 to <2 x i64>
	ret <2 x i64> %147

if.done-21:
	; AssignStmt
	; IndexExpr
	%148 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%149 = load i64, i64* %148, align 8
	%150 = call i64 @llvm.ctlz.i64(i64 %149, i1 false)
	%151 = trunc i64 %150 to i32
	; IndexExpr
	%152 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%153 = load i64, i64* %152, align 8
	%154 = call i64 @llvm.ctlz.i64(i64 %153, i1 false)
	%155 = trunc i64 %154 to i32
	%156 = sub i32 %151, %155
	%157 = bitcast i32 %156 to i32
	store i32 %157, i32* %7
	; IfStmt
	%158 = load i32, i32* %7, align 4
	%159 = icmp ugt i32 %158, 62
	%160 = zext i1 %159 to i8
	%161 = trunc i8 %160 to i1
	br i1 %161, label %if.then-22, label %if.done-25

if.then-22:
	; IfStmt
	%162 = load i128*, i128** %2, align 8
	%163 = icmp ne i128* %162, zeroinitializer
	%164 = zext i1 %163 to i8
	%165 = trunc i8 %164 to i1
	br i1 %165, label %if.then-23, label %if.done-24

if.then-23:
	; AssignStmt
	%166 = load i128*, i128** %2, align 8
	%167 = getelementptr inbounds i128, i128* %166, i64 0
	%168 = load i128, i128* %0, align 8
	store i128 %168, i128* %167
	br label %if.done-24

if.done-24:
	; ReturnStmt
	%169 = bitcast i128 0 to <2 x i64>
	ret <2 x i64> %169

if.done-25:
	; AssignStmt
	%170 = load i32, i32* %7, align 4
	%171 = add i32 %170, 1
	store i32 %171, i32* %7
	; AssignStmt
	; IndexExpr
	%172 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	store i64 0, i64* %172
	; AssignStmt
	; IndexExpr
	%173 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%174 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%175 = load i64, i64* %174, align 8
	%176 = load i32, i32* %7, align 4
	%177 = sub i32 64, %176
	%178 = zext i32 %177 to i64
	%179 = shl i64 %175, %178
	store i64 %179, i64* %173
	; AssignStmt
	; IndexExpr
	%180 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	; IndexExpr
	%181 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%182 = load i64, i64* %181, align 8
	%183 = load i32, i32* %7, align 4
	%184 = zext i32 %183 to i64
	%185 = lshr i64 %182, %184
	store i64 %185, i64* %180
	; AssignStmt
	; IndexExpr
	%186 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%187 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%188 = load i64, i64* %187, align 8
	%189 = load i32, i32* %7, align 4
	%190 = sub i32 64, %189
	%191 = zext i32 %190 to i64
	%192 = shl i64 %188, %191
	; IndexExpr
	%193 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%194 = load i64, i64* %193, align 8
	%195 = load i32, i32* %7, align 4
	%196 = zext i32 %195 to i64
	%197 = lshr i64 %194, %196
	%198 = or i64 %192, %197
	store i64 %198, i64* %186
	br label %if.done-48

if.else-26:
	; IfStmt
	; IndexExpr
	%199 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%200 = load i64, i64* %199, align 8
	%201 = icmp eq i64 %200, 0
	%202 = zext i1 %201 to i8
	%203 = trunc i8 %202 to i1
	br i1 %203, label %if.then-27, label %if.else-39

if.then-27:
	; IfStmt
	; IndexExpr
	%204 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%205 = load i64, i64* %204, align 8
	; IndexExpr
	%206 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%207 = load i64, i64* %206, align 8
	%208 = sub i64 %207, 1
	%209 = and i64 %205, %208
	%210 = icmp eq i64 %209, 0
	%211 = zext i1 %210 to i8
	%212 = trunc i8 %211 to i1
	br i1 %212, label %if.then-28, label %if.done-33

if.then-28:
	; IfStmt
	%213 = load i128*, i128** %2, align 8
	%214 = icmp ne i128* %213, zeroinitializer
	%215 = zext i1 %214 to i8
	%216 = trunc i8 %215 to i1
	br i1 %216, label %if.then-29, label %if.done-30

if.then-29:
	; AssignStmt
	%217 = load i128*, i128** %2, align 8
	%218 = getelementptr inbounds i128, i128* %217, i64 0
	; IndexExpr
	%219 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%220 = load i64, i64* %219, align 8
	; IndexExpr
	%221 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%222 = load i64, i64* %221, align 8
	%223 = sub i64 %222, 1
	%224 = and i64 %220, %223
	%225 = zext i64 %224 to i128
	store i128 %225, i128* %218
	br label %if.done-30

if.done-30:
	; IfStmt
	; IndexExpr
	%226 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%227 = load i64, i64* %226, align 8
	%228 = icmp eq i64 %227, 1
	%229 = zext i1 %228 to i8
	%230 = trunc i8 %229 to i1
	br i1 %230, label %if.then-31, label %if.done-32

if.then-31:
	; ReturnStmt
	%231 = load i128, i128* %0, align 8
	%232 = bitcast i128 %231 to <2 x i64>
	ret <2 x i64> %232

if.done-32:
	; AssignStmt
	; IndexExpr
	%233 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%234 = load i64, i64* %233, align 8
	%235 = call i64 @llvm.cttz.i64(i64 %234, i1 false)
	%236 = trunc i64 %235 to i32
	store i32 %236, i32* %7
	; AssignStmt
	; IndexExpr
	%237 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%238 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%239 = load i64, i64* %238, align 8
	%240 = load i32, i32* %7, align 4
	%241 = zext i32 %240 to i64
	%242 = lshr i64 %239, %241
	store i64 %242, i64* %237
	; AssignStmt
	; IndexExpr
	%243 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	; IndexExpr
	%244 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%245 = load i64, i64* %244, align 8
	%246 = load i32, i32* %7, align 4
	%247 = sub i32 64, %246
	%248 = zext i32 %247 to i64
	%249 = shl i64 %245, %248
	; IndexExpr
	%250 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%251 = load i64, i64* %250, align 8
	%252 = load i32, i32* %7, align 4
	%253 = zext i32 %252 to i64
	%254 = lshr i64 %251, %253
	%255 = or i64 %249, %254
	store i64 %255, i64* %243
	; ReturnStmt
	%256 = bitcast [2 x i64]* %5 to i128*
	%257 = load i128, i128* %256, align 8
	%258 = bitcast i128 %257 to <2 x i64>
	ret <2 x i64> %258

if.done-33:
	; AssignStmt
	; IndexExpr
	%259 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 0
	%260 = load i64, i64* %259, align 8
	%261 = call i64 @llvm.ctlz.i64(i64 %260, i1 false)
	%262 = trunc i64 %261 to i32
	%263 = add i32 65, %262
	; IndexExpr
	%264 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%265 = load i64, i64* %264, align 8
	%266 = call i64 @llvm.ctlz.i64(i64 %265, i1 false)
	%267 = trunc i64 %266 to i32
	%268 = sub i32 %263, %267
	store i32 %268, i32* %7
	; SwitchStmt
	%269 = load i32, i32* %7, align 4
	%270 = icmp eq i32 %269, 64
	%271 = zext i1 %270 to i8
	%272 = icmp eq i8 1, %271
	br i1 %272, label %switch.case.body-35, label %switch.case.next-34

switch.case.next-34:
	%273 = load i32, i32* %7, align 4
	%274 = icmp ult i32 %273, 64
	%275 = zext i1 %274 to i8
	%276 = icmp eq i8 1, %275
	br i1 %276, label %switch.fall.body-37, label %switch.case.next-36

switch.case.body-35:
	; AssignStmt
	; IndexExpr
	%277 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	store i64 0, i64* %277
	; AssignStmt
	; IndexExpr
	%278 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%279 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%280 = load i64, i64* %279, align 8
	store i64 %280, i64* %278
	; AssignStmt
	; IndexExpr
	%281 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	store i64 0, i64* %281
	; AssignStmt
	; IndexExpr
	%282 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%283 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%284 = load i64, i64* %283, align 8
	store i64 %284, i64* %282
	br label %switch.done-38

switch.case.next-36:
	; AssignStmt
	; IndexExpr
	%285 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	; IndexExpr
	%286 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%287 = load i64, i64* %286, align 8
	%288 = load i32, i32* %7, align 4
	%289 = sub i32 128, %288
	%290 = zext i32 %289 to i64
	%291 = shl i64 %287, %290
	store i64 %291, i64* %285
	; AssignStmt
	; IndexExpr
	%292 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%293 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%294 = load i64, i64* %293, align 8
	%295 = load i32, i32* %7, align 4
	%296 = sub i32 128, %295
	%297 = zext i32 %296 to i64
	%298 = shl i64 %294, %297
	; IndexExpr
	%299 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%300 = load i64, i64* %299, align 8
	%301 = load i32, i32* %7, align 4
	%302 = sub i32 %301, 64
	%303 = zext i32 %302 to i64
	%304 = lshr i64 %300, %303
	%305 = or i64 %298, %304
	store i64 %305, i64* %292
	; AssignStmt
	; IndexExpr
	%306 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	store i64 0, i64* %306
	; AssignStmt
	; IndexExpr
	%307 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%308 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%309 = load i64, i64* %308, align 8
	%310 = load i32, i32* %7, align 4
	%311 = sub i32 %310, 64
	%312 = zext i32 %311 to i64
	%313 = lshr i64 %309, %312
	store i64 %313, i64* %307
	br label %switch.done-38

switch.fall.body-37:
	; AssignStmt
	; IndexExpr
	%314 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	store i64 0, i64* %314
	; AssignStmt
	; IndexExpr
	%315 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%316 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%317 = load i64, i64* %316, align 8
	%318 = load i32, i32* %7, align 4
	%319 = sub i32 64, %318
	%320 = zext i32 %319 to i64
	%321 = shl i64 %317, %320
	store i64 %321, i64* %315
	; AssignStmt
	; IndexExpr
	%322 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	; IndexExpr
	%323 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%324 = load i64, i64* %323, align 8
	%325 = load i32, i32* %7, align 4
	%326 = zext i32 %325 to i64
	%327 = lshr i64 %324, %326
	store i64 %327, i64* %322
	; AssignStmt
	; IndexExpr
	%328 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%329 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%330 = load i64, i64* %329, align 8
	%331 = load i32, i32* %7, align 4
	%332 = sub i32 64, %331
	%333 = zext i32 %332 to i64
	%334 = shl i64 %330, %333
	; IndexExpr
	%335 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%336 = load i64, i64* %335, align 8
	%337 = load i32, i32* %7, align 4
	%338 = zext i32 %337 to i64
	%339 = lshr i64 %336, %338
	%340 = or i64 %334, %339
	store i64 %340, i64* %328
	br label %switch.done-38

switch.done-38:
	br label %if.done-47

if.else-39:
	; AssignStmt
	; IndexExpr
	%341 = getelementptr inbounds [2 x i64], [2 x i64]* %4, i32 0, i32 1
	%342 = load i64, i64* %341, align 8
	%343 = call i64 @llvm.ctlz.i64(i64 %342, i1 false)
	%344 = trunc i64 %343 to i32
	; IndexExpr
	%345 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%346 = load i64, i64* %345, align 8
	%347 = call i64 @llvm.ctlz.i64(i64 %346, i1 false)
	%348 = trunc i64 %347 to i32
	%349 = sub i32 %344, %348
	%350 = bitcast i32 %349 to i32
	store i32 %350, i32* %7
	; IfStmt
	%351 = load i32, i32* %7, align 4
	%352 = icmp ugt i32 %351, 63
	%353 = zext i1 %352 to i8
	%354 = trunc i8 %353 to i1
	br i1 %354, label %if.then-40, label %if.done-43

if.then-40:
	; IfStmt
	%355 = load i128*, i128** %2, align 8
	%356 = icmp ne i128* %355, zeroinitializer
	%357 = zext i1 %356 to i8
	%358 = trunc i8 %357 to i1
	br i1 %358, label %if.then-41, label %if.done-42

if.then-41:
	; AssignStmt
	%359 = load i128*, i128** %2, align 8
	%360 = getelementptr inbounds i128, i128* %359, i64 0
	%361 = load i128, i128* %0, align 8
	store i128 %361, i128* %360
	br label %if.done-42

if.done-42:
	; ReturnStmt
	%362 = bitcast i128 0 to <2 x i64>
	ret <2 x i64> %362

if.done-43:
	; AssignStmt
	%363 = load i32, i32* %7, align 4
	%364 = add i32 %363, 1
	store i32 %364, i32* %7
	; AssignStmt
	; IndexExpr
	%365 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	store i64 0, i64* %365
	; IfStmt
	%366 = load i32, i32* %7, align 4
	%367 = icmp eq i32 %366, 64
	%368 = zext i1 %367 to i8
	%369 = trunc i8 %368 to i1
	br i1 %369, label %if.then-44, label %if.else-45

if.then-44:
	; AssignStmt
	; IndexExpr
	%370 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%371 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%372 = load i64, i64* %371, align 8
	store i64 %372, i64* %370
	; AssignStmt
	; IndexExpr
	%373 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	store i64 0, i64* %373
	; AssignStmt
	; IndexExpr
	%374 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%375 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%376 = load i64, i64* %375, align 8
	store i64 %376, i64* %374
	br label %if.done-46

if.else-45:
	; AssignStmt
	; IndexExpr
	%377 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	; IndexExpr
	%378 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%379 = load i64, i64* %378, align 8
	%380 = load i32, i32* %7, align 4
	%381 = zext i32 %380 to i64
	%382 = lshr i64 %379, %381
	store i64 %382, i64* %377
	; AssignStmt
	; IndexExpr
	%383 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%384 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 1
	%385 = load i64, i64* %384, align 8
	%386 = load i32, i32* %7, align 4
	%387 = sub i32 64, %386
	%388 = zext i32 %387 to i64
	%389 = shl i64 %385, %388
	; IndexExpr
	%390 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%391 = load i64, i64* %390, align 8
	%392 = load i32, i32* %7, align 4
	%393 = zext i32 %392 to i64
	%394 = lshr i64 %391, %393
	%395 = or i64 %389, %394
	store i64 %395, i64* %383
	; AssignStmt
	; IndexExpr
	%396 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%397 = getelementptr inbounds [2 x i64], [2 x i64]* %3, i32 0, i32 0
	%398 = load i64, i64* %397, align 8
	%399 = load i32, i32* %7, align 4
	%400 = sub i32 64, %399
	%401 = zext i32 %400 to i64
	%402 = shl i64 %398, %401
	store i64 %402, i64* %396
	br label %if.done-46

if.done-46:
	br label %if.done-47

if.done-47:
	br label %if.done-48

if.done-48:
	; carry
	store i32 0, i32* %8
	; r_all
	store i128 undef, i128* %9
	; ForStmt
	br label %for.loop-49

for.loop-49:
	%403 = load i32, i32* %7, align 4
	%404 = icmp ugt i32 %403, 0
	%405 = zext i1 %404 to i8
	%406 = trunc i8 %405 to i1
	br i1 %406, label %for.body-50, label %for.done-51

for.body-50:
	; AssignStmt
	; IndexExpr
	%407 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	; IndexExpr
	%408 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 1
	%409 = load i64, i64* %408, align 8
	%410 = shl i64 %409, 1
	; IndexExpr
	%411 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	%412 = load i64, i64* %411, align 8
	%413 = lshr i64 %412, 63
	%414 = or i64 %410, %413
	store i64 %414, i64* %407
	; AssignStmt
	; IndexExpr
	%415 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	; IndexExpr
	%416 = getelementptr inbounds [2 x i64], [2 x i64]* %6, i32 0, i32 0
	%417 = load i64, i64* %416, align 8
	%418 = shl i64 %417, 1
	; IndexExpr
	%419 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	%420 = load i64, i64* %419, align 8
	%421 = lshr i64 %420, 63
	%422 = or i64 %418, %421
	store i64 %422, i64* %415
	; AssignStmt
	; IndexExpr
	%423 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	; IndexExpr
	%424 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 1
	%425 = load i64, i64* %424, align 8
	%426 = shl i64 %425, 1
	; IndexExpr
	%427 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	%428 = load i64, i64* %427, align 8
	%429 = lshr i64 %428, 63
	%430 = or i64 %426, %429
	store i64 %430, i64* %423
	; AssignStmt
	; IndexExpr
	%431 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	; IndexExpr
	%432 = getelementptr inbounds [2 x i64], [2 x i64]* %5, i32 0, i32 0
	%433 = load i64, i64* %432, align 8
	%434 = shl i64 %433, 1
	%435 = load i32, i32* %8, align 4
	%436 = zext i32 %435 to i64
	%437 = or i64 %434, %436
	store i64 %437, i64* %431
	; AssignStmt
	%438 = bitcast [2 x i64]* %6 to i128*
	%439 = load i128, i128* %438, align 8
	store i128 %439, i128* %9
	; s
	%440 = load i128, i128* %1, align 8
	%441 = load i128, i128* %9, align 8
	%442 = sub i128 %440, %441
	%443 = sub i128 %442, 1
	%444 = bitcast i128 %443 to i128
	%445 = ashr i128 %444, 127
	store i128 %445, i128* %10
	; AssignStmt
	%446 = load i128, i128* %10, align 8
	%447 = and i128 %446, 1
	%448 = trunc i128 %447 to i32
	store i32 %448, i32* %8
	; AssignStmt
	%449 = load i128, i128* %1, align 8
	%450 = load i128, i128* %10, align 8
	%451 = bitcast i128 %450 to i128
	%452 = and i128 %449, %451
	%453 = load i128, i128* %9, align 8
	%454 = sub i128 %453, %452
	store i128 %454, i128* %9
	; AssignStmt
	%455 = bitcast i128* %9 to [2 x i64]*
	%456 = load [2 x i64], [2 x i64]* %455, align 8
	store [2 x i64] %456, [2 x i64]* %6
	; AssignStmt
	%457 = load i32, i32* %7, align 4
	%458 = sub i32 %457, 1
	store i32 %458, i32* %7
	br label %for.loop-49

for.done-51:
	; q_all
	%459 = bitcast [2 x i64]* %5 to i128*
	%460 = load i128, i128* %459, align 8
	%461 = shl i128 %460, 1
	%462 = load i32, i32* %8, align 4
	%463 = zext i32 %462 to i128
	%464 = or i128 %461, %463
	store i128 %464, i128* %11
	; IfStmt
	%465 = load i128*, i128** %2, align 8
	%466 = icmp ne i128* %465, zeroinitializer
	%467 = zext i1 %466 to i8
	%468 = trunc i8 %467 to i1
	br i1 %468, label %if.then-52, label %if.done-53

if.then-52:
	; AssignStmt
	%469 = load i128*, i128** %2, align 8
	%470 = getelementptr inbounds i128, i128* %469, i64 0
	%471 = load i128, i128* %9, align 8
	store i128 %471, i128* %470
	br label %if.done-53

if.done-53:
	; ReturnStmt
	%472 = load i128, i128* %11, align 8
	%473 = bitcast i128 %472 to <2 x i64>
	ret <2 x i64> %473
}

define <2 x i64> @__umodti3(<2 x i64> %_.0, <2 x i64> %_.1) #0 {
decls-0:
	%0 = alloca i128, align 16
	%1 = alloca i128, align 16
	%2 = alloca i128, align 16
	%3 = alloca i128, align 16
	%4 = alloca i128, align 16
	%5 = alloca i128, align 16
	%6 = alloca i128, align 16
	%7 = bitcast <2 x i64> %_.0 to i128
	store i128 %7, i128* %0
	%8 = bitcast <2 x i64> %_.1 to i128
	store i128 %8, i128* %1
	; s_a
	%9 = load i128, i128* %0, align 8
	%10 = ashr i128 %9, 127
	store i128 %10, i128* %2
	; s_b
	%11 = load i128, i128* %1, align 8
	%12 = ashr i128 %11, 127
	store i128 %12, i128* %3
	; an
	%13 = load i128, i128* %0, align 8
	%14 = load i128, i128* %2, align 8
	%15 = xor i128 %13, %14
	%16 = load i128, i128* %2, align 8
	%17 = sub i128 %15, %16
	store i128 %17, i128* %4
	; bn
	%18 = load i128, i128* %1, align 8
	%19 = load i128, i128* %3, align 8
	%20 = xor i128 %18, %19
	%21 = load i128, i128* %3, align 8
	%22 = sub i128 %20, %21
	store i128 %22, i128* %5
	; r
	store i128 undef, i128* %6
	; AssignStmt
	%23 = load i128, i128* %4, align 8
	%24 = bitcast i128 %23 to i128
	%25 = load i128, i128* %5, align 8
	%26 = bitcast i128 %25 to i128
	%27 = bitcast i128 %24 to <2 x i64>
	%28 = bitcast i128 %26 to <2 x i64>
	%29 = call <2 x i64> @runtime.udivmod128(<2 x i64> %27, <2 x i64> %28, i128* %6)
	%30 = bitcast <2 x i64> %29 to i128
	; ReturnStmt
	%31 = load i128, i128* %6, align 8
	%32 = bitcast i128 %31 to i128
	%33 = load i128, i128* %2, align 8
	%34 = xor i128 %32, %33
	%35 = load i128, i128* %2, align 8
	%36 = sub i128 %34, %35
	%37 = bitcast i128 %36 to <2 x i64>
	ret <2 x i64> %37
}

define <2 x i64> @__udivmodti4(<2 x i64> %_.0, <2 x i64> %_.1, i128* %_.2) #0 {
decls-0:
	%0 = alloca i128, align 16
	%1 = alloca i128, align 16
	%2 = alloca i128*, align 16
	%3 = bitcast <2 x i64> %_.0 to i128
	store i128 %3, i128* %0
	%4 = bitcast <2 x i64> %_.1 to i128
	store i128 %4, i128* %1
	store i128* %_.2, i128** %2
	; ReturnStmt
	%5 = load i128, i128* %0, align 8
	%6 = load i128, i128* %1, align 8
	%7 = load i128*, i128** %2, align 8
	%8 = bitcast i128 %5 to <2 x i64>
	%9 = bitcast i128 %6 to <2 x i64>
	%10 = call <2 x i64> @runtime.udivmod128(<2 x i64> %8, <2 x i64> %9, i128* %7)
	%11 = bitcast <2 x i64> %10 to i128
	%12 = bitcast i128 %11 to <2 x i64>
	ret <2 x i64> %12
}

define <2 x i64> @__udivti3(<2 x i64> %_.0, <2 x i64> %_.1) #0 {
decls-0:
	%0 = alloca i128, align 16
	%1 = alloca i128, align 16
	%2 = bitcast <2 x i64> %_.0 to i128
	store i128 %2, i128* %0
	%3 = bitcast <2 x i64> %_.1 to i128
	store i128 %3, i128* %1
	; ReturnStmt
	%4 = load i128, i128* %0, align 8
	%5 = load i128, i128* %1, align 8
	%6 = bitcast i128 %4 to <2 x i64>
	%7 = bitcast i128 %5 to <2 x i64>
	%8 = call <2 x i64> @__udivmodti4(<2 x i64> %6, <2 x i64> %7, i128* zeroinitializer)
	%9 = bitcast <2 x i64> %8 to i128
	%10 = bitcast i128 %9 to <2 x i64>
	ret <2 x i64> %10
}

define void @runtime.print_u64(i64 %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca [129 x i8], align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store i64 %_.1, i64* %1
	; digits
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$0, i32 0, i32 0), i64 10}, %..string* %2
	; a
	%9 = bitcast [129 x i8]* %3 to %..rawptr
	; ZeroInit
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 129)
	; i
	store i64 129, i64* %4
	; b
	store i64 10, i64* %5
	; u
	%11 = load i64, i64* %1, align 8
	store i64 %11, i64* %6
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%12 = load i64, i64* %6, align 8
	%13 = load i64, i64* %5, align 8
	%14 = icmp uge i64 %12, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %for.body-2, label %for.done-3

for.body-2:
	; AssignStmt
	%17 = load i64, i64* %4, align 8
	%18 = sub i64 %17, 1
	store i64 %18, i64* %4
	; AssignStmt
	; IndexExpr
	%19 = load i64, i64* %4, align 8
	%20 = trunc i64 %19 to i32
	%21 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i32 0, i32 %20
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$1, i32 0, i32 0), i64 66}, i64 16, i64 13, i64 %19, i64 129)
	; IndexExpr
	%22 = load %..string, %..string* %2, align 8
	%23 = extractvalue %..string %22, 0
	%24 = extractvalue %..string %22, 1
	%25 = load i64, i64* %6, align 8
	%26 = load i64, i64* %5, align 8
	%27 = urem i64 %25, %26
	%28 = bitcast i64 %27 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$2, i32 0, i32 0), i64 66}, i64 16, i64 25, i64 %28, i64 %24)
	%29 = getelementptr inbounds i8, i8* %23, i64 %28
	%30 = load i8, i8* %29, align 1
	store i8 %30, i8* %21
	; AssignStmt
	%31 = load i64, i64* %5, align 8
	%32 = load i64, i64* %6, align 8
	%33 = udiv i64 %32, %31
	store i64 %33, i64* %6
	br label %for.loop-1

for.done-3:
	; AssignStmt
	%34 = load i64, i64* %4, align 8
	%35 = sub i64 %34, 1
	store i64 %35, i64* %4
	; AssignStmt
	; IndexExpr
	%36 = load i64, i64* %4, align 8
	%37 = trunc i64 %36 to i32
	%38 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i32 0, i32 %37
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$3, i32 0, i32 0), i64 66}, i64 19, i64 12, i64 %36, i64 129)
	; IndexExpr
	%39 = load %..string, %..string* %2, align 8
	%40 = extractvalue %..string %39, 0
	%41 = extractvalue %..string %39, 1
	%42 = load i64, i64* %6, align 8
	%43 = load i64, i64* %5, align 8
	%44 = urem i64 %42, %43
	%45 = bitcast i64 %44 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$4, i32 0, i32 0), i64 66}, i64 19, i64 24, i64 %45, i64 %41)
	%46 = getelementptr inbounds i8, i8* %40, i64 %45
	%47 = load i8, i8* %46, align 1
	store i8 %47, i8* %38
	; SelectorExpr
	%48 = load i64, i64* %0, align 8
	; SliceExpr
	%49 = load i64, i64* %4, align 8
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$5, i32 0, i32 0), i64 66}, i64 21, i64 16, i64 %49, i64 129, i64 129)
	%50 = getelementptr inbounds [129 x i8], [129 x i8]* %3, i32 0, i32 0
	%51 = getelementptr inbounds i8, i8* %50, i64 %49
	%52 = sub i64 129, %49
	%53 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 0
	store i8* %51, i8** %53
	%54 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 1
	store i64 %52, i64* %54
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %8, align 1
	call void @os.write({i64, i64}* %8, i64 %48, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @runtime.print_i64(i64 %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8, align 16
	%5 = alloca [129 x i8], align 16
	%6 = alloca i64, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store i64 %_.1, i64* %1
	; digits
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$6, i32 0, i32 0), i64 10}, %..string* %2
	; u
	%9 = load i64, i64* %1, align 8
	store i64 %9, i64* %3
	; neg
	%10 = load i64, i64* %3, align 8
	%11 = icmp slt i64 %10, 0
	%12 = zext i1 %11 to i8
	store i8 %12, i8* %4
	; AssignStmt
	%13 = load i64, i64* %3, align 8
	; abs
	%14 = icmp slt i64 %13, 0
	%15 = sub i64 0, %13
	%16 = select i1 %14, i64 %15, i64 %13
	store i64 %16, i64* %3
	; a
	%17 = bitcast [129 x i8]* %5 to %..rawptr
	; ZeroInit
	%18 = call %..rawptr @mem.zero(%..rawptr %17, i64 129)
	; i
	store i64 129, i64* %6
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%19 = load i64, i64* %3, align 8
	%20 = icmp sge i64 %19, 10
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %for.body-2, label %for.done-3

for.body-2:
	; AssignStmt
	%23 = load i64, i64* %6, align 8
	%24 = sub i64 %23, 1
	store i64 %24, i64* %6
	; AssignStmt
	; IndexExpr
	%25 = load i64, i64* %6, align 8
	%26 = trunc i64 %25 to i32
	%27 = getelementptr inbounds [129 x i8], [129 x i8]* %5, i32 0, i32 %26
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$7, i32 0, i32 0), i64 66}, i64 35, i64 13, i64 %25, i64 129)
	; IndexExpr
	%28 = load %..string, %..string* %2, align 8
	%29 = extractvalue %..string %28, 0
	%30 = extractvalue %..string %28, 1
	%31 = load i64, i64* %3, align 8
	%32 = srem i64 %31, 10
	%33 = bitcast i64 %32 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$8, i32 0, i32 0), i64 66}, i64 35, i64 25, i64 %33, i64 %30)
	%34 = getelementptr inbounds i8, i8* %29, i64 %33
	%35 = load i8, i8* %34, align 1
	store i8 %35, i8* %27
	; AssignStmt
	%36 = load i64, i64* %3, align 8
	%37 = sdiv i64 %36, 10
	store i64 %37, i64* %3
	br label %for.loop-1

for.done-3:
	; AssignStmt
	%38 = load i64, i64* %6, align 8
	%39 = sub i64 %38, 1
	store i64 %39, i64* %6
	; AssignStmt
	; IndexExpr
	%40 = load i64, i64* %6, align 8
	%41 = trunc i64 %40 to i32
	%42 = getelementptr inbounds [129 x i8], [129 x i8]* %5, i32 0, i32 %41
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$9, i32 0, i32 0), i64 66}, i64 38, i64 12, i64 %40, i64 129)
	; IndexExpr
	%43 = load %..string, %..string* %2, align 8
	%44 = extractvalue %..string %43, 0
	%45 = extractvalue %..string %43, 1
	%46 = load i64, i64* %3, align 8
	%47 = srem i64 %46, 10
	%48 = bitcast i64 %47 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$a, i32 0, i32 0), i64 66}, i64 38, i64 24, i64 %48, i64 %45)
	%49 = getelementptr inbounds i8, i8* %44, i64 %48
	%50 = load i8, i8* %49, align 1
	store i8 %50, i8* %42
	; IfStmt
	%51 = load i8, i8* %4, align 1
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	%53 = load i64, i64* %6, align 8
	%54 = sub i64 %53, 1
	store i64 %54, i64* %6
	; AssignStmt
	; IndexExpr
	%55 = load i64, i64* %6, align 8
	%56 = trunc i64 %55 to i32
	%57 = getelementptr inbounds [129 x i8], [129 x i8]* %5, i32 0, i32 %56
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$b, i32 0, i32 0), i64 66}, i64 40, i64 13, i64 %55, i64 129)
	store i8 45, i8* %57
	br label %if.done-5

if.done-5:
	; SelectorExpr
	%58 = load i64, i64* %0, align 8
	; SliceExpr
	%59 = load i64, i64* %6, align 8
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$c, i32 0, i32 0), i64 66}, i64 43, i64 16, i64 %59, i64 129, i64 129)
	%60 = getelementptr inbounds [129 x i8], [129 x i8]* %5, i32 0, i32 0
	%61 = getelementptr inbounds i8, i8* %60, i64 %59
	%62 = sub i64 129, %59
	%63 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 0
	store i8* %61, i8** %63
	%64 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 1
	store i64 %62, i64* %64
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %8, align 1
	call void @os.write({i64, i64}* %8, i64 %58, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @runtime.print_caller_location(i64 %_.0, %runtime.Source_Code_Location* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca {i64, i64}, align 16
	%2 = alloca {i64, i64}, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	; SelectorExpr
	%5 = load i64, i64* %0, align 8
	%6 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %_.1, i32 0, i32 0
	%7 = load %..string, %..string* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %1, align 1
	call void @os.write_string({i64, i64}* %1, i64 %5, %..string %7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%8 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %2, align 1
	call void @os.write_byte({i64, i64}* %2, i64 %8, i8 40, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%9 = load i64, i64* %0, align 8
	%10 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %_.1, i32 0, i32 1
	%11 = load i64, i64* %10, align 8
	%12 = bitcast i64 %11 to i64
	call void @runtime.print_u64(i64 %9, i64 %12, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%13 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %3, align 1
	call void @os.write_byte({i64, i64}* %3, i64 %13, i8 58, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%14 = load i64, i64* %0, align 8
	%15 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %_.1, i32 0, i32 2
	%16 = load i64, i64* %15, align 8
	%17 = bitcast i64 %16 to i64
	call void @runtime.print_u64(i64 %14, i64 %17, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%18 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %4, align 1
	call void @os.write_byte({i64, i64}* %4, i64 %18, i8 41, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @runtime.print_typeid(i64 %_.0, %..typeid %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %..typeid, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	store i64 %_.0, i64* %0
	store %..typeid %_.1, %..typeid* %1
	; ti
	%3 = load %..typeid, %..typeid* %1, align 8
	%4 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %3)
	store %runtime.Type_Info* %4, %runtime.Type_Info** %2
	%5 = load i64, i64* %0, align 8
	%6 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	call void @runtime.print_type(i64 %5, %runtime.Type_Info* %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @runtime.print_type(i64 %_.0, %runtime.Type_Info* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca {i64, i64}, align 16
	%3 = alloca %runtime.Type_Info_Named, align 16
	%4 = alloca {i64, i64}, align 16
	%5 = alloca %runtime.Type_Info_Integer, align 16
	%6 = alloca {i64, i64}, align 16
	%7 = alloca {i64, i64}, align 16
	%8 = alloca {i64, i64}, align 16
	%9 = alloca {i64, i64}, align 16
	%10 = alloca %runtime.Type_Info_Rune, align 16
	%11 = alloca {i64, i64}, align 16
	%12 = alloca %runtime.Type_Info_Float, align 16
	%13 = alloca {i64, i64}, align 16
	%14 = alloca %runtime.Type_Info_Complex, align 16
	%15 = alloca {i64, i64}, align 16
	%16 = alloca %runtime.Type_Info_String, align 16
	%17 = alloca {i64, i64}, align 16
	%18 = alloca %runtime.Type_Info_Boolean, align 16
	%19 = alloca {i64, i64}, align 16
	%20 = alloca {i64, i64}, align 16
	%21 = alloca %runtime.Type_Info_Any, align 16
	%22 = alloca {i64, i64}, align 16
	%23 = alloca %runtime.Type_Info_Type_Id, align 16
	%24 = alloca {i64, i64}, align 16
	%25 = alloca %runtime.Type_Info_Pointer, align 16
	%26 = alloca {i64, i64}, align 16
	%27 = alloca {i64, i64}, align 16
	%28 = alloca %runtime.Type_Info_Procedure, align 16
	%29 = alloca {i64, i64}, align 16
	%30 = alloca {i64, i64}, align 16
	%31 = alloca %runtime.Type_Info_Tuple, align 16
	%32 = alloca {%runtime.Type_Info_Tuple, i8}, align 16
	%33 = alloca {i64, i64}, align 16
	%34 = alloca %runtime.Type_Info*, align 16
	%35 = alloca i64, align 16
	%36 = alloca i64, align 16
	%37 = alloca i64, align 16
	%38 = alloca {i64, i64}, align 16
	%39 = alloca {i64, i64}, align 16
	%40 = alloca {i64, i64}, align 16
	%41 = alloca %runtime.Type_Info_Tuple, align 16
	%42 = alloca i64, align 16
	%43 = alloca {i64, i64}, align 16
	%44 = alloca %..string, align 16
	%45 = alloca i64, align 16
	%46 = alloca i64, align 16
	%47 = alloca i64, align 16
	%48 = alloca {i64, i64}, align 16
	%49 = alloca %runtime.Type_Info*, align 16
	%50 = alloca {i64, i64}, align 16
	%51 = alloca {i64, i64}, align 16
	%52 = alloca {i64, i64}, align 16
	%53 = alloca %runtime.Type_Info_Array, align 16
	%54 = alloca {i64, i64}, align 16
	%55 = alloca {i64, i64}, align 16
	%56 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%57 = alloca {i64, i64}, align 16
	%58 = alloca %runtime.Type_Info_Slice, align 16
	%59 = alloca {i64, i64}, align 16
	%60 = alloca %runtime.Type_Info_Map, align 16
	%61 = alloca {i64, i64}, align 16
	%62 = alloca {i64, i64}, align 16
	%63 = alloca %runtime.Type_Info_Struct, align 16
	%64 = alloca {i64, i64}, align 16
	%65 = alloca {i64, i64}, align 16
	%66 = alloca {i64, i64}, align 16
	%67 = alloca {i64, i64}, align 16
	%68 = alloca {i64, i64}, align 16
	%69 = alloca {i64, i64}, align 16
	%70 = alloca %..string, align 16
	%71 = alloca i64, align 16
	%72 = alloca i64, align 16
	%73 = alloca i64, align 16
	%74 = alloca {i64, i64}, align 16
	%75 = alloca {i64, i64}, align 16
	%76 = alloca {i64, i64}, align 16
	%77 = alloca {i64, i64}, align 16
	%78 = alloca %runtime.Type_Info_Union, align 16
	%79 = alloca {i64, i64}, align 16
	%80 = alloca %runtime.Type_Info*, align 16
	%81 = alloca i64, align 16
	%82 = alloca i64, align 16
	%83 = alloca i64, align 16
	%84 = alloca {i64, i64}, align 16
	%85 = alloca {i64, i64}, align 16
	%86 = alloca %runtime.Type_Info_Enum, align 16
	%87 = alloca {i64, i64}, align 16
	%88 = alloca {i64, i64}, align 16
	%89 = alloca %..string, align 16
	%90 = alloca i64, align 16
	%91 = alloca i64, align 16
	%92 = alloca i64, align 16
	%93 = alloca {i64, i64}, align 16
	%94 = alloca {i64, i64}, align 16
	%95 = alloca {i64, i64}, align 16
	%96 = alloca %runtime.Type_Info_Bit_Field, align 16
	%97 = alloca {i64, i64}, align 16
	%98 = alloca {i64, i64}, align 16
	%99 = alloca {i64, i64}, align 16
	%100 = alloca {i64, i64}, align 16
	%101 = alloca %..string, align 16
	%102 = alloca i64, align 16
	%103 = alloca i64, align 16
	%104 = alloca i64, align 16
	%105 = alloca {i64, i64}, align 16
	%106 = alloca {i64, i64}, align 16
	%107 = alloca {i64, i64}, align 16
	%108 = alloca {i64, i64}, align 16
	%109 = alloca %runtime.Type_Info_Bit_Set, align 16
	%110 = alloca {i64, i64}, align 16
	%111 = alloca %runtime.Type_Info*, align 16
	%112 = alloca %runtime.Type_Info_Enum, align 16
	%113 = alloca %runtime.Type_Info_Rune, align 16
	%114 = alloca {i64, i64}, align 16
	%115 = alloca {[0 x i64], [88 x i8], i64}, align 16
	%116 = alloca {i64, i64}, align 16
	%117 = alloca {i64, i64}, align 16
	%118 = alloca {i64, i64}, align 16
	%119 = alloca %runtime.Type_Info_Opaque, align 16
	%120 = alloca {i64, i64}, align 16
	%121 = alloca %runtime.Type_Info_Simd_Vector, align 16
	%122 = alloca {i64, i64}, align 16
	%123 = alloca {i64, i64}, align 16
	%124 = alloca {i64, i64}, align 16
	%125 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store %runtime.Type_Info* %_.1, %runtime.Type_Info** %1
	; IfStmt
	%126 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%127 = icmp eq %runtime.Type_Info* %126, zeroinitializer
	%128 = zext i1 %127 to i8
	%129 = trunc i8 %128 to i1
	br i1 %129, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%130 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %2, align 1
	call void @os.write_string({i64, i64}* %2, i64 %130, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$d, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; TypeSwitchStmt
	; SelectorExpr
	%131 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%132 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %131, i32 0, i32 3
	; get union's tag
	%133 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %132, i64 0, i32 2 ; UnionTagPtr
	%134 = load i64, i64* %133, align 8
	%135 = bitcast {[0 x i64], [88 x i8], i64}* %132 to %..rawptr
	%136 = icmp eq i64 %134, 1
	br i1 %136, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%137 = icmp eq i64 %134, 2
	br i1 %137, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%138 = bitcast %..rawptr %135 to %runtime.Type_Info_Named*
	%139 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %138, align 8
	store %runtime.Type_Info_Named %139, %runtime.Type_Info_Named* %3
	; SelectorExpr
	%140 = load i64, i64* %0, align 8
	; SelectorExpr
	%141 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %3, i32 0, i32 0
	%142 = load %..string, %..string* %141, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %4, align 1
	call void @os.write_string({i64, i64}* %4, i64 %140, %..string %142, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-5:
	%143 = icmp eq i64 %134, 3
	br i1 %143, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-6:
	%144 = bitcast %..rawptr %135 to %runtime.Type_Info_Integer*
	%145 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %144, align 1
	store %runtime.Type_Info_Integer %145, %runtime.Type_Info_Integer* %5
	; SwitchStmt
	; SelectorExpr
	%146 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%147 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %146, i32 0, i32 2
	%148 = load %..typeid, %..typeid* %147, align 8
	%149 = icmp eq %..typeid %148, 4683743612465315844
	br i1 %149, label %switch.case.body-8, label %switch.case.next-7

switch.case.next-7:
	%150 = icmp eq %..typeid %148, 72057594037928008
	br i1 %150, label %switch.fall.body-10, label %switch.case.next-9

switch.case.body-8:
	; SelectorExpr
	%151 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %6, align 1
	call void @os.write_string({i64, i64}* %6, i64 %151, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$e, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-16

switch.case.next-9:
	%152 = icmp eq %..typeid %148, 72057594037927989
	br i1 %152, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; SelectorExpr
	%153 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %7, align 1
	call void @os.write_string({i64, i64}* %7, i64 %153, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$f, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-16

switch.case.next-11:
	; SelectorExpr
	%154 = load i64, i64* %0, align 8
	; TernaryExpr
	; SelectorExpr
	%155 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %5, i32 0, i32 0
	%156 = load i8, i8* %155, align 1
	%157 = trunc i8 %156 to i1
	br i1 %157, label %if.then-13, label %if.else-14

switch.fall.body-12:
	; SelectorExpr
	%158 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %8, align 1
	call void @os.write_string({i64, i64}* %8, i64 %158, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$10, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-16

if.then-13:
	br label %if.done-15

if.else-14:
	br label %if.done-15

if.done-15:
	%159 = phi i32 [ 105, %if.then-13 ], [ 117, %if.else-14 ]
	%160 = trunc i32 %159 to i8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %9, align 1
	call void @os.write_byte({i64, i64}* %9, i64 %154, i8 %160, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%161 = load i64, i64* %0, align 8
	; SelectorExpr
	%162 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%163 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %162, i32 0, i32 0
	%164 = load i64, i64* %163, align 8
	%165 = mul i64 8, %164
	%166 = bitcast i64 %165 to i64
	call void @runtime.print_u64(i64 %161, i64 %166, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-16

switch.done-16:
	br label %typeswitch.done-126

typeswitch.next-17:
	%167 = icmp eq i64 %134, 4
	br i1 %167, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%168 = bitcast %..rawptr %135 to %runtime.Type_Info_Rune*
	%169 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %168, align 1
	store %runtime.Type_Info_Rune %169, %runtime.Type_Info_Rune* %10
	; SelectorExpr
	%170 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %11, align 1
	call void @os.write_string({i64, i64}* %11, i64 %170, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$11, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-19:
	%171 = icmp eq i64 %134, 5
	br i1 %171, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%172 = bitcast %..rawptr %135 to %runtime.Type_Info_Float*
	%173 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %172, align 1
	store %runtime.Type_Info_Float %173, %runtime.Type_Info_Float* %12
	; SelectorExpr
	%174 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %13, align 1
	call void @os.write_byte({i64, i64}* %13, i64 %174, i8 102, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%175 = load i64, i64* %0, align 8
	; SelectorExpr
	%176 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%177 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %176, i32 0, i32 0
	%178 = load i64, i64* %177, align 8
	%179 = mul i64 8, %178
	%180 = bitcast i64 %179 to i64
	call void @runtime.print_u64(i64 %175, i64 %180, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-21:
	%181 = icmp eq i64 %134, 7
	br i1 %181, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%182 = bitcast %..rawptr %135 to %runtime.Type_Info_Complex*
	%183 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %182, align 1
	store %runtime.Type_Info_Complex %183, %runtime.Type_Info_Complex* %14
	; SelectorExpr
	%184 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %15, align 1
	call void @os.write_string({i64, i64}* %15, i64 %184, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$12, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%185 = load i64, i64* %0, align 8
	; SelectorExpr
	%186 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%187 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %186, i32 0, i32 0
	%188 = load i64, i64* %187, align 8
	%189 = mul i64 8, %188
	%190 = bitcast i64 %189 to i64
	call void @runtime.print_u64(i64 %185, i64 %190, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-23:
	%191 = icmp eq i64 %134, 8
	br i1 %191, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%192 = bitcast %..rawptr %135 to %runtime.Type_Info_String*
	%193 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %192, align 1
	store %runtime.Type_Info_String %193, %runtime.Type_Info_String* %16
	; SelectorExpr
	%194 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %17, align 1
	call void @os.write_string({i64, i64}* %17, i64 %194, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$13, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-25:
	%195 = icmp eq i64 %134, 9
	br i1 %195, label %typeswitch.body-31, label %typeswitch.next-30

typeswitch.body-26:
	%196 = bitcast %..rawptr %135 to %runtime.Type_Info_Boolean*
	%197 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %196, align 1
	store %runtime.Type_Info_Boolean %197, %runtime.Type_Info_Boolean* %18
	; SwitchStmt
	; SelectorExpr
	%198 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %198, i32 0, i32 2
	%200 = load %..typeid, %..typeid* %199, align 8
	%201 = icmp eq %..typeid %200, 504403158265495572
	br i1 %201, label %switch.case.body-28, label %switch.case.next-27

switch.case.next-27:
	; SelectorExpr
	%202 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %20, align 1
	call void @os.write_byte({i64, i64}* %20, i64 %202, i8 98, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%203 = load i64, i64* %0, align 8
	; SelectorExpr
	%204 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%205 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %204, i32 0, i32 0
	%206 = load i64, i64* %205, align 8
	%207 = mul i64 8, %206
	%208 = bitcast i64 %207 to i64
	call void @runtime.print_u64(i64 %203, i64 %208, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.body-28:
	; SelectorExpr
	%209 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %19, align 1
	call void @os.write_string({i64, i64}* %19, i64 %209, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$14, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.done-29:
	br label %typeswitch.done-126

typeswitch.next-30:
	%210 = icmp eq i64 %134, 10
	br i1 %210, label %typeswitch.body-33, label %typeswitch.next-32

typeswitch.body-31:
	%211 = bitcast %..rawptr %135 to %runtime.Type_Info_Any*
	%212 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %211, align 1
	store %runtime.Type_Info_Any %212, %runtime.Type_Info_Any* %21
	; SelectorExpr
	%213 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %22, align 1
	call void @os.write_string({i64, i64}* %22, i64 %213, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$15, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-32:
	%214 = icmp eq i64 %134, 11
	br i1 %214, label %typeswitch.body-35, label %typeswitch.next-34

typeswitch.body-33:
	%215 = bitcast %..rawptr %135 to %runtime.Type_Info_Type_Id*
	%216 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %215, align 1
	store %runtime.Type_Info_Type_Id %216, %runtime.Type_Info_Type_Id* %23
	; SelectorExpr
	%217 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %24, align 1
	call void @os.write_string({i64, i64}* %24, i64 %217, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$16, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-34:
	%218 = icmp eq i64 %134, 12
	br i1 %218, label %typeswitch.body-40, label %typeswitch.next-39

typeswitch.body-35:
	%219 = bitcast %..rawptr %135 to %runtime.Type_Info_Pointer*
	%220 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %219, align 8
	store %runtime.Type_Info_Pointer %220, %runtime.Type_Info_Pointer* %25
	; IfStmt
	; SelectorExpr
	%221 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %25, i32 0, i32 0
	%222 = load %runtime.Type_Info*, %runtime.Type_Info** %221, align 8
	%223 = icmp eq %runtime.Type_Info* %222, zeroinitializer
	%224 = zext i1 %223 to i8
	%225 = trunc i8 %224 to i1
	br i1 %225, label %if.then-36, label %if.else-37

if.then-36:
	; SelectorExpr
	%226 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %26, align 1
	call void @os.write_string({i64, i64}* %26, i64 %226, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$17, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-38

if.else-37:
	; SelectorExpr
	%227 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %27, align 1
	call void @os.write_string({i64, i64}* %27, i64 %227, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$18, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%228 = load i64, i64* %0, align 8
	; SelectorExpr
	%229 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %25, i32 0, i32 0
	%230 = load %runtime.Type_Info*, %runtime.Type_Info** %229, align 8
	call void @runtime.print_type(i64 %228, %runtime.Type_Info* %230, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-38

if.done-38:
	br label %typeswitch.done-126

typeswitch.next-39:
	%231 = icmp eq i64 %134, 16
	br i1 %231, label %typeswitch.body-54, label %typeswitch.next-53

typeswitch.body-40:
	%232 = bitcast %..rawptr %135 to %runtime.Type_Info_Procedure*
	%233 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %232, align 8
	store %runtime.Type_Info_Procedure %233, %runtime.Type_Info_Procedure* %28
	; SelectorExpr
	%234 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %29, align 1
	call void @os.write_string({i64, i64}* %29, i64 %234, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$19, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%235 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %28, i32 0, i32 0
	%236 = load %runtime.Type_Info*, %runtime.Type_Info** %235, align 8
	%237 = icmp eq %runtime.Type_Info* %236, zeroinitializer
	%238 = zext i1 %237 to i8
	%239 = trunc i8 %238 to i1
	br i1 %239, label %if.then-41, label %if.else-42

if.then-41:
	; SelectorExpr
	%240 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %30, align 1
	call void @os.write_string({i64, i64}* %30, i64 %240, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1a, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-50

if.else-42:
	; t
	; SelectorExpr
	; SelectorExpr
	%241 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %28, i32 0, i32 0
	%242 = load %runtime.Type_Info*, %runtime.Type_Info** %241, align 8
	%243 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %242, i32 0, i32 3
	; cast - union_cast
	%244 = bitcast {%runtime.Type_Info_Tuple, i8}* %32 to %..rawptr
	; ZeroInit
	%245 = call %..rawptr @mem.zero(%..rawptr %244, i64 40)
	%246 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %243, i64 0, i32 2 ; UnionTagPtr
	%247 = load i64, i64* %246, align 8
	%248 = icmp eq i64 %247, 16
	br i1 %248, label %union_cast.ok-43, label %union_cast.end-44

union_cast.ok-43:
	%249 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %32, i32 0, i32 0
	%250 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %32, i32 0, i32 1
	%251 = bitcast {[0 x i64], [88 x i8], i64}* %243 to %runtime.Type_Info_Tuple*
	%252 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %251, align 8
	store %runtime.Type_Info_Tuple %252, %runtime.Type_Info_Tuple* %249
	store i8 1, i8* %250
	br label %union_cast.end-44

union_cast.end-44:
	%253 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %32, i32 0, i32 1
	%254 = load i8, i8* %253, align 1
	%255 = trunc i8 %254 to i1
	call void @runtime.type_assertion_check(i1 %255, %..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$1b, i32 0, i32 0), i64 66}, i64 110, i64 21, %..typeid 1224979098644774922, %..typeid 3458764513820540972)
	%256 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %32, i32 0, i32 0
	%257 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %256, align 8
	store %runtime.Type_Info_Tuple %257, %runtime.Type_Info_Tuple* %31
	; SelectorExpr
	%258 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %33, align 1
	call void @os.write_string({i64, i64}* %33, i64 %258, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1c, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; t
	; ZeroInit
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %34, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %35, align 1
	; SelectorExpr
	%259 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %31, i32 0, i32 0
	%260 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %259, align 8
	%261 = extractvalue {%runtime.Type_Info**, i64} %260, 1
	store i64 %261, i64* %36
	store i64 -1, i64* %37
	br label %for.index.loop-45

for.index.loop-45:
	%262 = load i64, i64* %37, align 8
	%263 = add i64 %262, 1
	store i64 %263, i64* %37
	%264 = load i64, i64* %36, align 8
	%265 = icmp slt i64 %263, %264
	br i1 %265, label %for.index.body-46, label %for.index.done-49

for.index.body-46:
	%266 = load i64, i64* %37, align 8
	%267 = extractvalue {%runtime.Type_Info**, i64} %260, 0
	%268 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %267, i64 %266
	%269 = load %runtime.Type_Info*, %runtime.Type_Info** %268, align 8
	store %runtime.Type_Info* %269, %runtime.Type_Info** %34
	store i64 %266, i64* %35
	; IfStmt
	%270 = load i64, i64* %35, align 8
	%271 = icmp sgt i64 %270, 0
	%272 = zext i1 %271 to i8
	%273 = trunc i8 %272 to i1
	br i1 %273, label %if.then-47, label %if.done-48

if.then-47:
	; SelectorExpr
	%274 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %38, align 1
	call void @os.write_string({i64, i64}* %38, i64 %274, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1d, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-48

if.done-48:
	%275 = load i64, i64* %0, align 8
	%276 = load %runtime.Type_Info*, %runtime.Type_Info** %34, align 8
	call void @runtime.print_type(i64 %275, %runtime.Type_Info* %276, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-45

for.index.done-49:
	; SelectorExpr
	%277 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %39, align 1
	call void @os.write_string({i64, i64}* %39, i64 %277, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1e, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-50

if.done-50:
	; IfStmt
	; SelectorExpr
	%278 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %28, i32 0, i32 1
	%279 = load %runtime.Type_Info*, %runtime.Type_Info** %278, align 8
	%280 = icmp ne %runtime.Type_Info* %279, zeroinitializer
	%281 = zext i1 %280 to i8
	%282 = trunc i8 %281 to i1
	br i1 %282, label %if.then-51, label %if.done-52

if.then-51:
	; SelectorExpr
	%283 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %40, align 1
	call void @os.write_string({i64, i64}* %40, i64 %283, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1f, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%284 = load i64, i64* %0, align 8
	; SelectorExpr
	%285 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %28, i32 0, i32 1
	%286 = load %runtime.Type_Info*, %runtime.Type_Info** %285, align 8
	call void @runtime.print_type(i64 %284, %runtime.Type_Info* %286, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-52

if.done-52:
	br label %typeswitch.done-126

typeswitch.next-53:
	%287 = icmp eq i64 %134, 13
	br i1 %287, label %typeswitch.body-67, label %typeswitch.next-66

typeswitch.body-54:
	%288 = bitcast %..rawptr %135 to %runtime.Type_Info_Tuple*
	%289 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %288, align 8
	store %runtime.Type_Info_Tuple %289, %runtime.Type_Info_Tuple* %41
	; count
	; SelectorExpr
	%290 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %41, i32 0, i32 1
	%291 = load {%..string*, i64}, {%..string*, i64}* %290, align 8
	%292 = extractvalue {%..string*, i64} %291, 1
	store i64 %292, i64* %42
	; IfStmt
	%293 = load i64, i64* %42, align 8
	%294 = icmp ne i64 %293, 1
	%295 = zext i1 %294 to i8
	%296 = trunc i8 %295 to i1
	br i1 %296, label %if.then-55, label %if.done-56

if.then-55:
	; SelectorExpr
	%297 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %43, align 1
	call void @os.write_string({i64, i64}* %43, i64 %297, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$20, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-56

if.done-56:
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %44, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %45, align 1
	; SelectorExpr
	%298 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %41, i32 0, i32 1
	%299 = load {%..string*, i64}, {%..string*, i64}* %298, align 8
	%300 = extractvalue {%..string*, i64} %299, 1
	store i64 %300, i64* %46
	store i64 -1, i64* %47
	br label %for.index.loop-57

for.index.loop-57:
	%301 = load i64, i64* %47, align 8
	%302 = add i64 %301, 1
	store i64 %302, i64* %47
	%303 = load i64, i64* %46, align 8
	%304 = icmp slt i64 %302, %303
	br i1 %304, label %for.index.body-58, label %for.index.done-63

for.index.body-58:
	%305 = load i64, i64* %47, align 8
	%306 = extractvalue {%..string*, i64} %299, 0
	%307 = getelementptr inbounds %..string, %..string* %306, i64 %305
	%308 = load %..string, %..string* %307, align 8
	store %..string %308, %..string* %44
	store i64 %305, i64* %45
	; IfStmt
	%309 = load i64, i64* %45, align 8
	%310 = icmp sgt i64 %309, 0
	%311 = zext i1 %310 to i8
	%312 = trunc i8 %311 to i1
	br i1 %312, label %if.then-59, label %if.done-60

if.then-59:
	; SelectorExpr
	%313 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %48, align 1
	call void @os.write_string({i64, i64}* %48, i64 %313, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$21, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-60

if.done-60:
	; t
	; IndexExpr
	; SelectorExpr
	%314 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %41, i32 0, i32 0
	%315 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %314, align 8
	%316 = extractvalue {%runtime.Type_Info**, i64} %315, 0
	%317 = load i64, i64* %45, align 8
	%318 = extractvalue {%runtime.Type_Info**, i64} %315, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$22, i32 0, i32 0), i64 66}, i64 128, i64 20, i64 %317, i64 %318)
	%319 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %316, i64 %317
	%320 = load %runtime.Type_Info*, %runtime.Type_Info** %319, align 8
	store %runtime.Type_Info* %320, %runtime.Type_Info** %49
	; IfStmt
	%321 = load %..string, %..string* %44, align 8
	%322 = extractvalue %..string %321, 1
	%323 = icmp sgt i64 %322, 0
	%324 = zext i1 %323 to i8
	%325 = trunc i8 %324 to i1
	br i1 %325, label %if.then-61, label %if.done-62

if.then-61:
	; SelectorExpr
	%326 = load i64, i64* %0, align 8
	%327 = load %..string, %..string* %44, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %50, align 1
	call void @os.write_string({i64, i64}* %50, i64 %326, %..string %327, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%328 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %51, align 1
	call void @os.write_string({i64, i64}* %51, i64 %328, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$23, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-62

if.done-62:
	%329 = load i64, i64* %0, align 8
	%330 = load %runtime.Type_Info*, %runtime.Type_Info** %49, align 8
	call void @runtime.print_type(i64 %329, %runtime.Type_Info* %330, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-57

for.index.done-63:
	; IfStmt
	%331 = load i64, i64* %42, align 8
	%332 = icmp ne i64 %331, 1
	%333 = zext i1 %332 to i8
	%334 = trunc i8 %333 to i1
	br i1 %334, label %if.then-64, label %if.done-65

if.then-64:
	; SelectorExpr
	%335 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %52, align 1
	call void @os.write_string({i64, i64}* %52, i64 %335, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$24, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-65

if.done-65:
	br label %typeswitch.done-126

typeswitch.next-66:
	%336 = icmp eq i64 %134, 14
	br i1 %336, label %typeswitch.body-69, label %typeswitch.next-68

typeswitch.body-67:
	%337 = bitcast %..rawptr %135 to %runtime.Type_Info_Array*
	%338 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %337, align 8
	store %runtime.Type_Info_Array %338, %runtime.Type_Info_Array* %53
	; SelectorExpr
	%339 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %54, align 1
	call void @os.write_string({i64, i64}* %54, i64 %339, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$25, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%340 = load i64, i64* %0, align 8
	; SelectorExpr
	%341 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %53, i32 0, i32 2
	%342 = load i64, i64* %341, align 8
	%343 = bitcast i64 %342 to i64
	call void @runtime.print_u64(i64 %340, i64 %343, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%344 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %55, align 1
	call void @os.write_string({i64, i64}* %55, i64 %344, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$26, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%345 = load i64, i64* %0, align 8
	; SelectorExpr
	%346 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %53, i32 0, i32 0
	%347 = load %runtime.Type_Info*, %runtime.Type_Info** %346, align 8
	call void @runtime.print_type(i64 %345, %runtime.Type_Info* %347, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-68:
	%348 = icmp eq i64 %134, 15
	br i1 %348, label %typeswitch.body-71, label %typeswitch.next-70

typeswitch.body-69:
	%349 = bitcast %..rawptr %135 to %runtime.Type_Info_Dynamic_Array*
	%350 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %349, align 8
	store %runtime.Type_Info_Dynamic_Array %350, %runtime.Type_Info_Dynamic_Array* %56
	; SelectorExpr
	%351 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %57, align 1
	call void @os.write_string({i64, i64}* %57, i64 %351, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$27, i32 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%352 = load i64, i64* %0, align 8
	; SelectorExpr
	%353 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %56, i32 0, i32 0
	%354 = load %runtime.Type_Info*, %runtime.Type_Info** %353, align 8
	call void @runtime.print_type(i64 %352, %runtime.Type_Info* %354, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-70:
	%355 = icmp eq i64 %134, 20
	br i1 %355, label %typeswitch.body-73, label %typeswitch.next-72

typeswitch.body-71:
	%356 = bitcast %..rawptr %135 to %runtime.Type_Info_Slice*
	%357 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %356, align 8
	store %runtime.Type_Info_Slice %357, %runtime.Type_Info_Slice* %58
	; SelectorExpr
	%358 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %59, align 1
	call void @os.write_string({i64, i64}* %59, i64 %358, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$28, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%359 = load i64, i64* %0, align 8
	; SelectorExpr
	%360 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %58, i32 0, i32 0
	%361 = load %runtime.Type_Info*, %runtime.Type_Info** %360, align 8
	call void @runtime.print_type(i64 %359, %runtime.Type_Info* %361, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-72:
	%362 = icmp eq i64 %134, 17
	br i1 %362, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-73:
	%363 = bitcast %..rawptr %135 to %runtime.Type_Info_Map*
	%364 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %363, align 8
	store %runtime.Type_Info_Map %364, %runtime.Type_Info_Map* %60
	; SelectorExpr
	%365 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %61, align 1
	call void @os.write_string({i64, i64}* %61, i64 %365, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$29, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%366 = load i64, i64* %0, align 8
	; SelectorExpr
	%367 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %60, i32 0, i32 0
	%368 = load %runtime.Type_Info*, %runtime.Type_Info** %367, align 8
	call void @runtime.print_type(i64 %366, %runtime.Type_Info* %368, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%369 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %62, align 1
	call void @os.write_byte({i64, i64}* %62, i64 %369, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%370 = load i64, i64* %0, align 8
	; SelectorExpr
	%371 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %60, i32 0, i32 1
	%372 = load %runtime.Type_Info*, %runtime.Type_Info** %371, align 8
	call void @runtime.print_type(i64 %370, %runtime.Type_Info* %372, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-74:
	%373 = icmp eq i64 %134, 18
	br i1 %373, label %typeswitch.body-88, label %typeswitch.next-87

typeswitch.body-75:
	%374 = bitcast %..rawptr %135 to %runtime.Type_Info_Struct*
	%375 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %374, align 8
	store %runtime.Type_Info_Struct %375, %runtime.Type_Info_Struct* %63
	; SelectorExpr
	%376 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %64, align 1
	call void @os.write_string({i64, i64}* %64, i64 %376, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2a, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%377 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %63, i32 0, i32 5
	%378 = load i8, i8* %377, align 1
	%379 = trunc i8 %378 to i1
	br i1 %379, label %if.then-76, label %if.done-77

if.then-76:
	; SelectorExpr
	%380 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %65, align 1
	call void @os.write_string({i64, i64}* %65, i64 %380, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$2b, i32 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-77

if.done-77:
	; IfStmt
	; SelectorExpr
	%381 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %63, i32 0, i32 6
	%382 = load i8, i8* %381, align 1
	%383 = trunc i8 %382 to i1
	br i1 %383, label %if.then-78, label %if.done-79

if.then-78:
	; SelectorExpr
	%384 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %66, align 1
	call void @os.write_string({i64, i64}* %66, i64 %384, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$2c, i32 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-79

if.done-79:
	; IfStmt
	; SelectorExpr
	%385 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %63, i32 0, i32 7
	%386 = load i8, i8* %385, align 1
	%387 = trunc i8 %386 to i1
	br i1 %387, label %if.then-80, label %if.done-81

if.then-80:
	; SelectorExpr
	%388 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %67, align 1
	call void @os.write_string({i64, i64}* %67, i64 %388, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$2d, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%389 = load i64, i64* %0, align 8
	; SelectorExpr
	%390 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%391 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %390, i32 0, i32 1
	%392 = load i64, i64* %391, align 8
	%393 = bitcast i64 %392 to i64
	call void @runtime.print_u64(i64 %389, i64 %393, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%394 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %68, align 1
	call void @os.write_byte({i64, i64}* %68, i64 %394, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-81

if.done-81:
	; SelectorExpr
	%395 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %69, align 1
	call void @os.write_byte({i64, i64}* %69, i64 %395, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %70, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %71, align 1
	; SelectorExpr
	%396 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %63, i32 0, i32 1
	%397 = load {%..string*, i64}, {%..string*, i64}* %396, align 8
	%398 = extractvalue {%..string*, i64} %397, 1
	store i64 %398, i64* %72
	store i64 -1, i64* %73
	br label %for.index.loop-82

for.index.loop-82:
	%399 = load i64, i64* %73, align 8
	%400 = add i64 %399, 1
	store i64 %400, i64* %73
	%401 = load i64, i64* %72, align 8
	%402 = icmp slt i64 %400, %401
	br i1 %402, label %for.index.body-83, label %for.index.done-86

for.index.body-83:
	%403 = load i64, i64* %73, align 8
	%404 = extractvalue {%..string*, i64} %397, 0
	%405 = getelementptr inbounds %..string, %..string* %404, i64 %403
	%406 = load %..string, %..string* %405, align 8
	store %..string %406, %..string* %70
	store i64 %403, i64* %71
	; IfStmt
	%407 = load i64, i64* %71, align 8
	%408 = icmp sgt i64 %407, 0
	%409 = zext i1 %408 to i8
	%410 = trunc i8 %409 to i1
	br i1 %410, label %if.then-84, label %if.done-85

if.then-84:
	; SelectorExpr
	%411 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %74, align 1
	call void @os.write_string({i64, i64}* %74, i64 %411, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$2e, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-85

if.done-85:
	; SelectorExpr
	%412 = load i64, i64* %0, align 8
	%413 = load %..string, %..string* %70, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %75, align 1
	call void @os.write_string({i64, i64}* %75, i64 %412, %..string %413, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%414 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %76, align 1
	call void @os.write_string({i64, i64}* %76, i64 %414, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$2f, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%415 = load i64, i64* %0, align 8
	; IndexExpr
	; SelectorExpr
	%416 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %63, i32 0, i32 0
	%417 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %416, align 8
	%418 = extractvalue {%runtime.Type_Info**, i64} %417, 0
	%419 = load i64, i64* %71, align 8
	%420 = extractvalue {%runtime.Type_Info**, i64} %417, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$30, i32 0, i32 0), i64 66}, i64 170, i64 30, i64 %419, i64 %420)
	%421 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %418, i64 %419
	%422 = load %runtime.Type_Info*, %runtime.Type_Info** %421, align 8
	call void @runtime.print_type(i64 %415, %runtime.Type_Info* %422, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-82

for.index.done-86:
	; SelectorExpr
	%423 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %77, align 1
	call void @os.write_byte({i64, i64}* %77, i64 %423, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-87:
	%424 = icmp eq i64 %134, 19
	br i1 %424, label %typeswitch.body-95, label %typeswitch.next-94

typeswitch.body-88:
	%425 = bitcast %..rawptr %135 to %runtime.Type_Info_Union*
	%426 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %425, align 8
	store %runtime.Type_Info_Union %426, %runtime.Type_Info_Union* %78
	; SelectorExpr
	%427 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %79, align 1
	call void @os.write_string({i64, i64}* %79, i64 %427, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$31, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; variant
	; ZeroInit
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %80, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %81, align 1
	; SelectorExpr
	%428 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %78, i32 0, i32 0
	%429 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %428, align 8
	%430 = extractvalue {%runtime.Type_Info**, i64} %429, 1
	store i64 %430, i64* %82
	store i64 -1, i64* %83
	br label %for.index.loop-89

for.index.loop-89:
	%431 = load i64, i64* %83, align 8
	%432 = add i64 %431, 1
	store i64 %432, i64* %83
	%433 = load i64, i64* %82, align 8
	%434 = icmp slt i64 %432, %433
	br i1 %434, label %for.index.body-90, label %for.index.done-93

for.index.body-90:
	%435 = load i64, i64* %83, align 8
	%436 = extractvalue {%runtime.Type_Info**, i64} %429, 0
	%437 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %436, i64 %435
	%438 = load %runtime.Type_Info*, %runtime.Type_Info** %437, align 8
	store %runtime.Type_Info* %438, %runtime.Type_Info** %80
	store i64 %435, i64* %81
	; IfStmt
	%439 = load i64, i64* %81, align 8
	%440 = icmp sgt i64 %439, 0
	%441 = zext i1 %440 to i8
	%442 = trunc i8 %441 to i1
	br i1 %442, label %if.then-91, label %if.done-92

if.then-91:
	; SelectorExpr
	%443 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %84, align 1
	call void @os.write_string({i64, i64}* %84, i64 %443, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$32, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-92

if.done-92:
	%444 = load i64, i64* %0, align 8
	%445 = load %runtime.Type_Info*, %runtime.Type_Info** %80, align 8
	call void @runtime.print_type(i64 %444, %runtime.Type_Info* %445, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-89

for.index.done-93:
	; SelectorExpr
	%446 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %85, align 1
	call void @os.write_string({i64, i64}* %85, i64 %446, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$33, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-94:
	%447 = icmp eq i64 %134, 21
	br i1 %447, label %typeswitch.body-102, label %typeswitch.next-101

typeswitch.body-95:
	%448 = bitcast %..rawptr %135 to %runtime.Type_Info_Enum*
	%449 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %448, align 8
	store %runtime.Type_Info_Enum %449, %runtime.Type_Info_Enum* %86
	; SelectorExpr
	%450 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %87, align 1
	call void @os.write_string({i64, i64}* %87, i64 %450, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$34, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%451 = load i64, i64* %0, align 8
	; SelectorExpr
	%452 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %86, i32 0, i32 0
	%453 = load %runtime.Type_Info*, %runtime.Type_Info** %452, align 8
	call void @runtime.print_type(i64 %451, %runtime.Type_Info* %453, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%454 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %88, align 1
	call void @os.write_string({i64, i64}* %88, i64 %454, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$35, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %89, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %90, align 1
	; SelectorExpr
	%455 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %86, i32 0, i32 1
	%456 = load {%..string*, i64}, {%..string*, i64}* %455, align 8
	%457 = extractvalue {%..string*, i64} %456, 1
	store i64 %457, i64* %91
	store i64 -1, i64* %92
	br label %for.index.loop-96

for.index.loop-96:
	%458 = load i64, i64* %92, align 8
	%459 = add i64 %458, 1
	store i64 %459, i64* %92
	%460 = load i64, i64* %91, align 8
	%461 = icmp slt i64 %459, %460
	br i1 %461, label %for.index.body-97, label %for.index.done-100

for.index.body-97:
	%462 = load i64, i64* %92, align 8
	%463 = extractvalue {%..string*, i64} %456, 0
	%464 = getelementptr inbounds %..string, %..string* %463, i64 %462
	%465 = load %..string, %..string* %464, align 8
	store %..string %465, %..string* %89
	store i64 %462, i64* %90
	; IfStmt
	%466 = load i64, i64* %90, align 8
	%467 = icmp sgt i64 %466, 0
	%468 = zext i1 %467 to i8
	%469 = trunc i8 %468 to i1
	br i1 %469, label %if.then-98, label %if.done-99

if.then-98:
	; SelectorExpr
	%470 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %93, align 1
	call void @os.write_string({i64, i64}* %93, i64 %470, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$36, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-99

if.done-99:
	; SelectorExpr
	%471 = load i64, i64* %0, align 8
	%472 = load %..string, %..string* %89, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %94, align 1
	call void @os.write_string({i64, i64}* %94, i64 %471, %..string %472, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-96

for.index.done-100:
	; SelectorExpr
	%473 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %95, align 1
	call void @os.write_string({i64, i64}* %95, i64 %473, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$37, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-101:
	%474 = icmp eq i64 %134, 22
	br i1 %474, label %typeswitch.body-111, label %typeswitch.next-110

typeswitch.body-102:
	%475 = bitcast %..rawptr %135 to %runtime.Type_Info_Bit_Field*
	%476 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %475, align 8
	store %runtime.Type_Info_Bit_Field %476, %runtime.Type_Info_Bit_Field* %96
	; SelectorExpr
	%477 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %97, align 1
	call void @os.write_string({i64, i64}* %97, i64 %477, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$38, i32 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%478 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%479 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %478, i32 0, i32 1
	%480 = load i64, i64* %479, align 8
	%481 = icmp ne i64 %480, 1
	%482 = zext i1 %481 to i8
	%483 = trunc i8 %482 to i1
	br i1 %483, label %if.then-103, label %if.done-104

if.then-103:
	; SelectorExpr
	%484 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %98, align 1
	call void @os.write_string({i64, i64}* %98, i64 %484, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$39, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%485 = load i64, i64* %0, align 8
	; SelectorExpr
	%486 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%487 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %486, i32 0, i32 1
	%488 = load i64, i64* %487, align 8
	%489 = bitcast i64 %488 to i64
	call void @runtime.print_u64(i64 %485, i64 %489, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%490 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %99, align 1
	call void @os.write_byte({i64, i64}* %99, i64 %490, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-104

if.done-104:
	; SelectorExpr
	%491 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %100, align 1
	call void @os.write_string({i64, i64}* %100, i64 %491, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3a, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %101, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %102, align 1
	; SelectorExpr
	%492 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %96, i32 0, i32 0
	%493 = load {%..string*, i64}, {%..string*, i64}* %492, align 8
	%494 = extractvalue {%..string*, i64} %493, 1
	store i64 %494, i64* %103
	store i64 -1, i64* %104
	br label %for.index.loop-105

for.index.loop-105:
	%495 = load i64, i64* %104, align 8
	%496 = add i64 %495, 1
	store i64 %496, i64* %104
	%497 = load i64, i64* %103, align 8
	%498 = icmp slt i64 %496, %497
	br i1 %498, label %for.index.body-106, label %for.index.done-109

for.index.body-106:
	%499 = load i64, i64* %104, align 8
	%500 = extractvalue {%..string*, i64} %493, 0
	%501 = getelementptr inbounds %..string, %..string* %500, i64 %499
	%502 = load %..string, %..string* %501, align 8
	store %..string %502, %..string* %101
	store i64 %499, i64* %102
	; IfStmt
	%503 = load i64, i64* %102, align 8
	%504 = icmp sgt i64 %503, 0
	%505 = zext i1 %504 to i8
	%506 = trunc i8 %505 to i1
	br i1 %506, label %if.then-107, label %if.done-108

if.then-107:
	; SelectorExpr
	%507 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %105, align 1
	call void @os.write_string({i64, i64}* %105, i64 %507, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3b, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-108

if.done-108:
	; SelectorExpr
	%508 = load i64, i64* %0, align 8
	%509 = load %..string, %..string* %101, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %106, align 1
	call void @os.write_string({i64, i64}* %106, i64 %508, %..string %509, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%510 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %107, align 1
	call void @os.write_string({i64, i64}* %107, i64 %510, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$3c, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%511 = load i64, i64* %0, align 8
	; IndexExpr
	; SelectorExpr
	%512 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %96, i32 0, i32 1
	%513 = load {i32*, i64}, {i32*, i64}* %512, align 8
	%514 = extractvalue {i32*, i64} %513, 0
	%515 = load i64, i64* %102, align 8
	%516 = extractvalue {i32*, i64} %513, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$3d, i32 0, i32 0), i64 66}, i64 204, i64 32, i64 %515, i64 %516)
	%517 = getelementptr inbounds i32, i32* %514, i64 %515
	%518 = load i32, i32* %517, align 4
	%519 = sext i32 %518 to i64
	call void @runtime.print_u64(i64 %511, i64 %519, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-105

for.index.done-109:
	; SelectorExpr
	%520 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %108, align 1
	call void @os.write_string({i64, i64}* %108, i64 %520, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$3e, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-110:
	%521 = icmp eq i64 %134, 23
	br i1 %521, label %typeswitch.body-120, label %typeswitch.next-119

typeswitch.body-111:
	%522 = bitcast %..rawptr %135 to %runtime.Type_Info_Bit_Set*
	%523 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %522, align 8
	store %runtime.Type_Info_Bit_Set %523, %runtime.Type_Info_Bit_Set* %109
	; SelectorExpr
	%524 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %110, align 1
	call void @os.write_string({i64, i64}* %110, i64 %524, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$3f, i32 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%525 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 0
	%526 = load %runtime.Type_Info*, %runtime.Type_Info** %525, align 8
	%527 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %526)
	store %runtime.Type_Info* %527, %runtime.Type_Info** %111
	%528 = load %runtime.Type_Info*, %runtime.Type_Info** %111, align 8
	%529 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %528, i32 0, i32 3
	%530 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %529, align 8
	; get union's tag
	%531 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %529, i64 0, i32 2 ; UnionTagPtr
	%532 = load i64, i64* %531, align 8
	%533 = bitcast {[0 x i64], [88 x i8], i64}* %529 to %..rawptr
	%534 = icmp eq i64 %532, 19
	br i1 %534, label %typeswitch.body-113, label %typeswitch.next-112

typeswitch.next-112:
	%535 = icmp eq i64 %532, 3
	br i1 %535, label %typeswitch.body-115, label %typeswitch.next-114

typeswitch.body-113:
	%536 = bitcast %..rawptr %533 to %runtime.Type_Info_Enum*
	%537 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %536, align 8
	store %runtime.Type_Info_Enum %537, %runtime.Type_Info_Enum* %112
	%538 = load i64, i64* %0, align 8
	; SelectorExpr
	%539 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 0
	%540 = load %runtime.Type_Info*, %runtime.Type_Info** %539, align 8
	call void @runtime.print_type(i64 %538, %runtime.Type_Info* %540, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.next-114:
	store {[0 x i64], [88 x i8], i64} %530, {[0 x i64], [88 x i8], i64}* %115
	%541 = load i64, i64* %0, align 8
	; SelectorExpr
	%542 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 2
	%543 = load i64, i64* %542, align 8
	call void @runtime.print_i64(i64 %541, i64 %543, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%544 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %116, align 1
	call void @os.write_string({i64, i64}* %116, i64 %544, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$40, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%545 = load i64, i64* %0, align 8
	; SelectorExpr
	%546 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 3
	%547 = load i64, i64* %546, align 8
	call void @runtime.print_i64(i64 %545, i64 %547, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.body-115:
	%548 = bitcast %..rawptr %533 to %runtime.Type_Info_Rune*
	%549 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %548, align 1
	store %runtime.Type_Info_Rune %549, %runtime.Type_Info_Rune* %113
	; SelectorExpr
	%550 = load i64, i64* %0, align 8
	; SelectorExpr
	%551 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 2
	%552 = load i64, i64* %551, align 8
	%553 = trunc i64 %552 to i32
	call void @os.write_encoded_rune(i64 %550, i32 %553, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%554 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %114, align 1
	call void @os.write_string({i64, i64}* %114, i64 %554, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$41, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%555 = load i64, i64* %0, align 8
	; SelectorExpr
	%556 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 3
	%557 = load i64, i64* %556, align 8
	%558 = trunc i64 %557 to i32
	call void @os.write_encoded_rune(i64 %555, i32 %558, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-116

typeswitch.done-116:
	; IfStmt
	; SelectorExpr
	%559 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 1
	%560 = load %runtime.Type_Info*, %runtime.Type_Info** %559, align 8
	%561 = icmp ne %runtime.Type_Info* %560, zeroinitializer
	%562 = zext i1 %561 to i8
	%563 = trunc i8 %562 to i1
	br i1 %563, label %if.then-117, label %if.done-118

if.then-117:
	; SelectorExpr
	%564 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %117, align 1
	call void @os.write_string({i64, i64}* %117, i64 %564, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$42, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%565 = load i64, i64* %0, align 8
	; SelectorExpr
	%566 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %109, i32 0, i32 1
	%567 = load %runtime.Type_Info*, %runtime.Type_Info** %566, align 8
	call void @runtime.print_type(i64 %565, %runtime.Type_Info* %567, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-118

if.done-118:
	; SelectorExpr
	%568 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %118, align 1
	call void @os.write_byte({i64, i64}* %118, i64 %568, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-119:
	%569 = icmp eq i64 %134, 24
	br i1 %569, label %typeswitch.body-122, label %typeswitch.next-121

typeswitch.body-120:
	%570 = bitcast %..rawptr %135 to %runtime.Type_Info_Opaque*
	%571 = load %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %570, align 8
	store %runtime.Type_Info_Opaque %571, %runtime.Type_Info_Opaque* %119
	; SelectorExpr
	%572 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %120, align 1
	call void @os.write_string({i64, i64}* %120, i64 %572, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$43, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%573 = load i64, i64* %0, align 8
	; SelectorExpr
	%574 = getelementptr inbounds %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %119, i32 0, i32 0
	%575 = load %runtime.Type_Info*, %runtime.Type_Info** %574, align 8
	call void @runtime.print_type(i64 %573, %runtime.Type_Info* %575, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-126

typeswitch.next-121:
	br label %typeswitch.done-126

typeswitch.body-122:
	%576 = bitcast %..rawptr %135 to %runtime.Type_Info_Simd_Vector*
	%577 = load %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %576, align 8
	store %runtime.Type_Info_Simd_Vector %577, %runtime.Type_Info_Simd_Vector* %121
	; IfStmt
	; SelectorExpr
	%578 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %121, i32 0, i32 3
	%579 = load i8, i8* %578, align 1
	%580 = trunc i8 %579 to i1
	br i1 %580, label %if.then-123, label %if.else-124

if.then-123:
	; SelectorExpr
	%581 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %122, align 1
	call void @os.write_string({i64, i64}* %122, i64 %581, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$44, i32 0, i32 0), i64 18}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-125

if.else-124:
	; SelectorExpr
	%582 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %123, align 1
	call void @os.write_string({i64, i64}* %123, i64 %582, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$45, i32 0, i32 0), i64 18}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%583 = load i64, i64* %0, align 8
	; SelectorExpr
	%584 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %121, i32 0, i32 2
	%585 = load i64, i64* %584, align 8
	%586 = bitcast i64 %585 to i64
	call void @runtime.print_u64(i64 %583, i64 %586, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%587 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %124, align 1
	call void @os.write_string({i64, i64}* %124, i64 %587, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$46, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%588 = load i64, i64* %0, align 8
	; SelectorExpr
	%589 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %121, i32 0, i32 0
	%590 = load %runtime.Type_Info*, %runtime.Type_Info** %589, align 8
	call void @runtime.print_type(i64 %588, %runtime.Type_Info* %590, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%591 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %125, align 1
	call void @os.write_byte({i64, i64}* %125, i64 %591, i8 41, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-125

if.done-125:
	br label %typeswitch.done-126

typeswitch.done-126:
	ret void
}

define i64 @runtime.memory_compare(%..rawptr %_.0, %..rawptr %_.1, i64 %_.2) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i8, align 16
	%13 = alloca i8, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store %..rawptr %_.1, %..rawptr* %1
	store i64 %_.2, i64* %2
	; x
	%16 = load %..rawptr, %..rawptr* %0, align 8
	%17 = ptrtoint %..rawptr %16 to i64
	store i64 %17, i64* %3
	; y
	%18 = load %..rawptr, %..rawptr* %1, align 8
	%19 = ptrtoint %..rawptr %18 to i64
	store i64 %19, i64* %4
	; n
	%20 = load i64, i64* %2, align 8
	%21 = bitcast i64 %20 to i64
	store i64 %21, i64* %5
	; fast
	%22 = load i64, i64* %5, align 8
	%23 = udiv i64 %22, 8
	%24 = add i64 %23, 1
	store i64 %24, i64* %6
	; offset
	%25 = load i64, i64* %6, align 8
	%26 = sub i64 %25, 1
	%27 = mul i64 %26, 8
	store i64 %27, i64* %7
	; curr_block
	store i64 0, i64* %8
	; IfStmt
	%28 = load i64, i64* %5, align 8
	%29 = icmp ult i64 %28, 8
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	store i64 0, i64* %6
	br label %if.done-2

if.done-2:
	; ForStmt
	br label %for.loop-3

for.loop-3:
	%32 = load i64, i64* %8, align 8
	%33 = load i64, i64* %6, align 8
	%34 = icmp ult i64 %32, %33
	%35 = zext i1 %34 to i8
	%36 = trunc i8 %35 to i1
	br i1 %36, label %for.body-4, label %for.done-15

for.body-4:
	; va
	%37 = load i64, i64* %3, align 8
	%38 = load i64, i64* %8, align 8
	%39 = mul i64 %38, 8
	%40 = add i64 %37, %39
	%41 = inttoptr i64 %40 to i64*
	%42 = getelementptr inbounds i64, i64* %41, i64 0
	%43 = load i64, i64* %42, align 8
	store i64 %43, i64* %9
	; vb
	%44 = load i64, i64* %4, align 8
	%45 = load i64, i64* %8, align 8
	%46 = mul i64 %45, 8
	%47 = add i64 %44, %46
	%48 = inttoptr i64 %47 to i64*
	%49 = getelementptr inbounds i64, i64* %48, i64 0
	%50 = load i64, i64* %49, align 8
	store i64 %50, i64* %10
	; IfStmt
	%51 = load i64, i64* %9, align 8
	%52 = load i64, i64* %10, align 8
	%53 = xor i64 %51, %52
	%54 = icmp ne i64 %53, 0
	%55 = zext i1 %54 to i8
	%56 = trunc i8 %55 to i1
	br i1 %56, label %if.then-5, label %if.done-14

if.then-5:
	; ForStmt
	; pos
	%57 = load i64, i64* %8, align 8
	%58 = mul i64 %57, 8
	store i64 %58, i64* %11
	br label %for.loop-6

for.loop-6:
	%59 = load i64, i64* %11, align 8
	%60 = load i64, i64* %5, align 8
	%61 = icmp ult i64 %59, %60
	%62 = zext i1 %61 to i8
	%63 = trunc i8 %62 to i1
	br i1 %63, label %for.body-7, label %for.done-13

for.body-7:
	; a
	%64 = load i64, i64* %3, align 8
	%65 = load i64, i64* %11, align 8
	%66 = add i64 %64, %65
	%67 = inttoptr i64 %66 to i8*
	%68 = getelementptr inbounds i8, i8* %67, i64 0
	%69 = load i8, i8* %68, align 1
	store i8 %69, i8* %12
	; b
	%70 = load i64, i64* %4, align 8
	%71 = load i64, i64* %11, align 8
	%72 = add i64 %70, %71
	%73 = inttoptr i64 %72 to i8*
	%74 = getelementptr inbounds i8, i8* %73, i64 0
	%75 = load i8, i8* %74, align 1
	store i8 %75, i8* %13
	; IfStmt
	%76 = load i8, i8* %12, align 1
	%77 = load i8, i8* %13, align 1
	%78 = xor i8 %76, %77
	%79 = icmp ne i8 %78, 0
	%80 = zext i1 %79 to i8
	%81 = trunc i8 %80 to i1
	br i1 %81, label %if.then-8, label %if.done-12

if.then-8:
	; ReturnStmt
	; TernaryExpr
	%82 = load i8, i8* %12, align 1
	%83 = zext i8 %82 to i64
	%84 = load i8, i8* %13, align 1
	%85 = zext i8 %84 to i64
	%86 = sub i64 %83, %85
	%87 = icmp slt i64 %86, 0
	%88 = zext i1 %87 to i8
	%89 = trunc i8 %88 to i1
	br i1 %89, label %if.then-9, label %if.else-10

if.then-9:
	br label %if.done-11

if.else-10:
	br label %if.done-11

if.done-11:
	%90 = phi i64 [ -1, %if.then-9 ], [ 1, %if.else-10 ]
	ret i64 %90

if.done-12:
	; AssignStmt
	%91 = load i64, i64* %11, align 8
	%92 = add i64 %91, 1
	store i64 %92, i64* %11
	br label %for.loop-6

for.done-13:
	br label %if.done-14

if.done-14:
	; AssignStmt
	%93 = load i64, i64* %8, align 8
	%94 = add i64 %93, 1
	store i64 %94, i64* %8
	br label %for.loop-3

for.done-15:
	; ForStmt
	br label %for.loop-16

for.loop-16:
	%95 = load i64, i64* %7, align 8
	%96 = load i64, i64* %5, align 8
	%97 = icmp ult i64 %95, %96
	%98 = zext i1 %97 to i8
	%99 = trunc i8 %98 to i1
	br i1 %99, label %for.body-17, label %for.done-23

for.body-17:
	; a
	%100 = load i64, i64* %3, align 8
	%101 = load i64, i64* %7, align 8
	%102 = add i64 %100, %101
	%103 = inttoptr i64 %102 to i8*
	%104 = getelementptr inbounds i8, i8* %103, i64 0
	%105 = load i8, i8* %104, align 1
	store i8 %105, i8* %14
	; b
	%106 = load i64, i64* %4, align 8
	%107 = load i64, i64* %7, align 8
	%108 = add i64 %106, %107
	%109 = inttoptr i64 %108 to i8*
	%110 = getelementptr inbounds i8, i8* %109, i64 0
	%111 = load i8, i8* %110, align 1
	store i8 %111, i8* %15
	; IfStmt
	%112 = load i8, i8* %14, align 1
	%113 = load i8, i8* %15, align 1
	%114 = xor i8 %112, %113
	%115 = icmp ne i8 %114, 0
	%116 = zext i1 %115 to i8
	%117 = trunc i8 %116 to i1
	br i1 %117, label %if.then-18, label %if.done-22

if.then-18:
	; ReturnStmt
	; TernaryExpr
	%118 = load i8, i8* %14, align 1
	%119 = zext i8 %118 to i64
	%120 = load i8, i8* %15, align 1
	%121 = zext i8 %120 to i64
	%122 = sub i64 %119, %121
	%123 = icmp slt i64 %122, 0
	%124 = zext i1 %123 to i8
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-19, label %if.else-20

if.then-19:
	br label %if.done-21

if.else-20:
	br label %if.done-21

if.done-21:
	%126 = phi i64 [ -1, %if.then-19 ], [ 1, %if.else-20 ]
	ret i64 %126

if.done-22:
	; AssignStmt
	%127 = load i64, i64* %7, align 8
	%128 = add i64 %127, 1
	store i64 %128, i64* %7
	br label %for.loop-16

for.done-23:
	; ReturnStmt
	ret i64 0
}

define i64 @runtime.memory_compare_zero(%..rawptr %_.0, i64 %_.1) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i8, align 16
	%10 = alloca i8, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i64 %_.1, i64* %1
	; x
	%11 = load %..rawptr, %..rawptr* %0, align 8
	%12 = ptrtoint %..rawptr %11 to i64
	store i64 %12, i64* %2
	; n
	%13 = load i64, i64* %1, align 8
	%14 = bitcast i64 %13 to i64
	store i64 %14, i64* %3
	; fast
	%15 = load i64, i64* %3, align 8
	%16 = udiv i64 %15, 8
	%17 = add i64 %16, 1
	store i64 %17, i64* %4
	; offset
	%18 = load i64, i64* %4, align 8
	%19 = sub i64 %18, 1
	%20 = mul i64 %19, 8
	store i64 %20, i64* %5
	; curr_block
	store i64 0, i64* %6
	; IfStmt
	%21 = load i64, i64* %3, align 8
	%22 = icmp ult i64 %21, 8
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	store i64 0, i64* %4
	br label %if.done-2

if.done-2:
	; ForStmt
	br label %for.loop-3

for.loop-3:
	%25 = load i64, i64* %6, align 8
	%26 = load i64, i64* %4, align 8
	%27 = icmp ult i64 %25, %26
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %for.body-4, label %for.done-15

for.body-4:
	; va
	%30 = load i64, i64* %2, align 8
	%31 = load i64, i64* %6, align 8
	%32 = mul i64 %31, 8
	%33 = add i64 %30, %32
	%34 = inttoptr i64 %33 to i64*
	%35 = getelementptr inbounds i64, i64* %34, i64 0
	%36 = load i64, i64* %35, align 8
	store i64 %36, i64* %7
	; IfStmt
	%37 = load i64, i64* %7, align 8
	%38 = xor i64 %37, 0
	%39 = icmp ne i64 %38, 0
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %if.then-5, label %if.done-14

if.then-5:
	; ForStmt
	; pos
	%42 = load i64, i64* %6, align 8
	%43 = mul i64 %42, 8
	store i64 %43, i64* %8
	br label %for.loop-6

for.loop-6:
	%44 = load i64, i64* %8, align 8
	%45 = load i64, i64* %3, align 8
	%46 = icmp ult i64 %44, %45
	%47 = zext i1 %46 to i8
	%48 = trunc i8 %47 to i1
	br i1 %48, label %for.body-7, label %for.done-13

for.body-7:
	; a
	%49 = load i64, i64* %2, align 8
	%50 = load i64, i64* %8, align 8
	%51 = add i64 %49, %50
	%52 = inttoptr i64 %51 to i8*
	%53 = getelementptr inbounds i8, i8* %52, i64 0
	%54 = load i8, i8* %53, align 1
	store i8 %54, i8* %9
	; IfStmt
	%55 = load i8, i8* %9, align 1
	%56 = xor i8 %55, 0
	%57 = icmp ne i8 %56, 0
	%58 = zext i1 %57 to i8
	%59 = trunc i8 %58 to i1
	br i1 %59, label %if.then-8, label %if.done-12

if.then-8:
	; ReturnStmt
	; TernaryExpr
	%60 = load i8, i8* %9, align 1
	%61 = zext i8 %60 to i64
	%62 = icmp slt i64 %61, 0
	%63 = zext i1 %62 to i8
	%64 = trunc i8 %63 to i1
	br i1 %64, label %if.then-9, label %if.else-10

if.then-9:
	br label %if.done-11

if.else-10:
	br label %if.done-11

if.done-11:
	%65 = phi i64 [ -1, %if.then-9 ], [ 1, %if.else-10 ]
	ret i64 %65

if.done-12:
	; AssignStmt
	%66 = load i64, i64* %8, align 8
	%67 = add i64 %66, 1
	store i64 %67, i64* %8
	br label %for.loop-6

for.done-13:
	br label %if.done-14

if.done-14:
	; AssignStmt
	%68 = load i64, i64* %6, align 8
	%69 = add i64 %68, 1
	store i64 %69, i64* %6
	br label %for.loop-3

for.done-15:
	; ForStmt
	br label %for.loop-16

for.loop-16:
	%70 = load i64, i64* %5, align 8
	%71 = load i64, i64* %3, align 8
	%72 = icmp ult i64 %70, %71
	%73 = zext i1 %72 to i8
	%74 = trunc i8 %73 to i1
	br i1 %74, label %for.body-17, label %for.done-23

for.body-17:
	; a
	%75 = load i64, i64* %2, align 8
	%76 = load i64, i64* %5, align 8
	%77 = add i64 %75, %76
	%78 = inttoptr i64 %77 to i8*
	%79 = getelementptr inbounds i8, i8* %78, i64 0
	%80 = load i8, i8* %79, align 1
	store i8 %80, i8* %10
	; IfStmt
	%81 = load i8, i8* %10, align 1
	%82 = xor i8 %81, 0
	%83 = icmp ne i8 %82, 0
	%84 = zext i1 %83 to i8
	%85 = trunc i8 %84 to i1
	br i1 %85, label %if.then-18, label %if.done-22

if.then-18:
	; ReturnStmt
	; TernaryExpr
	%86 = load i8, i8* %10, align 1
	%87 = zext i8 %86 to i64
	%88 = icmp slt i64 %87, 0
	%89 = zext i1 %88 to i8
	%90 = trunc i8 %89 to i1
	br i1 %90, label %if.then-19, label %if.else-20

if.then-19:
	br label %if.done-21

if.else-20:
	br label %if.done-21

if.done-21:
	%91 = phi i64 [ -1, %if.then-19 ], [ 1, %if.else-20 ]
	ret i64 %91

if.done-22:
	; AssignStmt
	%92 = load i64, i64* %5, align 8
	%93 = add i64 %92, 1
	store i64 %93, i64* %5
	br label %for.loop-16

for.done-23:
	; ReturnStmt
	ret i64 0
}

define i8 @runtime.string_eq(%..string %_.0, %..string %_.1) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %_.0, %..string* %0
	store %..string %_.1, %..string* %1
	; SwitchStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = extractvalue %..string %2, 1
	%4 = load %..string, %..string* %1, align 8
	%5 = extractvalue %..string %4, 1
	%6 = icmp ne i64 %3, %5
	%7 = zext i1 %6 to i8
	%8 = icmp eq i8 1, %7
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = load %..string, %..string* %0, align 8
	%10 = extractvalue %..string %9, 1
	%11 = icmp eq i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = icmp eq i8 1, %12
	br i1 %13, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	ret i8 0

switch.case.next-3:
	; IndexExpr
	%14 = load %..string, %..string* %0, align 8
	%15 = extractvalue %..string %14, 0
	%16 = extractvalue %..string %14, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$47, i32 0, i32 0), i64 66}, i64 322, i64 10, i64 0, i64 %16)
	%17 = getelementptr inbounds i8, i8* %15, i64 0
	; IndexExpr
	%18 = load %..string, %..string* %1, align 8
	%19 = extractvalue %..string %18, 0
	%20 = extractvalue %..string %18, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$48, i32 0, i32 0), i64 66}, i64 322, i64 19, i64 0, i64 %20)
	%21 = getelementptr inbounds i8, i8* %19, i64 0
	%22 = icmp eq i8* %17, %21
	%23 = zext i1 %22 to i8
	%24 = icmp eq i8 1, %23
	br i1 %24, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	; ReturnStmt
	ret i8 1

switch.case.next-5:
	; ReturnStmt
	%25 = load %..string, %..string* %0, align 8
	%26 = load %..string, %..string* %1, align 8
	%27 = call i64 @runtime.string_cmp(%..string %25, %..string %26)
	%28 = icmp eq i64 %27, 0
	%29 = zext i1 %28 to i8
	ret i8 %29

switch.fall.body-6:
	; ReturnStmt
	ret i8 1
}

define i64 @runtime.string_cmp(%..string %_.0, %..string %_.1) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %_.0, %..string* %0
	store %..string %_.1, %..string* %1
	; ReturnStmt
	; IndexExpr
	%2 = load %..string, %..string* %0, align 8
	%3 = extractvalue %..string %2, 0
	%4 = extractvalue %..string %2, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$49, i32 0, i32 0), i64 66}, i64 328, i64 27, i64 0, i64 %4)
	%5 = getelementptr inbounds i8, i8* %3, i64 0
	; IndexExpr
	%6 = load %..string, %..string* %1, align 8
	%7 = extractvalue %..string %6, 0
	%8 = extractvalue %..string %6, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([67 x i8], [67 x i8]* @str$4a, i32 0, i32 0), i64 66}, i64 328, i64 34, i64 0, i64 %8)
	%9 = getelementptr inbounds i8, i8* %7, i64 0
	; min
	%10 = load %..string, %..string* %1, align 8
	%11 = extractvalue %..string %10, 1
	%12 = load %..string, %..string* %0, align 8
	%13 = extractvalue %..string %12, 1
	%14 = icmp slt i64 %13, %11
	%15 = select i1 %14, i64 %13, i64 %11
	%16 = bitcast i8* %5 to %..rawptr
	%17 = bitcast i8* %9 to %..rawptr
	%18 = call i64 @runtime.memory_compare(%..rawptr %16, %..rawptr %17, i64 %15)
	ret i64 %18
}

define i8 @runtime.string_ne(%..string %_.0, %..string %_.1) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	store %..string %_.0, %..string* %0
	store %..string %_.1, %..string* %1
	; ReturnStmt
	%2 = load %..string, %..string* %0, align 8
	%3 = load %..string, %..string* %1, align 8
	%4 = call i8 @runtime.string_eq(%..string %2, %..string %3) alwaysinline
	%5 = icmp eq i8 %4, 0
	%6 = zext i1 %5 to i8
	ret i8 %6
}

define i64 @runtime.cstring_len(i8* %_.0) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8*, align 16
	store i8* %_.0, i8** %0
	; n
	store i64 0, i64* %1
	; ForStmt
	; p
	%3 = load i8*, i8** %0, align 8
	%4 = bitcast i8* %3 to i8*
	store i8* %4, i8** %2
	br label %for.loop-1

for.loop-1:
	%5 = load i8*, i8** %2, align 8
	%6 = icmp ne i8* %5, zeroinitializer
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %cmp.and-2, label %for.done-4

cmp.and-2:
	%9 = load i8*, i8** %2, align 8
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = load i8, i8* %10, align 1
	%12 = icmp ne i8 %11, 0
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	%15 = load i64, i64* %1, align 8
	%16 = add i64 %15, 1
	store i64 %16, i64* %1
	; AssignStmt
	; SelectorExpr
	%17 = load i8*, i8** %2, align 8
	%18 = call i8* @mem.ptr_offset-5849(i8* %17, i64 1)
	store i8* %18, i8** %2
	br label %for.loop-1

for.done-4:
	; ReturnStmt
	%19 = load i64, i64* %1, align 8
	ret i64 %19
}

define void @runtime.cstring_to_string(%..string* sret noalias %agg.result, i8* %_.0) #0 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i64, align 16
	%3 = alloca %mem.Raw_String, align 16
	store i8* %_.0, i8** %0
	; IfStmt
	%4 = load i8*, i8** %0, align 8
	%5 = bitcast i8* %4 to i8*
	%6 = bitcast %..rawptr null to i8*
	%7 = icmp eq i8* %5, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	store %..string zeroinitializer, %..string* %agg.result
	ret void

if.done-2:
	; ptr
	%10 = load i8*, i8** %0, align 8
	%11 = bitcast i8* %10 to i8*
	store i8* %11, i8** %1
	; n
	%12 = load i8*, i8** %0, align 8
	%13 = call i64 @runtime.cstring_len(i8* %12)
	store i64 %13, i64* %2
	; ReturnStmt
	; CompoundLit
	; ZeroInit
	store %mem.Raw_String zeroinitializer, %mem.Raw_String* %3, align 1
	store %mem.Raw_String {i8* zeroinitializer, i64 zeroinitializer}, %mem.Raw_String* %3
	%14 = load i8*, i8** %1, align 8
	%15 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %3, i32 0, i32 0
	store i8* %14, i8** %15
	%16 = load i64, i64* %2, align 8
	%17 = getelementptr inbounds %mem.Raw_String, %mem.Raw_String* %3, i32 0, i32 1
	store i64 %16, i64* %17
	%18 = bitcast %mem.Raw_String* %3 to %..string*
	%19 = load %..string, %..string* %18, align 8
	store %..string %19, %..string* %agg.result
	ret void
}

define void @runtime.bounds_check_error(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	; IfStmt
	%5 = load i64, i64* %3, align 8
	%6 = icmp sle i64 0, %5
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%9 = load i64, i64* %3, align 8
	%10 = load i64, i64* %4, align 8
	%11 = icmp slt i64 %9, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	%14 = load %..string, %..string* %0, align 8
	%15 = load i64, i64* %1, align 8
	%16 = load i64, i64* %2, align 8
	%17 = load i64, i64* %3, align 8
	%18 = load i64, i64* %4, align 8
	call void @runtime.bounds_check_error.handle_error-0(%..string %14, i64 %15, i64 %16, i64 %17, i64 %18)
	ret void
}

define void @runtime.bounds_check_error.handle_error-0(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Context, align 16
	%8 = bitcast %runtime.Context* %7 to %..rawptr
	; ZeroInit
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 144)
	%10 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %10, %runtime.Context* %7
	call void @runtime.__init_context(%runtime.Context* %7)
	%11 = alloca {i64, i64}, align 16
	%12 = alloca {i64, i64}, align 16
	%13 = alloca {i64, i64}, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	; fd
	; SelectorExpr
	%14 = load i64, i64* @os.stderr, align 8
	store i64 %14, i64* %5
	%15 = load i64, i64* %5, align 8
	; CompoundLit
	%16 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	; ZeroInit
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 56)
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer, i64 0}, %runtime.Source_Code_Location* %6
	%18 = load %..string, %..string* %0, align 8
	%19 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i32 0, i32 0
	store %..string %18, %..string* %19
	%20 = load i64, i64* %1, align 8
	%21 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i32 0, i32 1
	store i64 %20, i64* %21
	%22 = load i64, i64* %2, align 8
	%23 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i32 0, i32 2
	store i64 %22, i64* %23
	call void @runtime.print_caller_location(i64 %15, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %7)
	; SelectorExpr
	%24 = load i64, i64* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %11, align 1
	call void @os.write_string({i64, i64}* %11, i64 %24, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$4b, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %7)
	%25 = load i64, i64* %5, align 8
	%26 = load i64, i64* %3, align 8
	%27 = bitcast i64 %26 to i64
	call void @runtime.print_i64(i64 %25, i64 %27, %runtime.Context* noalias nonnull nocapture %7)
	; SelectorExpr
	%28 = load i64, i64* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %12, align 1
	call void @os.write_string({i64, i64}* %12, i64 %28, %..string {i8* getelementptr inbounds ([27 x i8], [27 x i8]* @str$4c, i32 0, i32 0), i64 26}, %runtime.Context* noalias nonnull nocapture %7)
	%29 = load i64, i64* %5, align 8
	%30 = load i64, i64* %4, align 8
	%31 = bitcast i64 %30 to i64
	call void @runtime.print_i64(i64 %29, i64 %31, %runtime.Context* noalias nonnull nocapture %7)
	; SelectorExpr
	%32 = load i64, i64* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %13, align 1
	call void @os.write_byte({i64, i64}* %13, i64 %32, i8 10, %runtime.Context* noalias nonnull nocapture %7)
	call void @llvm.debugtrap()
	ret void
}

define void @runtime.slice_handle_error(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4, i64 %_.5) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	; ZeroInit
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 144)
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca {i64, i64}, align 16
	%13 = alloca {i64, i64}, align 16
	%14 = alloca {i64, i64}, align 16
	%15 = alloca {i64, i64}, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	store i64 %_.5, i64* %5
	; fd
	; SelectorExpr
	%16 = load i64, i64* @os.stderr, align 8
	store i64 %16, i64* %6
	%17 = load i64, i64* %6, align 8
	; CompoundLit
	%18 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	; ZeroInit
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 56)
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer, i64 0}, %runtime.Source_Code_Location* %7
	%20 = load %..string, %..string* %0, align 8
	%21 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i32 0, i32 0
	store %..string %20, %..string* %21
	%22 = load i64, i64* %1, align 8
	%23 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i32 0, i32 1
	store i64 %22, i64* %23
	%24 = load i64, i64* %2, align 8
	%25 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i32 0, i32 2
	store i64 %24, i64* %25
	call void @runtime.print_caller_location(i64 %17, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%26 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %12, align 1
	call void @os.write_string({i64, i64}* %12, i64 %26, %..string {i8* getelementptr inbounds ([25 x i8], [25 x i8]* @str$4d, i32 0, i32 0), i64 24}, %runtime.Context* noalias nonnull nocapture %8)
	%27 = load i64, i64* %6, align 8
	%28 = load i64, i64* %3, align 8
	%29 = bitcast i64 %28 to i64
	call void @runtime.print_i64(i64 %27, i64 %29, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%30 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %13, align 1
	call void @os.write_string({i64, i64}* %13, i64 %30, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4e, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %8)
	%31 = load i64, i64* %6, align 8
	%32 = load i64, i64* %4, align 8
	%33 = bitcast i64 %32 to i64
	call void @runtime.print_i64(i64 %31, i64 %33, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%34 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %14, align 1
	call void @os.write_string({i64, i64}* %14, i64 %34, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$4f, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %8)
	%35 = load i64, i64* %6, align 8
	%36 = load i64, i64* %5, align 8
	%37 = bitcast i64 %36 to i64
	call void @runtime.print_i64(i64 %35, i64 %37, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%38 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %15, align 1
	call void @os.write_byte({i64, i64}* %15, i64 %38, i8 10, %runtime.Context* noalias nonnull nocapture %8)
	call void @llvm.debugtrap()
	ret void
}

define void @runtime.slice_expr_error_hi(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	; IfStmt
	%5 = load i64, i64* %3, align 8
	%6 = icmp sle i64 0, %5
	%7 = zext i1 %6 to i8
	%8 = trunc i8 %7 to i1
	br i1 %8, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%9 = load i64, i64* %3, align 8
	%10 = load i64, i64* %4, align 8
	%11 = icmp sle i64 %9, %10
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	%14 = load %..string, %..string* %0, align 8
	%15 = load i64, i64* %1, align 8
	%16 = load i64, i64* %2, align 8
	%17 = load i64, i64* %3, align 8
	%18 = load i64, i64* %4, align 8
	call void @runtime.slice_handle_error(%..string %14, i64 %15, i64 %16, i64 0, i64 %17, i64 %18)
	ret void
}

define void @runtime.slice_expr_error_lo_hi(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4, i64 %_.5) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	store i64 %_.5, i64* %5
	; IfStmt
	%6 = load i64, i64* %3, align 8
	%7 = icmp sle i64 0, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %cmp.and-1, label %if.done-5

cmp.and-1:
	%10 = load i64, i64* %3, align 8
	%11 = load i64, i64* %5, align 8
	%12 = icmp sle i64 %10, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %cmp.and-2, label %if.done-5

cmp.and-2:
	%15 = load i64, i64* %3, align 8
	%16 = load i64, i64* %4, align 8
	%17 = icmp sle i64 %15, %16
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %cmp.and-3, label %if.done-5

cmp.and-3:
	%20 = load i64, i64* %4, align 8
	%21 = load i64, i64* %5, align 8
	%22 = icmp sle i64 %20, %21
	%23 = zext i1 %22 to i8
	%24 = trunc i8 %23 to i1
	br i1 %24, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	ret void

if.done-5:
	%25 = load %..string, %..string* %0, align 8
	%26 = load i64, i64* %1, align 8
	%27 = load i64, i64* %2, align 8
	%28 = load i64, i64* %3, align 8
	%29 = load i64, i64* %4, align 8
	%30 = load i64, i64* %5, align 8
	call void @runtime.slice_handle_error(%..string %25, i64 %26, i64 %27, i64 %28, i64 %29, i64 %30)
	ret void
}

define void @runtime.dynamic_array_expr_error(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4, i64 %_.5) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	store i64 %_.5, i64* %5
	; IfStmt
	%6 = load i64, i64* %3, align 8
	%7 = icmp sle i64 0, %6
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %cmp.and-1, label %if.done-4

cmp.and-1:
	%10 = load i64, i64* %3, align 8
	%11 = load i64, i64* %4, align 8
	%12 = icmp sle i64 %10, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %cmp.and-2, label %if.done-4

cmp.and-2:
	%15 = load i64, i64* %4, align 8
	%16 = load i64, i64* %5, align 8
	%17 = icmp sle i64 %15, %16
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	%20 = load %..string, %..string* %0, align 8
	%21 = load i64, i64* %1, align 8
	%22 = load i64, i64* %2, align 8
	%23 = load i64, i64* %3, align 8
	%24 = load i64, i64* %4, align 8
	%25 = load i64, i64* %5, align 8
	call void @runtime.dynamic_array_expr_error.handle_error-0(%..string %20, i64 %21, i64 %22, i64 %23, i64 %24, i64 %25)
	ret void
}

define void @runtime.dynamic_array_expr_error.handle_error-0(%..string %_.0, i64 %_.1, i64 %_.2, i64 %_.3, i64 %_.4, i64 %_.5) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Context, align 16
	%9 = bitcast %runtime.Context* %8 to %..rawptr
	; ZeroInit
	%10 = call %..rawptr @mem.zero(%..rawptr %9, i64 144)
	%11 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %11, %runtime.Context* %8
	call void @runtime.__init_context(%runtime.Context* %8)
	%12 = alloca {i64, i64}, align 16
	%13 = alloca {i64, i64}, align 16
	%14 = alloca {i64, i64}, align 16
	%15 = alloca {i64, i64}, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store i64 %_.4, i64* %4
	store i64 %_.5, i64* %5
	; fd
	; SelectorExpr
	%16 = load i64, i64* @os.stderr, align 8
	store i64 %16, i64* %6
	%17 = load i64, i64* %6, align 8
	; CompoundLit
	%18 = bitcast %runtime.Source_Code_Location* %7 to %..rawptr
	; ZeroInit
	%19 = call %..rawptr @mem.zero(%..rawptr %18, i64 56)
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer, i64 0}, %runtime.Source_Code_Location* %7
	%20 = load %..string, %..string* %0, align 8
	%21 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i32 0, i32 0
	store %..string %20, %..string* %21
	%22 = load i64, i64* %1, align 8
	%23 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i32 0, i32 1
	store i64 %22, i64* %23
	%24 = load i64, i64* %2, align 8
	%25 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %7, i32 0, i32 2
	store i64 %24, i64* %25
	call void @runtime.print_caller_location(i64 %17, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%26 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %12, align 1
	call void @os.write_string({i64, i64}* %12, i64 %26, %..string {i8* getelementptr inbounds ([32 x i8], [32 x i8]* @str$50, i32 0, i32 0), i64 31}, %runtime.Context* noalias nonnull nocapture %8)
	%27 = load i64, i64* %6, align 8
	%28 = load i64, i64* %3, align 8
	%29 = bitcast i64 %28 to i64
	call void @runtime.print_i64(i64 %27, i64 %29, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%30 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %13, align 1
	call void @os.write_string({i64, i64}* %13, i64 %30, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$51, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %8)
	%31 = load i64, i64* %6, align 8
	%32 = load i64, i64* %4, align 8
	%33 = bitcast i64 %32 to i64
	call void @runtime.print_i64(i64 %31, i64 %33, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%34 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %14, align 1
	call void @os.write_string({i64, i64}* %14, i64 %34, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$52, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %8)
	%35 = load i64, i64* %6, align 8
	%36 = load i64, i64* %5, align 8
	%37 = bitcast i64 %36 to i64
	call void @runtime.print_i64(i64 %35, i64 %37, %runtime.Context* noalias nonnull nocapture %8)
	; SelectorExpr
	%38 = load i64, i64* %6, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %15, align 1
	call void @os.write_byte({i64, i64}* %15, i64 %38, i8 10, %runtime.Context* noalias nonnull nocapture %8)
	call void @llvm.debugtrap()
	ret void
}

define void @runtime.type_assertion_check(i1 %_.0, %..string %_.1, i64 %_.2, i64 %_.3, %..typeid %_.4, %..typeid %_.5) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..typeid, align 16
	%5 = alloca %..typeid, align 16
	%6 = zext i1 %_.0 to i8
	store i8 %6, i8* %0
	store %..string %_.1, %..string* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store %..typeid %_.4, %..typeid* %4
	store %..typeid %_.5, %..typeid* %5
	; IfStmt
	%7 = load i8, i8* %0, align 1
	%8 = trunc i8 %7 to i1
	br i1 %8, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	%9 = load %..string, %..string* %1, align 8
	%10 = load i64, i64* %2, align 8
	%11 = load i64, i64* %3, align 8
	%12 = load %..typeid, %..typeid* %4, align 8
	%13 = load %..typeid, %..typeid* %5, align 8
	call void @runtime.type_assertion_check.handle_error-0(%..string %9, i64 %10, i64 %11, %..typeid %12, %..typeid %13)
	ret void
}

define void @runtime.type_assertion_check.handle_error-0(%..string %_.0, i64 %_.1, i64 %_.2, %..typeid %_.3, %..typeid %_.4) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %..typeid, align 16
	%4 = alloca %..typeid, align 16
	%5 = alloca i64, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %runtime.Context, align 16
	%8 = bitcast %runtime.Context* %7 to %..rawptr
	; ZeroInit
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 144)
	%10 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %10, %runtime.Context* %7
	call void @runtime.__init_context(%runtime.Context* %7)
	%11 = alloca {i64, i64}, align 16
	%12 = alloca {i64, i64}, align 16
	%13 = alloca {i64, i64}, align 16
	store %..string %_.0, %..string* %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store %..typeid %_.3, %..typeid* %3
	store %..typeid %_.4, %..typeid* %4
	; fd
	; SelectorExpr
	%14 = load i64, i64* @os.stderr, align 8
	store i64 %14, i64* %5
	%15 = load i64, i64* %5, align 8
	; CompoundLit
	%16 = bitcast %runtime.Source_Code_Location* %6 to %..rawptr
	; ZeroInit
	%17 = call %..rawptr @mem.zero(%..rawptr %16, i64 56)
	store %runtime.Source_Code_Location {%..string zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %..string zeroinitializer, i64 0}, %runtime.Source_Code_Location* %6
	%18 = load %..string, %..string* %0, align 8
	%19 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i32 0, i32 0
	store %..string %18, %..string* %19
	%20 = load i64, i64* %1, align 8
	%21 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i32 0, i32 1
	store i64 %20, i64* %21
	%22 = load i64, i64* %2, align 8
	%23 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %6, i32 0, i32 2
	store i64 %22, i64* %23
	call void @runtime.print_caller_location(i64 %15, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %7)
	; SelectorExpr
	%24 = load i64, i64* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %11, align 1
	call void @os.write_string({i64, i64}* %11, i64 %24, %..string {i8* getelementptr inbounds ([30 x i8], [30 x i8]* @str$53, i32 0, i32 0), i64 29}, %runtime.Context* noalias nonnull nocapture %7)
	%25 = load i64, i64* %5, align 8
	%26 = load %..typeid, %..typeid* %3, align 8
	call void @runtime.print_typeid(i64 %25, %..typeid %26, %runtime.Context* noalias nonnull nocapture %7)
	; SelectorExpr
	%27 = load i64, i64* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %12, align 1
	call void @os.write_string({i64, i64}* %12, i64 %27, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$54, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %7)
	%28 = load i64, i64* %5, align 8
	%29 = load %..typeid, %..typeid* %4, align 8
	call void @runtime.print_typeid(i64 %28, %..typeid %29, %runtime.Context* noalias nonnull nocapture %7)
	; SelectorExpr
	%30 = load i64, i64* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %13, align 1
	call void @os.write_byte({i64, i64}* %13, i64 %30, i8 10, %runtime.Context* noalias nonnull nocapture %7)
	call void @llvm.debugtrap()
	ret void
}

define void @runtime.make_slice_error_loc(%runtime.Source_Code_Location* %_.0, i64 %_.1) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	store i64 %_.1, i64* %0
	; IfStmt
	%1 = load i64, i64* %0, align 8
	%2 = icmp sle i64 0, %1
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	%5 = load i64, i64* %0, align 8
	call void @runtime.make_slice_error_loc.handle_error-0(%runtime.Source_Code_Location* %_.0, i64 %5) alwaysinline
	ret void
}

define void @runtime.make_slice_error_loc.handle_error-0(%runtime.Source_Code_Location* %_.0, i64 %_.1) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Context, align 16
	%3 = bitcast %runtime.Context* %2 to %..rawptr
	; ZeroInit
	%4 = call %..rawptr @mem.zero(%..rawptr %3, i64 144)
	%5 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %5, %runtime.Context* %2
	call void @runtime.__init_context(%runtime.Context* %2)
	%6 = alloca {i64, i64}, align 16
	%7 = alloca {i64, i64}, align 16
	store i64 %_.1, i64* %0
	; fd
	; SelectorExpr
	%8 = load i64, i64* @os.stderr, align 8
	store i64 %8, i64* %1
	%9 = load i64, i64* %1, align 8
	call void @runtime.print_caller_location(i64 %9, %runtime.Source_Code_Location* %_.0, %runtime.Context* noalias nonnull nocapture %2)
	; SelectorExpr
	%10 = load i64, i64* %1, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %6, align 1
	call void @os.write_string({i64, i64}* %6, i64 %10, %..string {i8* getelementptr inbounds ([33 x i8], [33 x i8]* @str$55, i32 0, i32 0), i64 32}, %runtime.Context* noalias nonnull nocapture %2)
	%11 = load i64, i64* %1, align 8
	%12 = load i64, i64* %0, align 8
	%13 = bitcast i64 %12 to i64
	call void @runtime.print_i64(i64 %11, i64 %13, %runtime.Context* noalias nonnull nocapture %2)
	; SelectorExpr
	%14 = load i64, i64* %1, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %7, align 1
	call void @os.write_byte({i64, i64}* %7, i64 %14, i8 10, %runtime.Context* noalias nonnull nocapture %2)
	call void @llvm.debugtrap()
	ret void
}

define void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %_.0, i64 %_.1, i64 %_.2) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	store i64 %_.1, i64* %0
	store i64 %_.2, i64* %1
	; IfStmt
	%2 = load i64, i64* %0, align 8
	%3 = icmp sle i64 0, %2
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %cmp.and-1, label %if.done-3

cmp.and-1:
	%6 = load i64, i64* %0, align 8
	%7 = load i64, i64* %1, align 8
	%8 = icmp sle i64 %6, %7
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	%11 = load i64, i64* %0, align 8
	%12 = load i64, i64* %1, align 8
	call void @runtime.make_dynamic_array_error_loc.handle_error-0(%runtime.Source_Code_Location* %_.0, i64 %11, i64 %12) alwaysinline
	ret void
}

define void @runtime.make_dynamic_array_error_loc.handle_error-0(%runtime.Source_Code_Location* %_.0, i64 %_.1, i64 %_.2) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %runtime.Context, align 16
	%4 = bitcast %runtime.Context* %3 to %..rawptr
	; ZeroInit
	%5 = call %..rawptr @mem.zero(%..rawptr %4, i64 144)
	%6 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %6, %runtime.Context* %3
	call void @runtime.__init_context(%runtime.Context* %3)
	%7 = alloca {i64, i64}, align 16
	%8 = alloca {i64, i64}, align 16
	%9 = alloca {i64, i64}, align 16
	store i64 %_.1, i64* %0
	store i64 %_.2, i64* %1
	; fd
	; SelectorExpr
	%10 = load i64, i64* @os.stderr, align 8
	store i64 %10, i64* %2
	%11 = load i64, i64* %2, align 8
	call void @runtime.print_caller_location(i64 %11, %runtime.Source_Code_Location* %_.0, %runtime.Context* noalias nonnull nocapture %3)
	; SelectorExpr
	%12 = load i64, i64* %2, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %7, align 1
	call void @os.write_string({i64, i64}* %7, i64 %12, %..string {i8* getelementptr inbounds ([45 x i8], [45 x i8]* @str$56, i32 0, i32 0), i64 44}, %runtime.Context* noalias nonnull nocapture %3)
	%13 = load i64, i64* %2, align 8
	%14 = load i64, i64* %0, align 8
	%15 = bitcast i64 %14 to i64
	call void @runtime.print_i64(i64 %13, i64 %15, %runtime.Context* noalias nonnull nocapture %3)
	; SelectorExpr
	%16 = load i64, i64* %2, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %8, align 1
	call void @os.write_byte({i64, i64}* %8, i64 %16, i8 58, %runtime.Context* noalias nonnull nocapture %3)
	%17 = load i64, i64* %2, align 8
	%18 = load i64, i64* %1, align 8
	%19 = bitcast i64 %18 to i64
	call void @runtime.print_i64(i64 %17, i64 %19, %runtime.Context* noalias nonnull nocapture %3)
	; SelectorExpr
	%20 = load i64, i64* %2, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %9, align 1
	call void @os.write_byte({i64, i64}* %9, i64 %20, i8 10, %runtime.Context* noalias nonnull nocapture %3)
	call void @llvm.debugtrap()
	ret void
}

define float @runtime.abs_f32(float %_.0) alwaysinline #1 {
decls-0:
	%0 = alloca float, align 16
	store float %_.0, float* %0
	; ReturnStmt
	%1 = load float, float* %0, align 4
	%2 = call float @llvm.fabs.f32(float %1) alwaysinline
	ret float %2
}
declare float @llvm.fabs.f32(float) #0 

define double @runtime.abs_f64(double %_.0) alwaysinline #1 {
decls-0:
	%0 = alloca double, align 16
	store double %_.0, double* %0
	; ReturnStmt
	%1 = load double, double* %0, align 8
	%2 = call double @llvm.fabs.f64(double %1) alwaysinline
	ret double %2
}
declare double @llvm.fabs.f64(double) #0 

define %..complex64 @runtime.quo_complex64(%..complex64 %_.0, %..complex64 %_.1) #0 {
decls-0:
	%0 = alloca %..complex64, align 16
	%1 = alloca %..complex64, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca float, align 16
	%7 = alloca float, align 16
	%8 = alloca %..complex64, align 16
	store %..complex64 %_.0, %..complex64* %0
	store %..complex64 %_.1, %..complex64* %1
	; e
	; ZeroInit
	store float zeroinitializer, float* %2, align 1
	; f
	; ZeroInit
	store float zeroinitializer, float* %3, align 1
	; IfStmt
	; real
	%9 = load %..complex64, %..complex64* %1, align 4
	%10 = extractvalue %..complex64 %9, 0
	; abs
	%11 = call float @runtime.abs_f32(float %10)
	; imag
	%12 = load %..complex64, %..complex64* %1, align 4
	%13 = extractvalue %..complex64 %12, 1
	; abs
	%14 = call float @runtime.abs_f32(float %13)
	%15 = fcmp oge float %11, %14
	%16 = zext i1 %15 to i8
	%17 = trunc i8 %16 to i1
	br i1 %17, label %if.then-1, label %if.else-2

if.then-1:
	; ratio
	; imag
	%18 = load %..complex64, %..complex64* %1, align 4
	%19 = extractvalue %..complex64 %18, 1
	; real
	%20 = load %..complex64, %..complex64* %1, align 4
	%21 = extractvalue %..complex64 %20, 0
	%22 = fdiv float %19, %21
	store float %22, float* %4
	; denom
	; real
	%23 = load %..complex64, %..complex64* %1, align 4
	%24 = extractvalue %..complex64 %23, 0
	%25 = load float, float* %4, align 4
	; imag
	%26 = load %..complex64, %..complex64* %1, align 4
	%27 = extractvalue %..complex64 %26, 1
	%28 = fmul float %25, %27
	%29 = fadd float %24, %28
	store float %29, float* %5
	; AssignStmt
	; real
	%30 = load %..complex64, %..complex64* %0, align 4
	%31 = extractvalue %..complex64 %30, 0
	; imag
	%32 = load %..complex64, %..complex64* %0, align 4
	%33 = extractvalue %..complex64 %32, 1
	%34 = load float, float* %4, align 4
	%35 = fmul float %33, %34
	%36 = fadd float %31, %35
	%37 = load float, float* %5, align 4
	%38 = fdiv float %36, %37
	store float %38, float* %2
	; AssignStmt
	; imag
	%39 = load %..complex64, %..complex64* %0, align 4
	%40 = extractvalue %..complex64 %39, 1
	; real
	%41 = load %..complex64, %..complex64* %0, align 4
	%42 = extractvalue %..complex64 %41, 0
	%43 = load float, float* %4, align 4
	%44 = fmul float %42, %43
	%45 = fsub float %40, %44
	%46 = load float, float* %5, align 4
	%47 = fdiv float %45, %46
	store float %47, float* %3
	br label %if.done-3

if.else-2:
	; ratio
	; real
	%48 = load %..complex64, %..complex64* %1, align 4
	%49 = extractvalue %..complex64 %48, 0
	; imag
	%50 = load %..complex64, %..complex64* %1, align 4
	%51 = extractvalue %..complex64 %50, 1
	%52 = fdiv float %49, %51
	store float %52, float* %6
	; denom
	; imag
	%53 = load %..complex64, %..complex64* %1, align 4
	%54 = extractvalue %..complex64 %53, 1
	%55 = load float, float* %6, align 4
	; real
	%56 = load %..complex64, %..complex64* %1, align 4
	%57 = extractvalue %..complex64 %56, 0
	%58 = fmul float %55, %57
	%59 = fadd float %54, %58
	store float %59, float* %7
	; AssignStmt
	; real
	%60 = load %..complex64, %..complex64* %0, align 4
	%61 = extractvalue %..complex64 %60, 0
	%62 = load float, float* %6, align 4
	%63 = fmul float %61, %62
	; imag
	%64 = load %..complex64, %..complex64* %0, align 4
	%65 = extractvalue %..complex64 %64, 1
	%66 = fadd float %63, %65
	%67 = load float, float* %7, align 4
	%68 = fdiv float %66, %67
	store float %68, float* %2
	; AssignStmt
	; imag
	%69 = load %..complex64, %..complex64* %0, align 4
	%70 = extractvalue %..complex64 %69, 1
	%71 = load float, float* %6, align 4
	%72 = fmul float %70, %71
	; real
	%73 = load %..complex64, %..complex64* %0, align 4
	%74 = extractvalue %..complex64 %73, 0
	%75 = fsub float %72, %74
	%76 = load float, float* %7, align 4
	%77 = fdiv float %75, %76
	store float %77, float* %3
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; complex
	%78 = load float, float* %2, align 4
	%79 = load float, float* %3, align 4
	%80 = getelementptr inbounds %..complex64, %..complex64* %8, i32 0, i32 0
	store float %78, float* %80
	%81 = getelementptr inbounds %..complex64, %..complex64* %8, i32 0, i32 1
	store float %79, float* %81
	%82 = load %..complex64, %..complex64* %8, align 4
	ret %..complex64 %82
}

define void @runtime.quo_complex128(%..complex128* sret noalias %agg.result, %..complex128* %_.0, %..complex128* %_.1) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	%5 = alloca double, align 16
	%6 = alloca %..complex128, align 16
	; e
	; ZeroInit
	store double zeroinitializer, double* %0, align 1
	; f
	; ZeroInit
	store double zeroinitializer, double* %1, align 1
	; IfStmt
	; real
	%7 = load %..complex128, %..complex128* %_.1, align 8
	%8 = extractvalue %..complex128 %7, 0
	; abs
	%9 = call double @runtime.abs_f64(double %8)
	; imag
	%10 = load %..complex128, %..complex128* %_.1, align 8
	%11 = extractvalue %..complex128 %10, 1
	; abs
	%12 = call double @runtime.abs_f64(double %11)
	%13 = fcmp oge double %9, %12
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-1, label %if.else-2

if.then-1:
	; ratio
	; imag
	%16 = load %..complex128, %..complex128* %_.1, align 8
	%17 = extractvalue %..complex128 %16, 1
	; real
	%18 = load %..complex128, %..complex128* %_.1, align 8
	%19 = extractvalue %..complex128 %18, 0
	%20 = fdiv double %17, %19
	store double %20, double* %2
	; denom
	; real
	%21 = load %..complex128, %..complex128* %_.1, align 8
	%22 = extractvalue %..complex128 %21, 0
	%23 = load double, double* %2, align 8
	; imag
	%24 = load %..complex128, %..complex128* %_.1, align 8
	%25 = extractvalue %..complex128 %24, 1
	%26 = fmul double %23, %25
	%27 = fadd double %22, %26
	store double %27, double* %3
	; AssignStmt
	; real
	%28 = load %..complex128, %..complex128* %_.0, align 8
	%29 = extractvalue %..complex128 %28, 0
	; imag
	%30 = load %..complex128, %..complex128* %_.0, align 8
	%31 = extractvalue %..complex128 %30, 1
	%32 = load double, double* %2, align 8
	%33 = fmul double %31, %32
	%34 = fadd double %29, %33
	%35 = load double, double* %3, align 8
	%36 = fdiv double %34, %35
	store double %36, double* %0
	; AssignStmt
	; imag
	%37 = load %..complex128, %..complex128* %_.0, align 8
	%38 = extractvalue %..complex128 %37, 1
	; real
	%39 = load %..complex128, %..complex128* %_.0, align 8
	%40 = extractvalue %..complex128 %39, 0
	%41 = load double, double* %2, align 8
	%42 = fmul double %40, %41
	%43 = fsub double %38, %42
	%44 = load double, double* %3, align 8
	%45 = fdiv double %43, %44
	store double %45, double* %1
	br label %if.done-3

if.else-2:
	; ratio
	; real
	%46 = load %..complex128, %..complex128* %_.1, align 8
	%47 = extractvalue %..complex128 %46, 0
	; imag
	%48 = load %..complex128, %..complex128* %_.1, align 8
	%49 = extractvalue %..complex128 %48, 1
	%50 = fdiv double %47, %49
	store double %50, double* %4
	; denom
	; imag
	%51 = load %..complex128, %..complex128* %_.1, align 8
	%52 = extractvalue %..complex128 %51, 1
	%53 = load double, double* %4, align 8
	; real
	%54 = load %..complex128, %..complex128* %_.1, align 8
	%55 = extractvalue %..complex128 %54, 0
	%56 = fmul double %53, %55
	%57 = fadd double %52, %56
	store double %57, double* %5
	; AssignStmt
	; real
	%58 = load %..complex128, %..complex128* %_.0, align 8
	%59 = extractvalue %..complex128 %58, 0
	%60 = load double, double* %4, align 8
	%61 = fmul double %59, %60
	; imag
	%62 = load %..complex128, %..complex128* %_.0, align 8
	%63 = extractvalue %..complex128 %62, 1
	%64 = fadd double %61, %63
	%65 = load double, double* %5, align 8
	%66 = fdiv double %64, %65
	store double %66, double* %0
	; AssignStmt
	; imag
	%67 = load %..complex128, %..complex128* %_.0, align 8
	%68 = extractvalue %..complex128 %67, 1
	%69 = load double, double* %4, align 8
	%70 = fmul double %68, %69
	; real
	%71 = load %..complex128, %..complex128* %_.0, align 8
	%72 = extractvalue %..complex128 %71, 0
	%73 = fsub double %70, %72
	%74 = load double, double* %5, align 8
	%75 = fdiv double %73, %74
	store double %75, double* %1
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; complex
	%76 = load double, double* %0, align 8
	%77 = load double, double* %1, align 8
	%78 = getelementptr inbounds %..complex128, %..complex128* %6, i32 0, i32 0
	store double %76, double* %78
	%79 = getelementptr inbounds %..complex128, %..complex128* %6, i32 0, i32 1
	store double %77, double* %79
	%80 = load %..complex128, %..complex128* %6, align 8
	store %..complex128 %80, %..complex128* %agg.result
	ret void
}

define void @runtime.mul_quaternion128(%..quaternion128* sret noalias %agg.result, %..quaternion128* %_.0, %..quaternion128* %_.1) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca float, align 16
	%7 = alloca float, align 16
	%8 = alloca float, align 16
	%9 = alloca float, align 16
	%10 = alloca float, align 16
	%11 = alloca float, align 16
	%12 = alloca %..quaternion128, align 16
	; q0
	; q1
	; q2
	; q3
	; real
	%13 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%14 = extractvalue %..quaternion128 %13, 3
	; imag
	%15 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%16 = extractvalue %..quaternion128 %15, 0
	; jmag
	%17 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%18 = extractvalue %..quaternion128 %17, 1
	; kmag
	%19 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%20 = extractvalue %..quaternion128 %19, 2
	store float %14, float* %0
	store float %16, float* %1
	store float %18, float* %2
	store float %20, float* %3
	; r0
	; r1
	; r2
	; r3
	; real
	%21 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%22 = extractvalue %..quaternion128 %21, 3
	; imag
	%23 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%24 = extractvalue %..quaternion128 %23, 0
	; jmag
	%25 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%26 = extractvalue %..quaternion128 %25, 1
	; kmag
	%27 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%28 = extractvalue %..quaternion128 %27, 2
	store float %22, float* %4
	store float %24, float* %5
	store float %26, float* %6
	store float %28, float* %7
	; t0
	%29 = load float, float* %4, align 4
	%30 = load float, float* %0, align 4
	%31 = fmul float %29, %30
	%32 = load float, float* %5, align 4
	%33 = load float, float* %1, align 4
	%34 = fmul float %32, %33
	%35 = fsub float %31, %34
	%36 = load float, float* %6, align 4
	%37 = load float, float* %2, align 4
	%38 = fmul float %36, %37
	%39 = fsub float %35, %38
	%40 = load float, float* %7, align 4
	%41 = load float, float* %3, align 4
	%42 = fmul float %40, %41
	%43 = fsub float %39, %42
	store float %43, float* %8
	; t1
	%44 = load float, float* %4, align 4
	%45 = load float, float* %1, align 4
	%46 = fmul float %44, %45
	%47 = load float, float* %5, align 4
	%48 = load float, float* %0, align 4
	%49 = fmul float %47, %48
	%50 = fadd float %46, %49
	%51 = load float, float* %6, align 4
	%52 = load float, float* %3, align 4
	%53 = fmul float %51, %52
	%54 = fsub float %50, %53
	%55 = load float, float* %7, align 4
	%56 = load float, float* %2, align 4
	%57 = fmul float %55, %56
	%58 = fadd float %54, %57
	store float %58, float* %9
	; t2
	%59 = load float, float* %4, align 4
	%60 = load float, float* %2, align 4
	%61 = fmul float %59, %60
	%62 = load float, float* %5, align 4
	%63 = load float, float* %3, align 4
	%64 = fmul float %62, %63
	%65 = fadd float %61, %64
	%66 = load float, float* %6, align 4
	%67 = load float, float* %0, align 4
	%68 = fmul float %66, %67
	%69 = fadd float %65, %68
	%70 = load float, float* %7, align 4
	%71 = load float, float* %1, align 4
	%72 = fmul float %70, %71
	%73 = fsub float %69, %72
	store float %73, float* %10
	; t3
	%74 = load float, float* %4, align 4
	%75 = load float, float* %3, align 4
	%76 = fmul float %74, %75
	%77 = load float, float* %5, align 4
	%78 = load float, float* %2, align 4
	%79 = fmul float %77, %78
	%80 = fsub float %76, %79
	%81 = load float, float* %6, align 4
	%82 = load float, float* %1, align 4
	%83 = fmul float %81, %82
	%84 = fadd float %80, %83
	%85 = load float, float* %7, align 4
	%86 = load float, float* %0, align 4
	%87 = fmul float %85, %86
	%88 = fadd float %84, %87
	store float %88, float* %11
	; ReturnStmt
	; quaternion
	%89 = load float, float* %8, align 4
	%90 = load float, float* %9, align 4
	%91 = load float, float* %10, align 4
	%92 = load float, float* %11, align 4
	%93 = getelementptr inbounds %..quaternion128, %..quaternion128* %12, i32 0, i32 3
	store float %89, float* %93
	%94 = getelementptr inbounds %..quaternion128, %..quaternion128* %12, i32 0, i32 0
	store float %90, float* %94
	%95 = getelementptr inbounds %..quaternion128, %..quaternion128* %12, i32 0, i32 1
	store float %91, float* %95
	%96 = getelementptr inbounds %..quaternion128, %..quaternion128* %12, i32 0, i32 2
	store float %92, float* %96
	%97 = load %..quaternion128, %..quaternion128* %12, align 4
	store %..quaternion128 %97, %..quaternion128* %agg.result
	ret void
}

define void @runtime.mul_quaternion256(%..quaternion256* sret noalias %agg.result, %..quaternion256* %_.0, %..quaternion256* %_.1) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	%5 = alloca double, align 16
	%6 = alloca double, align 16
	%7 = alloca double, align 16
	%8 = alloca double, align 16
	%9 = alloca double, align 16
	%10 = alloca double, align 16
	%11 = alloca double, align 16
	%12 = alloca %..quaternion256, align 16
	; q0
	; q1
	; q2
	; q3
	; real
	%13 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%14 = extractvalue %..quaternion256 %13, 3
	; imag
	%15 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%16 = extractvalue %..quaternion256 %15, 0
	; jmag
	%17 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%18 = extractvalue %..quaternion256 %17, 1
	; kmag
	%19 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%20 = extractvalue %..quaternion256 %19, 2
	store double %14, double* %0
	store double %16, double* %1
	store double %18, double* %2
	store double %20, double* %3
	; r0
	; r1
	; r2
	; r3
	; real
	%21 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%22 = extractvalue %..quaternion256 %21, 3
	; imag
	%23 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%24 = extractvalue %..quaternion256 %23, 0
	; jmag
	%25 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%26 = extractvalue %..quaternion256 %25, 1
	; kmag
	%27 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%28 = extractvalue %..quaternion256 %27, 2
	store double %22, double* %4
	store double %24, double* %5
	store double %26, double* %6
	store double %28, double* %7
	; t0
	%29 = load double, double* %4, align 8
	%30 = load double, double* %0, align 8
	%31 = fmul double %29, %30
	%32 = load double, double* %5, align 8
	%33 = load double, double* %1, align 8
	%34 = fmul double %32, %33
	%35 = fsub double %31, %34
	%36 = load double, double* %6, align 8
	%37 = load double, double* %2, align 8
	%38 = fmul double %36, %37
	%39 = fsub double %35, %38
	%40 = load double, double* %7, align 8
	%41 = load double, double* %3, align 8
	%42 = fmul double %40, %41
	%43 = fsub double %39, %42
	store double %43, double* %8
	; t1
	%44 = load double, double* %4, align 8
	%45 = load double, double* %1, align 8
	%46 = fmul double %44, %45
	%47 = load double, double* %5, align 8
	%48 = load double, double* %0, align 8
	%49 = fmul double %47, %48
	%50 = fadd double %46, %49
	%51 = load double, double* %6, align 8
	%52 = load double, double* %3, align 8
	%53 = fmul double %51, %52
	%54 = fsub double %50, %53
	%55 = load double, double* %7, align 8
	%56 = load double, double* %2, align 8
	%57 = fmul double %55, %56
	%58 = fadd double %54, %57
	store double %58, double* %9
	; t2
	%59 = load double, double* %4, align 8
	%60 = load double, double* %2, align 8
	%61 = fmul double %59, %60
	%62 = load double, double* %5, align 8
	%63 = load double, double* %3, align 8
	%64 = fmul double %62, %63
	%65 = fadd double %61, %64
	%66 = load double, double* %6, align 8
	%67 = load double, double* %0, align 8
	%68 = fmul double %66, %67
	%69 = fadd double %65, %68
	%70 = load double, double* %7, align 8
	%71 = load double, double* %1, align 8
	%72 = fmul double %70, %71
	%73 = fsub double %69, %72
	store double %73, double* %10
	; t3
	%74 = load double, double* %4, align 8
	%75 = load double, double* %3, align 8
	%76 = fmul double %74, %75
	%77 = load double, double* %5, align 8
	%78 = load double, double* %2, align 8
	%79 = fmul double %77, %78
	%80 = fsub double %76, %79
	%81 = load double, double* %6, align 8
	%82 = load double, double* %1, align 8
	%83 = fmul double %81, %82
	%84 = fadd double %80, %83
	%85 = load double, double* %7, align 8
	%86 = load double, double* %0, align 8
	%87 = fmul double %85, %86
	%88 = fadd double %84, %87
	store double %88, double* %11
	; ReturnStmt
	; quaternion
	%89 = load double, double* %8, align 8
	%90 = load double, double* %9, align 8
	%91 = load double, double* %10, align 8
	%92 = load double, double* %11, align 8
	%93 = getelementptr inbounds %..quaternion256, %..quaternion256* %12, i32 0, i32 3
	store double %89, double* %93
	%94 = getelementptr inbounds %..quaternion256, %..quaternion256* %12, i32 0, i32 0
	store double %90, double* %94
	%95 = getelementptr inbounds %..quaternion256, %..quaternion256* %12, i32 0, i32 1
	store double %91, double* %95
	%96 = getelementptr inbounds %..quaternion256, %..quaternion256* %12, i32 0, i32 2
	store double %92, double* %96
	%97 = load %..quaternion256, %..quaternion256* %12, align 8
	store %..quaternion256 %97, %..quaternion256* %agg.result
	ret void
}

define void @runtime.quo_quaternion128(%..quaternion128* sret noalias %agg.result, %..quaternion128* %_.0, %..quaternion128* %_.1) #0 {
decls-0:
	%0 = alloca float, align 16
	%1 = alloca float, align 16
	%2 = alloca float, align 16
	%3 = alloca float, align 16
	%4 = alloca float, align 16
	%5 = alloca float, align 16
	%6 = alloca float, align 16
	%7 = alloca float, align 16
	%8 = alloca float, align 16
	%9 = alloca float, align 16
	%10 = alloca float, align 16
	%11 = alloca float, align 16
	%12 = alloca float, align 16
	%13 = alloca %..quaternion128, align 16
	; q0
	; q1
	; q2
	; q3
	; real
	%14 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%15 = extractvalue %..quaternion128 %14, 3
	; imag
	%16 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%17 = extractvalue %..quaternion128 %16, 0
	; jmag
	%18 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%19 = extractvalue %..quaternion128 %18, 1
	; kmag
	%20 = load %..quaternion128, %..quaternion128* %_.0, align 4
	%21 = extractvalue %..quaternion128 %20, 2
	store float %15, float* %0
	store float %17, float* %1
	store float %19, float* %2
	store float %21, float* %3
	; r0
	; r1
	; r2
	; r3
	; real
	%22 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%23 = extractvalue %..quaternion128 %22, 3
	; imag
	%24 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%25 = extractvalue %..quaternion128 %24, 0
	; jmag
	%26 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%27 = extractvalue %..quaternion128 %26, 1
	; kmag
	%28 = load %..quaternion128, %..quaternion128* %_.1, align 4
	%29 = extractvalue %..quaternion128 %28, 2
	store float %23, float* %4
	store float %25, float* %5
	store float %27, float* %6
	store float %29, float* %7
	; invmag2
	%30 = load float, float* %4, align 4
	%31 = load float, float* %4, align 4
	%32 = fmul float %30, %31
	%33 = load float, float* %5, align 4
	%34 = load float, float* %5, align 4
	%35 = fmul float %33, %34
	%36 = fadd float %32, %35
	%37 = load float, float* %6, align 4
	%38 = load float, float* %6, align 4
	%39 = fmul float %37, %38
	%40 = fadd float %36, %39
	%41 = load float, float* %7, align 4
	%42 = load float, float* %7, align 4
	%43 = fmul float %41, %42
	%44 = fadd float %40, %43
	%45 = fdiv float bitcast (i32 1065353216 to float), %44
	store float %45, float* %8
	; t0
	%46 = load float, float* %4, align 4
	%47 = load float, float* %0, align 4
	%48 = fmul float %46, %47
	%49 = load float, float* %5, align 4
	%50 = load float, float* %1, align 4
	%51 = fmul float %49, %50
	%52 = fadd float %48, %51
	%53 = load float, float* %6, align 4
	%54 = load float, float* %2, align 4
	%55 = fmul float %53, %54
	%56 = fadd float %52, %55
	%57 = load float, float* %7, align 4
	%58 = load float, float* %3, align 4
	%59 = fmul float %57, %58
	%60 = fadd float %56, %59
	%61 = load float, float* %8, align 4
	%62 = fmul float %60, %61
	store float %62, float* %9
	; t1
	%63 = load float, float* %4, align 4
	%64 = load float, float* %1, align 4
	%65 = fmul float %63, %64
	%66 = load float, float* %5, align 4
	%67 = load float, float* %0, align 4
	%68 = fmul float %66, %67
	%69 = fsub float %65, %68
	%70 = load float, float* %6, align 4
	%71 = load float, float* %3, align 4
	%72 = fmul float %70, %71
	%73 = fsub float %69, %72
	%74 = load float, float* %7, align 4
	%75 = load float, float* %2, align 4
	%76 = fmul float %74, %75
	%77 = fsub float %73, %76
	%78 = load float, float* %8, align 4
	%79 = fmul float %77, %78
	store float %79, float* %10
	; t2
	%80 = load float, float* %4, align 4
	%81 = load float, float* %2, align 4
	%82 = fmul float %80, %81
	%83 = load float, float* %5, align 4
	%84 = load float, float* %3, align 4
	%85 = fmul float %83, %84
	%86 = fsub float %82, %85
	%87 = load float, float* %6, align 4
	%88 = load float, float* %0, align 4
	%89 = fmul float %87, %88
	%90 = fsub float %86, %89
	%91 = load float, float* %7, align 4
	%92 = load float, float* %1, align 4
	%93 = fmul float %91, %92
	%94 = fadd float %90, %93
	%95 = load float, float* %8, align 4
	%96 = fmul float %94, %95
	store float %96, float* %11
	; t3
	%97 = load float, float* %4, align 4
	%98 = load float, float* %3, align 4
	%99 = fmul float %97, %98
	%100 = load float, float* %5, align 4
	%101 = load float, float* %2, align 4
	%102 = fmul float %100, %101
	%103 = fadd float %99, %102
	%104 = load float, float* %6, align 4
	%105 = load float, float* %1, align 4
	%106 = fmul float %104, %105
	%107 = fadd float %103, %106
	%108 = load float, float* %7, align 4
	%109 = load float, float* %0, align 4
	%110 = fmul float %108, %109
	%111 = fsub float %107, %110
	%112 = load float, float* %8, align 4
	%113 = fmul float %111, %112
	store float %113, float* %12
	; ReturnStmt
	; quaternion
	%114 = load float, float* %9, align 4
	%115 = load float, float* %10, align 4
	%116 = load float, float* %11, align 4
	%117 = load float, float* %12, align 4
	%118 = getelementptr inbounds %..quaternion128, %..quaternion128* %13, i32 0, i32 3
	store float %114, float* %118
	%119 = getelementptr inbounds %..quaternion128, %..quaternion128* %13, i32 0, i32 0
	store float %115, float* %119
	%120 = getelementptr inbounds %..quaternion128, %..quaternion128* %13, i32 0, i32 1
	store float %116, float* %120
	%121 = getelementptr inbounds %..quaternion128, %..quaternion128* %13, i32 0, i32 2
	store float %117, float* %121
	%122 = load %..quaternion128, %..quaternion128* %13, align 4
	store %..quaternion128 %122, %..quaternion128* %agg.result
	ret void
}

define void @runtime.quo_quaternion256(%..quaternion256* sret noalias %agg.result, %..quaternion256* %_.0, %..quaternion256* %_.1) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca double, align 16
	%2 = alloca double, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	%5 = alloca double, align 16
	%6 = alloca double, align 16
	%7 = alloca double, align 16
	%8 = alloca double, align 16
	%9 = alloca double, align 16
	%10 = alloca double, align 16
	%11 = alloca double, align 16
	%12 = alloca double, align 16
	%13 = alloca %..quaternion256, align 16
	; q0
	; q1
	; q2
	; q3
	; real
	%14 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%15 = extractvalue %..quaternion256 %14, 3
	; imag
	%16 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%17 = extractvalue %..quaternion256 %16, 0
	; jmag
	%18 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%19 = extractvalue %..quaternion256 %18, 1
	; kmag
	%20 = load %..quaternion256, %..quaternion256* %_.0, align 8
	%21 = extractvalue %..quaternion256 %20, 2
	store double %15, double* %0
	store double %17, double* %1
	store double %19, double* %2
	store double %21, double* %3
	; r0
	; r1
	; r2
	; r3
	; real
	%22 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%23 = extractvalue %..quaternion256 %22, 3
	; imag
	%24 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%25 = extractvalue %..quaternion256 %24, 0
	; jmag
	%26 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%27 = extractvalue %..quaternion256 %26, 1
	; kmag
	%28 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%29 = extractvalue %..quaternion256 %28, 2
	store double %23, double* %4
	store double %25, double* %5
	store double %27, double* %6
	store double %29, double* %7
	; invmag2
	%30 = load double, double* %4, align 8
	%31 = load double, double* %4, align 8
	%32 = fmul double %30, %31
	%33 = load double, double* %5, align 8
	%34 = load double, double* %5, align 8
	%35 = fmul double %33, %34
	%36 = fadd double %32, %35
	%37 = load double, double* %6, align 8
	%38 = load double, double* %6, align 8
	%39 = fmul double %37, %38
	%40 = fadd double %36, %39
	%41 = load double, double* %7, align 8
	%42 = load double, double* %7, align 8
	%43 = fmul double %41, %42
	%44 = fadd double %40, %43
	%45 = fdiv double 0x3ff0000000000000, %44
	store double %45, double* %8
	; t0
	%46 = load double, double* %4, align 8
	%47 = load double, double* %0, align 8
	%48 = fmul double %46, %47
	%49 = load double, double* %5, align 8
	%50 = load double, double* %1, align 8
	%51 = fmul double %49, %50
	%52 = fadd double %48, %51
	%53 = load double, double* %6, align 8
	%54 = load double, double* %2, align 8
	%55 = fmul double %53, %54
	%56 = fadd double %52, %55
	%57 = load double, double* %7, align 8
	%58 = load double, double* %3, align 8
	%59 = fmul double %57, %58
	%60 = fadd double %56, %59
	%61 = load double, double* %8, align 8
	%62 = fmul double %60, %61
	store double %62, double* %9
	; t1
	%63 = load double, double* %4, align 8
	%64 = load double, double* %1, align 8
	%65 = fmul double %63, %64
	%66 = load double, double* %5, align 8
	%67 = load double, double* %0, align 8
	%68 = fmul double %66, %67
	%69 = fsub double %65, %68
	%70 = load double, double* %6, align 8
	%71 = load double, double* %3, align 8
	%72 = fmul double %70, %71
	%73 = fsub double %69, %72
	%74 = load double, double* %7, align 8
	%75 = load double, double* %2, align 8
	%76 = fmul double %74, %75
	%77 = fsub double %73, %76
	%78 = load double, double* %8, align 8
	%79 = fmul double %77, %78
	store double %79, double* %10
	; t2
	%80 = load double, double* %4, align 8
	%81 = load double, double* %2, align 8
	%82 = fmul double %80, %81
	%83 = load double, double* %5, align 8
	%84 = load double, double* %3, align 8
	%85 = fmul double %83, %84
	%86 = fsub double %82, %85
	%87 = load double, double* %6, align 8
	%88 = load double, double* %0, align 8
	%89 = fmul double %87, %88
	%90 = fsub double %86, %89
	%91 = load double, double* %7, align 8
	%92 = load double, double* %1, align 8
	%93 = fmul double %91, %92
	%94 = fadd double %90, %93
	%95 = load double, double* %8, align 8
	%96 = fmul double %94, %95
	store double %96, double* %11
	; t3
	%97 = load double, double* %4, align 8
	%98 = load double, double* %3, align 8
	%99 = fmul double %97, %98
	%100 = load double, double* %5, align 8
	%101 = load double, double* %2, align 8
	%102 = fmul double %100, %101
	%103 = fadd double %99, %102
	%104 = load double, double* %6, align 8
	%105 = load double, double* %1, align 8
	%106 = fmul double %104, %105
	%107 = fadd double %103, %106
	%108 = load double, double* %7, align 8
	%109 = load double, double* %0, align 8
	%110 = fmul double %108, %109
	%111 = fsub double %107, %110
	%112 = load double, double* %8, align 8
	%113 = fmul double %111, %112
	store double %113, double* %12
	; ReturnStmt
	; quaternion
	%114 = load double, double* %9, align 8
	%115 = load double, double* %10, align 8
	%116 = load double, double* %11, align 8
	%117 = load double, double* %12, align 8
	%118 = getelementptr inbounds %..quaternion256, %..quaternion256* %13, i32 0, i32 3
	store double %114, double* %118
	%119 = getelementptr inbounds %..quaternion256, %..quaternion256* %13, i32 0, i32 0
	store double %115, double* %119
	%120 = getelementptr inbounds %..quaternion256, %..quaternion256* %13, i32 0, i32 1
	store double %116, double* %120
	%121 = getelementptr inbounds %..quaternion256, %..quaternion256* %13, i32 0, i32 2
	store double %117, double* %121
	%122 = load %..quaternion256, %..quaternion256* %13, align 8
	store %..quaternion256 %122, %..quaternion256* %agg.result
	ret void
}

define %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %_.0) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca {[0 x i64], [88 x i8], i64}, align 16
	store %runtime.Type_Info* %_.0, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %runtime.Type_Info* zeroinitializer

if.done-2:
	; base
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	store %runtime.Type_Info* %8, %runtime.Type_Info** %1
	; ForStmt
	br label %for.body-3

for.body-3:
	; TypeSwitchStmt
	; SelectorExpr
	%9 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%10 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %9, i32 0, i32 3
	%11 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %10, align 8
	; get union's tag
	%12 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %10, i64 0, i32 2 ; UnionTagPtr
	%13 = load i64, i64* %12, align 8
	%14 = bitcast {[0 x i64], [88 x i8], i64}* %10 to %..rawptr
	%15 = icmp eq i64 %13, 1
	br i1 %15, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	store {[0 x i64], [88 x i8], i64} %11, {[0 x i64], [88 x i8], i64}* %3
	; break
	; ReturnStmt
	%16 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	ret %runtime.Type_Info* %16

typeswitch.body-5:
	%17 = bitcast %..rawptr %14 to %runtime.Type_Info_Named*
	%18 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %17, align 8
	store %runtime.Type_Info_Named %18, %runtime.Type_Info_Named* %2
	; AssignStmt
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i32 0, i32 1
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	store %runtime.Type_Info* %20, %runtime.Type_Info** %1
	br label %for.body-3
}

define %runtime.Type_Info* @runtime.__type_info_of(%..typeid %_.0) #0 {
decls-0:
	%0 = alloca %..typeid, align 16
	%1 = alloca <{[0 x i64], [8 x i8]}>, align 16
	%2 = alloca i64, align 16
	store %..typeid %_.0, %..typeid* %0
	; data
	%3 = bitcast %..typeid* %0 to <{[0 x i64], [8 x i8]}>*
	%4 = load <{[0 x i64], [8 x i8]}>, <{[0 x i64], [8 x i8]}>* %3, align 8
	store <{[0 x i64], [8 x i8]}> %4, <{[0 x i64], [8 x i8]}>* %1
	; n
	; SelectorExpr
	%5 = bitcast <{[0 x i64], [8 x i8]}>* %1 to i8*
	%6 = getelementptr inbounds i8, i8* %5, i64 0
	%7 = bitcast i8* %6 to i64*
	%8 = load i64, i64* %7, align 1
	%9 = shl i64 %8, 8
	%10 = lshr i64 %9, 8
	%11 = bitcast i64 %10 to i64
	store i64 %11, i64* %2
	; IfStmt
	%12 = load i64, i64* %2, align 8
	%13 = icmp slt i64 %12, 0
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%16 = load i64, i64* %2, align 8
	%17 = load {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, align 8
	%18 = extractvalue {%runtime.Type_Info*, i64} %17, 1
	%19 = icmp sge i64 %16, %18
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %if.then-2, label %if.done-3

if.then-2:
	; AssignStmt
	store i64 0, i64* %2
	br label %if.done-3

if.done-3:
	; ReturnStmt
	; IndexExpr
	%22 = load {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, align 8
	%23 = extractvalue {%runtime.Type_Info*, i64} %22, 0
	%24 = load i64, i64* %2, align 8
	%25 = extractvalue {%runtime.Type_Info*, i64} %22, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$57, i32 0, i32 0), i64 62}, i64 311, i64 21, i64 %24, i64 %25)
	%26 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %23, i64 %24
	ret %runtime.Type_Info* %26
}

define %..typeid @runtime.typeid_base(%..typeid %_.0) #0 {
decls-0:
	%0 = alloca %..typeid, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	store %..typeid %_.0, %..typeid* %0
	; ti
	%2 = load %..typeid, %..typeid* %0, align 8
	%3 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %2)
	store %runtime.Type_Info* %3, %runtime.Type_Info** %1
	; AssignStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%5 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %4)
	store %runtime.Type_Info* %5, %runtime.Type_Info** %1
	; ReturnStmt
	; SelectorExpr
	%6 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%7 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %6, i32 0, i32 2
	%8 = load %..typeid, %..typeid* %7, align 8
	ret %..typeid %8
}

define void @runtime.__init_context(%runtime.Context* %_.0) #0 {
decls-0:
	%0 = alloca %runtime.Context*, align 16
	store %runtime.Context* %_.0, %runtime.Context** %0
	; IfStmt
	%1 = load %runtime.Context*, %runtime.Context** %0, align 8
	%2 = icmp eq %runtime.Context* %1, zeroinitializer
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%5 = load %runtime.Context*, %runtime.Context** %0, align 8
	%6 = getelementptr inbounds %runtime.Context, %runtime.Context* %5, i32 0, i32 0
	%7 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i32 0, i32 0
	; SelectorExpr
	%8 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @os.heap_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %8, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %7
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%9 = load %runtime.Context*, %runtime.Context** %0, align 8
	%10 = getelementptr inbounds %runtime.Context, %runtime.Context* %9, i32 0, i32 0
	%11 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %10, i32 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %11
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%12 = load %runtime.Context*, %runtime.Context** %0, align 8
	%13 = getelementptr inbounds %runtime.Context, %runtime.Context* %12, i32 0, i32 1
	%14 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %13, i32 0, i32 0
	; SelectorExpr
	%15 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @mem.scratch_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %15, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %14
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%16 = load %runtime.Context*, %runtime.Context** %0, align 8
	%17 = getelementptr inbounds %runtime.Context, %runtime.Context* %16, i32 0, i32 1
	%18 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %17, i32 0, i32 1
	%19 = bitcast %mem.Scratch_Allocator* @runtime.global_scratch_allocator_data to %..rawptr
	store %..rawptr %19, %..rawptr* %18
	; AssignStmt
	; SelectorExpr
	%20 = load %runtime.Context*, %runtime.Context** %0, align 8
	%21 = getelementptr inbounds %runtime.Context, %runtime.Context* %20, i32 0, i32 7
	; SelectorExpr
	%22 = call i64 @os.current_thread_id()
	store i64 %22, i64* %21
	; AssignStmt
	; SelectorExpr
	%23 = load %runtime.Context*, %runtime.Context** %0, align 8
	%24 = getelementptr inbounds %runtime.Context, %runtime.Context* %23, i32 0, i32 2
	%25 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %25, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %24
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%26 = load %runtime.Context*, %runtime.Context** %0, align 8
	%27 = getelementptr inbounds %runtime.Context, %runtime.Context* %26, i32 0, i32 3
	%28 = getelementptr inbounds %log.Logger, %log.Logger* %27, i32 0, i32 0
	; SelectorExpr
	%29 = bitcast void (%..rawptr, i64, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)* @log.nil_logger_proc to void (%..rawptr, i64, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..rawptr, i64, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)* %29, void (%..rawptr, i64, %..string, i8, %runtime.Source_Code_Location*, %runtime.Context*)** %28
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%30 = load %runtime.Context*, %runtime.Context** %0, align 8
	%31 = getelementptr inbounds %runtime.Context, %runtime.Context* %30, i32 0, i32 3
	%32 = getelementptr inbounds %log.Logger, %log.Logger* %31, i32 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %32
	; AssignStmt
	; SelectorExpr
	%33 = load %runtime.Context*, %runtime.Context** %0, align 8
	%34 = getelementptr inbounds %runtime.Context, %runtime.Context* %33, i32 0, i32 4
	; SelectorExpr
	%35 = load i64, i64* @os.stdin, align 8
	store i64 %35, i64* %34
	; AssignStmt
	; SelectorExpr
	%36 = load %runtime.Context*, %runtime.Context** %0, align 8
	%37 = getelementptr inbounds %runtime.Context, %runtime.Context* %36, i32 0, i32 5
	; SelectorExpr
	%38 = load i64, i64* @os.stdout, align 8
	store i64 %38, i64* %37
	; AssignStmt
	; SelectorExpr
	%39 = load %runtime.Context*, %runtime.Context** %0, align 8
	%40 = getelementptr inbounds %runtime.Context, %runtime.Context* %39, i32 0, i32 6
	; SelectorExpr
	%41 = load i64, i64* @os.stderr, align 8
	store i64 %41, i64* %40
	ret void
}

define void @runtime.default_assertion_failure_proc(%..string %_.0, %..string %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	%5 = alloca {i64, i64}, align 16
	%6 = alloca {i64, i64}, align 16
	%7 = alloca {i64, i64}, align 16
	store %..string %_.0, %..string* %0
	store %..string %_.1, %..string* %1
	; fd
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 6
	%9 = load i64, i64* %8, align 8
	store i64 %9, i64* %2
	%10 = load i64, i64* %2, align 8
	call void @runtime.print_caller_location(i64 %10, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%11 = load i64, i64* %2, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %3, align 1
	call void @os.write_string({i64, i64}* %3, i64 %11, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$58, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%12 = load i64, i64* %2, align 8
	%13 = load %..string, %..string* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %4, align 1
	call void @os.write_string({i64, i64}* %4, i64 %12, %..string %13, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	%14 = load %..string, %..string* %1, align 8
	%15 = extractvalue %..string %14, 1
	%16 = icmp sgt i64 %15, 0
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	%19 = load i64, i64* %2, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %5, align 1
	call void @os.write_string({i64, i64}* %5, i64 %19, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$59, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%20 = load i64, i64* %2, align 8
	%21 = load %..string, %..string* %1, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %6, align 1
	call void @os.write_string({i64, i64}* %6, i64 %20, %..string %21, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SelectorExpr
	%22 = load i64, i64* %2, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %7, align 1
	call void @os.write_byte({i64, i64}* %7, i64 %22, i8 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	call void @llvm.debugtrap()
	ret void
}

define i8 @runtime.assert(i1 %_.0, %..string %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %..string, align 16
	%2 = zext i1 %_.0 to i8
	store i8 %2, i8* %0
	store %..string %_.1, %..string* %1
	; IfStmt
	%3 = load i8, i8* %0, align 1
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.done-2, label %if.then-1

if.then-1:
	%5 = load %..string, %..string* %1, align 8
	call void @runtime.assert$anon-0(%..string %5, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%6 = load i8, i8* %0, align 1
	ret i8 %6
}

define void @runtime.assert$anon-0(%..string %_.0, %runtime.Source_Code_Location* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, align 16
	store %..string %_.0, %..string* %0
	; p
	; SelectorExpr
	%2 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 2
	%3 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2, align 8
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %3, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	; IfStmt
	%4 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%5 = icmp eq void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%8 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %8, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	br label %if.done-2

if.done-2:
	%9 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%10 = load %..string, %..string* %0, align 8
	call void %9(%..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$5a, i32 0, i32 0), i64 17}, %..string %10, %runtime.Source_Code_Location* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @runtime.panic(%..string %_.0, %runtime.Source_Code_Location* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 noreturn {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, align 16
	store %..string %_.0, %..string* %0
	; p
	; SelectorExpr
	%2 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 2
	%3 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %2, align 8
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %3, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	; IfStmt
	%4 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%5 = icmp eq void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%8 = bitcast void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* @runtime.default_assertion_failure_proc to void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*
	store void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)* %8, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1
	br label %if.done-2

if.done-2:
	%9 = load void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)*, void (%..string, %..string, %runtime.Source_Code_Location*, %runtime.Context*)** %1, align 8
	%10 = load %..string, %..string* %0, align 8
	call void %9(%..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$5b, i32 0, i32 0), i64 5}, %..string %10, %runtime.Source_Code_Location* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @LinkedList.main() #0 {
decls-0:
	%0 = alloca %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, align 16
	%1 = alloca %runtime.Context, align 16
	%2 = bitcast %runtime.Context* %1 to %..rawptr
	; ZeroInit
	%3 = call %..rawptr @mem.zero(%..rawptr %2, i64 144)
	%4 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %4, %runtime.Context* %1
	call void @runtime.__init_context(%runtime.Context* %1)
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca i64*, align 16
	%7 = alloca %runtime.Source_Code_Location, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	%12 = alloca i64, align 16
	%13 = alloca %..any, align 16
	%14 = alloca {%..any*, i64}, align 16
	%15 = alloca [1 x %..any], align 16
	; list
	; SelectorExpr
	%16 = getelementptr inbounds %runtime.Context, %runtime.Context* %1, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$5c, i32 0, i32 0), i64 72}, i64 108, i64 13, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$5d, i32 0, i32 0), i64 4}, i64 12378879641500791202}, %runtime.Source_Code_Location* %5
	%17 = call %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* @mem.new-6207(%mem.Allocator* %16, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture %1)
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %17, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0
	; value
	; SelectorExpr
	%18 = getelementptr inbounds %runtime.Context, %runtime.Context* %1, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$5e, i32 0, i32 0), i64 72}, i64 110, i64 14, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$5f, i32 0, i32 0), i64 4}, i64 12378878541989166353}, %runtime.Source_Code_Location* %7
	%19 = call i64* @mem.new-6217(%mem.Allocator* %18, %runtime.Source_Code_Location* %7, %runtime.Context* noalias nonnull nocapture %1)
	store i64* %19, i64** %6
	; AssignStmt
	%20 = load i64*, i64** %6, align 8
	%21 = getelementptr inbounds i64, i64* %20, i64 0
	store i64 1, i64* %21
	%22 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%23 = load i64*, i64** %6, align 8
	call void @LinkedList.insert-6232(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %22, i64* %23, %runtime.Context* noalias nonnull nocapture %1)
	; AssignStmt
	; SelectorExpr
	%24 = getelementptr inbounds %runtime.Context, %runtime.Context* %1, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$60, i32 0, i32 0), i64 72}, i64 114, i64 13, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$61, i32 0, i32 0), i64 4}, i64 12378851054198474640}, %runtime.Source_Code_Location* %8
	%25 = call i64* @mem.new-6217(%mem.Allocator* %24, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture %1)
	store i64* %25, i64** %6
	; AssignStmt
	%26 = load i64*, i64** %6, align 8
	%27 = getelementptr inbounds i64, i64* %26, i64 0
	store i64 1, i64* %27
	%28 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%29 = load i64*, i64** %6, align 8
	call void @LinkedList.insert-6232(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %28, i64* %29, %runtime.Context* noalias nonnull nocapture %1)
	; AssignStmt
	; SelectorExpr
	%30 = getelementptr inbounds %runtime.Context, %runtime.Context* %1, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$62, i32 0, i32 0), i64 72}, i64 118, i64 13, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$63, i32 0, i32 0), i64 4}, i64 12378855452244987556}, %runtime.Source_Code_Location* %9
	%31 = call i64* @mem.new-6217(%mem.Allocator* %30, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture %1)
	store i64* %31, i64** %6
	; AssignStmt
	%32 = load i64*, i64** %6, align 8
	%33 = getelementptr inbounds i64, i64* %32, i64 0
	store i64 1, i64* %33
	%34 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%35 = load i64*, i64** %6, align 8
	call void @LinkedList.insert-6232(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %34, i64* %35, %runtime.Context* noalias nonnull nocapture %1)
	; AssignStmt
	; SelectorExpr
	%36 = getelementptr inbounds %runtime.Context, %runtime.Context* %1, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$64, i32 0, i32 0), i64 72}, i64 122, i64 13, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$65, i32 0, i32 0), i64 4}, i64 12378859850291497320}, %runtime.Source_Code_Location* %10
	%37 = call i64* @mem.new-6217(%mem.Allocator* %36, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture %1)
	store i64* %37, i64** %6
	; AssignStmt
	%38 = load i64*, i64** %6, align 8
	%39 = getelementptr inbounds i64, i64* %38, i64 0
	store i64 1, i64* %39
	%40 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%41 = load i64*, i64** %6, align 8
	call void @LinkedList.insert-6232(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %40, i64* %41, %runtime.Context* noalias nonnull nocapture %1)
	; AssignStmt
	; SelectorExpr
	%42 = getelementptr inbounds %runtime.Context, %runtime.Context* %1, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$66, i32 0, i32 0), i64 72}, i64 126, i64 13, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$67, i32 0, i32 0), i64 4}, i64 12378864248338010172}, %runtime.Source_Code_Location* %11
	%43 = call i64* @mem.new-6217(%mem.Allocator* %42, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture %1)
	store i64* %43, i64** %6
	; AssignStmt
	%44 = load i64*, i64** %6, align 8
	%45 = getelementptr inbounds i64, i64* %44, i64 0
	store i64 1, i64* %45
	%46 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%47 = load i64*, i64** %6, align 8
	call void @LinkedList.insert-6232(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %46, i64* %47, %runtime.Context* noalias nonnull nocapture %1)
	; ForStmt
	; i
	store i64 0, i64* %12
	br label %for.loop-1

for.loop-1:
	%48 = load i64, i64* %12, align 8
	%49 = icmp slt i64 %48, 5
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %for.body-2, label %for.done-3

for.body-2:
	; SelectorExpr
	; ZeroInit
	store %..any zeroinitializer, %..any* %13, align 1
	%52 = bitcast i64* %12 to %..rawptr
	%53 = getelementptr inbounds %..any, %..any* %13, i32 0, i32 0
	store %..rawptr %52, %..rawptr* %53
	%54 = getelementptr inbounds %..any, %..any* %13, i32 0, i32 1
	store %..typeid 4683743612465315844, %..typeid* %54
	%55 = load %..any, %..any* %13, align 8
	; variadic call argument generation
	; ZeroInit
	store {%..any*, i64} zeroinitializer, {%..any*, i64}* %14, align 1
	; ZeroInit
	store [1 x %..any] zeroinitializer, [1 x %..any]* %15, align 1
	%56 = getelementptr inbounds [1 x %..any], [1 x %..any]* %15, i32 0, i32 0
	store %..any %55, %..any* %56
	%57 = getelementptr inbounds [1 x %..any], [1 x %..any]* %15, i32 0, i32 0
	%58 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i32 0, i32 0
	store %..any* %57, %..any** %58
	%59 = getelementptr inbounds {%..any*, i64}, {%..any*, i64}* %14, i32 0, i32 1
	store i64 1, i64* %59
	%60 = call i64 @fmt.println({%..any*, i64}* %14, %runtime.Context* noalias nonnull nocapture %1)
	; AssignStmt
	%61 = load i64, i64* %12, align 8
	%62 = add i64 %61, 1
	store i64 %62, i64* %12
	br label %for.loop-1

for.done-3:
	%63 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%64 = call i64 @LinkedList.removeAt-6292(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %63, i64 2, %runtime.Context* noalias nonnull nocapture %1)
	ret void
}

define i64 @fmt.fprintln(i64 %_.0, {%..any*, i64}* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca [4096 x i8], align 16
	%2 = alloca %strings.Builder, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca %strings.Builder, align 16
	%5 = alloca %..string, align 16
	%6 = alloca %..string, align 16
	%7 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	; data
	%8 = bitcast [4096 x i8]* %1 to %..rawptr
	; ZeroInit
	%9 = call %..rawptr @mem.zero(%..rawptr %8, i64 4096)
	; buf
	; SelectorExpr
	; SliceExpr
	%10 = getelementptr inbounds [4096 x i8], [4096 x i8]* %1, i32 0, i32 0
	%11 = getelementptr inbounds i8, i8* %10, i64 0
	%12 = sub i64 4096, 0
	%13 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i32 0, i32 0
	store i8* %11, i8** %13
	%14 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i32 0, i32 1
	store i64 %12, i64* %14
	%15 = bitcast %strings.Builder* %4 to %..rawptr
	; ZeroInit
	%16 = call %..rawptr @mem.zero(%..rawptr %15, i64 40)
	call void @strings.builder_from_slice(%strings.Builder* %4, {i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%17 = load %strings.Builder, %strings.Builder* %4, align 8
	store %strings.Builder %17, %strings.Builder* %2
	; res
	; ZeroInit
	store %..string zeroinitializer, %..string* %6, align 1
	call void @fmt.sbprintln(%..string* %6, %strings.Builder* %2, {%..any*, i64}* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%18 = load %..string, %..string* %6, align 8
	store %..string %18, %..string* %5
	; SelectorExpr
	%19 = load i64, i64* %0, align 8
	%20 = load %..string, %..string* %5, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %7, align 1
	call void @os.write_string({i64, i64}* %7, i64 %19, %..string %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	%21 = load %..string, %..string* %5, align 8
	%22 = extractvalue %..string %21, 1
	ret i64 %22
}

define i64 @fmt.println({%..any*, i64}* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	; ReturnStmt
	; SelectorExpr
	%0 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 5
	%1 = load i64, i64* %0, align 8
	%2 = call i64 @fmt.fprintln(i64 %1, {%..any*, i64}* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret i64 %2
}

define void @fmt.sbprintln(%..string* sret noalias %agg.result, %strings.Builder* %_.0, {%..any*, i64}* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca %fmt.Info, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca %..string, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	; fi
	%6 = bitcast %fmt.Info* %1 to %..rawptr
	; ZeroInit
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 72)
	; AssignStmt
	; SelectorExpr
	%8 = getelementptr inbounds %fmt.Info, %fmt.Info* %1, i32 0, i32 12
	%9 = load %strings.Builder*, %strings.Builder** %0, align 8
	store %strings.Builder* %9, %strings.Builder** %8
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	%10 = load {%..any*, i64}, {%..any*, i64}* %_.1, align 8
	%11 = extractvalue {%..any*, i64} %10, 1
	store i64 %11, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-1

for.index.loop-1:
	%12 = load i64, i64* %4, align 8
	%13 = add i64 %12, 1
	store i64 %13, i64* %4
	%14 = load i64, i64* %3, align 8
	%15 = icmp slt i64 %13, %14
	br i1 %15, label %for.index.body-2, label %for.index.done-5

for.index.body-2:
	%16 = load i64, i64* %4, align 8
	store i64 %16, i64* %2
	; IfStmt
	%17 = load i64, i64* %2, align 8
	%18 = icmp sgt i64 %17, 0
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-3, label %if.done-4

if.then-3:
	; SelectorExpr
	%21 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %21, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-4

if.done-4:
	; IndexExpr
	%22 = load {%..any*, i64}, {%..any*, i64}* %_.1, align 8
	%23 = extractvalue {%..any*, i64} %22, 0
	%24 = load i64, i64* %2, align 8
	%25 = extractvalue {%..any*, i64} %22, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$68, i32 0, i32 0), i64 57}, i64 182, i64 23, i64 %24, i64 %25)
	%26 = getelementptr inbounds %..any, %..any* %23, i64 %24
	%27 = load %..any, %..any* %26, align 8
	call void @fmt.fmt_value(%fmt.Info* %1, %..any %27, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-1

for.index.done-5:
	; SelectorExpr
	%28 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %28, i8 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	; SelectorExpr
	%29 = load %strings.Builder*, %strings.Builder** %0, align 8
	%30 = getelementptr inbounds %strings.Builder, %strings.Builder* %29, i64 0
	; ZeroInit
	store %..string zeroinitializer, %..string* %5, align 1
	call void @strings.to_string(%..string* %5, %strings.Builder* %30, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%31 = load %..string, %..string* %5, align 8
	store %..string %31, %..string* %agg.result
	ret void
}

define void @fmt.fmt_bad_verb(%fmt.Info* %_.0, i32 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i32, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i32 %_.1, i32* %1
	; SelectorExpr
	%2 = load %fmt.Info*, %fmt.Info** %0, align 8
	%3 = getelementptr inbounds %fmt.Info, %fmt.Info* %2, i32 0, i32 12
	%4 = load %strings.Builder*, %strings.Builder** %3, align 8
	call void @strings.write_string(%strings.Builder* %4, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$69, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%5 = load %fmt.Info*, %fmt.Info** %0, align 8
	%6 = getelementptr inbounds %fmt.Info, %fmt.Info* %5, i32 0, i32 12
	%7 = load %strings.Builder*, %strings.Builder** %6, align 8
	%8 = load i32, i32* %1, align 4
	%9 = call i64 @strings.write_rune(%strings.Builder* %7, i32 %8, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%10 = load %fmt.Info*, %fmt.Info** %0, align 8
	%11 = getelementptr inbounds %fmt.Info, %fmt.Info* %10, i32 0, i32 12
	%12 = load %strings.Builder*, %strings.Builder** %11, align 8
	call void @strings.write_byte(%strings.Builder* %12, i8 40, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%13 = load %fmt.Info*, %fmt.Info** %0, align 8
	%14 = getelementptr inbounds %fmt.Info, %fmt.Info* %13, i32 0, i32 13
	%15 = getelementptr inbounds %..any, %..any* %14, i32 0, i32 1
	%16 = load %..typeid, %..typeid* %15, align 8
	%17 = icmp ne %..typeid %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.else-2

if.then-1:
	; SelectorExpr
	%20 = load %fmt.Info*, %fmt.Info** %0, align 8
	%21 = getelementptr inbounds %fmt.Info, %fmt.Info* %20, i32 0, i32 12
	%22 = load %strings.Builder*, %strings.Builder** %21, align 8
	; SelectorExpr
	%23 = load %fmt.Info*, %fmt.Info** %0, align 8
	%24 = getelementptr inbounds %fmt.Info, %fmt.Info* %23, i32 0, i32 13
	%25 = getelementptr inbounds %..any, %..any* %24, i32 0, i32 1
	%26 = load %..typeid, %..typeid* %25, align 8
	call void @reflect.write_typeid(%strings.Builder* %22, %..typeid %26, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%27 = load %fmt.Info*, %fmt.Info** %0, align 8
	%28 = getelementptr inbounds %fmt.Info, %fmt.Info* %27, i32 0, i32 12
	%29 = load %strings.Builder*, %strings.Builder** %28, align 8
	call void @strings.write_byte(%strings.Builder* %29, i8 61, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%30 = load %fmt.Info*, %fmt.Info** %0, align 8
	%31 = load %fmt.Info*, %fmt.Info** %0, align 8
	%32 = getelementptr inbounds %fmt.Info, %fmt.Info* %31, i32 0, i32 13
	%33 = load %..any, %..any* %32, align 8
	call void @fmt.fmt_value(%fmt.Info* %30, %..any %33, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-3

if.else-2:
	; SelectorExpr
	%34 = load %fmt.Info*, %fmt.Info** %0, align 8
	%35 = getelementptr inbounds %fmt.Info, %fmt.Info* %34, i32 0, i32 12
	%36 = load %strings.Builder*, %strings.Builder** %35, align 8
	call void @strings.write_string(%strings.Builder* %36, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$6a, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-3

if.done-3:
	; SelectorExpr
	%37 = load %fmt.Info*, %fmt.Info** %0, align 8
	%38 = getelementptr inbounds %fmt.Info, %fmt.Info* %37, i32 0, i32 12
	%39 = load %strings.Builder*, %strings.Builder** %38, align 8
	call void @strings.write_byte(%strings.Builder* %39, i8 41, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @fmt.fmt_bool(%fmt.Info* %_.0, i1 %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca i32, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	%3 = zext i1 %_.1 to i8
	store i8 %3, i8* %1
	store i32 %_.2, i32* %2
	; SwitchStmt
	%4 = load i32, i32* %2, align 4
	%5 = icmp eq i32 %4, 116
	br i1 %5, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%6 = icmp eq i32 %4, 118
	br i1 %6, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%7 = load %fmt.Info*, %fmt.Info** %0, align 8
	%8 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %7, i32 %8, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-7

switch.case.body-3:
	; SelectorExpr
	%9 = load %fmt.Info*, %fmt.Info** %0, align 8
	%10 = getelementptr inbounds %fmt.Info, %fmt.Info* %9, i32 0, i32 12
	%11 = load %strings.Builder*, %strings.Builder** %10, align 8
	; TernaryExpr
	%12 = load i8, i8* %1, align 1
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-6

if.else-5:
	br label %if.done-6

if.done-6:
	%14 = phi %..string [ {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$6b, i32 0, i32 0), i64 4}, %if.then-4 ], [ {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$6c, i32 0, i32 0), i64 5}, %if.else-5 ]
	call void @strings.write_string(%strings.Builder* %11, %..string %14, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-7

switch.done-7:
	ret void
}

define void @fmt.fmt_write_padding(%fmt.Info* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%4 = load i64, i64* %1, align 8
	%5 = icmp sle i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; pad_byte
	store i8 48, i8* %2
	; IfStmt
	; SelectorExpr
	%8 = load %fmt.Info*, %fmt.Info** %0, align 8
	%9 = getelementptr inbounds %fmt.Info, %fmt.Info* %8, i32 0, i32 2
	%10 = load i8, i8* %9, align 1
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	store i8 32, i8* %2
	br label %if.done-4

if.done-4:
	; ForStmt
	; i
	store i64 0, i64* %3
	br label %for.loop-5

for.loop-5:
	%12 = load i64, i64* %3, align 8
	%13 = load i64, i64* %1, align 8
	%14 = icmp slt i64 %12, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %for.body-6, label %for.done-7

for.body-6:
	; SelectorExpr
	; SelectorExpr
	%17 = load %fmt.Info*, %fmt.Info** %0, align 8
	%18 = getelementptr inbounds %fmt.Info, %fmt.Info* %17, i32 0, i32 12
	%19 = load %strings.Builder*, %strings.Builder** %18, align 8
	%20 = load i8, i8* %2, align 1
	call void @strings.write_byte(%strings.Builder* %19, i8 %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%21 = load i64, i64* %3, align 8
	%22 = add i64 %21, 1
	store i64 %22, i64* %3
	br label %for.loop-5

for.done-7:
	ret void
}

define void @fmt._fmt_int(%fmt.Info* %_.0, i64 %_.1, i64 %_.2, i1 %_.3, i64 %_.4, %..string %_.5, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca %..string, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca i64, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca i64, align 16
	%11 = alloca i8, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca [256 x i8], align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca %..string, align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca %..string, align 16
	%19 = alloca i8, align 16
	%20 = alloca i8, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	%21 = zext i1 %_.3 to i8
	store i8 %21, i8* %3
	store i64 %_.4, i64* %4
	store %..string %_.5, %..string* %5
	; neg
	; SelectorExpr
	%22 = load i64, i64* %1, align 8
	%23 = load i8, i8* %3, align 1
	%24 = load i64, i64* %4, align 8
	%25 = trunc i8 %23 to i1
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %7, align 1
	call void @strconv.is_integer_negative({i64, i8}* %7, i64 %22, i1 %25, i64 %24, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%26 = load {i64, i8}, {i64, i8}* %7, align 8
	%27 = extractvalue {i64, i8} %26, 1
	store i8 %27, i8* %6
	; IfStmt
	; SelectorExpr
	%28 = load %fmt.Info*, %fmt.Info** %0, align 8
	%29 = getelementptr inbounds %fmt.Info, %fmt.Info* %28, i32 0, i32 5
	%30 = load i8, i8* %29, align 1
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%32 = load %fmt.Info*, %fmt.Info** %0, align 8
	%33 = getelementptr inbounds %fmt.Info, %fmt.Info* %32, i32 0, i32 6
	%34 = load i8, i8* %33, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %if.then-2, label %if.done-5

if.then-2:
	; width
	; SelectorExpr
	%36 = load %fmt.Info*, %fmt.Info** %0, align 8
	%37 = getelementptr inbounds %fmt.Info, %fmt.Info* %36, i32 0, i32 7
	%38 = load i64, i64* %37, align 8
	; SelectorExpr
	%39 = load %fmt.Info*, %fmt.Info** %0, align 8
	%40 = getelementptr inbounds %fmt.Info, %fmt.Info* %39, i32 0, i32 8
	%41 = load i64, i64* %40, align 8
	%42 = add i64 %38, %41
	%43 = add i64 %42, 3
	store i64 %43, i64* %8
	; IfStmt
	%44 = load i64, i64* %8, align 8
	%45 = icmp sgt i64 %44, 256
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-3, label %if.done-4

if.then-3:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$6d, i32 0, i32 0), i64 57}, i64 446, i64 4, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$6e, i32 0, i32 0), i64 8}, i64 9009983153117460653}, %runtime.Source_Code_Location* %9
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$6f, i32 0, i32 0), i64 53}, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %if.done-4

if.done-4:
	br label %if.done-5

if.done-5:
	; prec
	store i64 0, i64* %10
	; IfStmt
	; SelectorExpr
	%48 = load %fmt.Info*, %fmt.Info** %0, align 8
	%49 = getelementptr inbounds %fmt.Info, %fmt.Info* %48, i32 0, i32 6
	%50 = load i8, i8* %49, align 1
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-6, label %if.else-10

if.then-6:
	; AssignStmt
	; SelectorExpr
	%52 = load %fmt.Info*, %fmt.Info** %0, align 8
	%53 = getelementptr inbounds %fmt.Info, %fmt.Info* %52, i32 0, i32 8
	%54 = load i64, i64* %53, align 8
	store i64 %54, i64* %10
	; IfStmt
	%55 = load i64, i64* %10, align 8
	%56 = icmp eq i64 %55, 0
	%57 = zext i1 %56 to i8
	%58 = trunc i8 %57 to i1
	br i1 %58, label %cmp.and-7, label %if.done-9

cmp.and-7:
	%59 = load i64, i64* %1, align 8
	%60 = icmp eq i64 %59, 0
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-8, label %if.done-9

if.then-8:
	; prev_zero
	; SelectorExpr
	%63 = load %fmt.Info*, %fmt.Info** %0, align 8
	%64 = getelementptr inbounds %fmt.Info, %fmt.Info* %63, i32 0, i32 3
	%65 = load i8, i8* %64, align 1
	store i8 %65, i8* %11
	; AssignStmt
	; SelectorExpr
	%66 = load %fmt.Info*, %fmt.Info** %0, align 8
	%67 = getelementptr inbounds %fmt.Info, %fmt.Info* %66, i32 0, i32 3
	store i8 0, i8* %67
	%68 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SelectorExpr
	%69 = load %fmt.Info*, %fmt.Info** %0, align 8
	%70 = getelementptr inbounds %fmt.Info, %fmt.Info* %69, i32 0, i32 7
	%71 = load i64, i64* %70, align 8
	call void @fmt.fmt_write_padding(%fmt.Info* %68, i64 %71, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%72 = load %fmt.Info*, %fmt.Info** %0, align 8
	%73 = getelementptr inbounds %fmt.Info, %fmt.Info* %72, i32 0, i32 3
	%74 = load i8, i8* %11, align 1
	store i8 %74, i8* %73
	; ReturnStmt
	ret void

if.done-9:
	br label %if.done-18

if.else-10:
	; IfStmt
	; SelectorExpr
	%75 = load %fmt.Info*, %fmt.Info** %0, align 8
	%76 = getelementptr inbounds %fmt.Info, %fmt.Info* %75, i32 0, i32 3
	%77 = load i8, i8* %76, align 1
	%78 = trunc i8 %77 to i1
	br i1 %78, label %cmp.and-11, label %if.done-17

cmp.and-11:
	; SelectorExpr
	%79 = load %fmt.Info*, %fmt.Info** %0, align 8
	%80 = getelementptr inbounds %fmt.Info, %fmt.Info* %79, i32 0, i32 5
	%81 = load i8, i8* %80, align 1
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-12, label %if.done-17

if.then-12:
	; AssignStmt
	; SelectorExpr
	%83 = load %fmt.Info*, %fmt.Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Info, %fmt.Info* %83, i32 0, i32 7
	%85 = load i64, i64* %84, align 8
	store i64 %85, i64* %10
	; IfStmt
	%86 = load i8, i8* %6, align 1
	%87 = trunc i8 %86 to i1
	br i1 %87, label %if.then-15, label %cmp.or-13

cmp.or-13:
	; SelectorExpr
	%88 = load %fmt.Info*, %fmt.Info** %0, align 8
	%89 = getelementptr inbounds %fmt.Info, %fmt.Info* %88, i32 0, i32 1
	%90 = load i8, i8* %89, align 1
	%91 = trunc i8 %90 to i1
	br i1 %91, label %if.then-15, label %cmp.or-14

cmp.or-14:
	; SelectorExpr
	%92 = load %fmt.Info*, %fmt.Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Info, %fmt.Info* %92, i32 0, i32 2
	%94 = load i8, i8* %93, align 1
	%95 = trunc i8 %94 to i1
	br i1 %95, label %if.then-15, label %if.done-16

if.then-15:
	; AssignStmt
	%96 = load i64, i64* %10, align 8
	%97 = sub i64 %96, 1
	store i64 %97, i64* %10
	br label %if.done-16

if.done-16:
	br label %if.done-17

if.done-17:
	br label %if.done-18

if.done-18:
	; SwitchStmt
	%98 = load i64, i64* %2, align 8
	%99 = icmp eq i64 %98, 2
	br i1 %99, label %switch.case.body-24, label %switch.case.next-19

switch.case.next-19:
	%100 = icmp eq i64 %98, 8
	br i1 %100, label %switch.case.body-24, label %switch.case.next-20

switch.case.next-20:
	%101 = icmp eq i64 %98, 10
	br i1 %101, label %switch.case.body-24, label %switch.case.next-21

switch.case.next-21:
	%102 = icmp eq i64 %98, 12
	br i1 %102, label %switch.case.body-24, label %switch.case.next-22

switch.case.next-22:
	%103 = icmp eq i64 %98, 16
	br i1 %103, label %switch.case.body-24, label %switch.case.next-23

switch.case.next-23:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$70, i32 0, i32 0), i64 57}, i64 472, i64 3, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$71, i32 0, i32 0), i64 8}, i64 9009876500489448618}, %runtime.Source_Code_Location* %12
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$72, i32 0, i32 0), i64 30}, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-25

switch.case.body-24:
	; break
	br label %switch.done-25

switch.done-25:
	; buf
	%104 = bitcast [256 x i8]* %13 to %..rawptr
	; ZeroInit
	%105 = call %..rawptr @mem.zero(%..rawptr %104, i64 256)
	; start
	store i64 0, i64* %14
	; flags
	; ZeroInit
	store i8 zeroinitializer, i8* %15, align 1
	; IfStmt
	; SelectorExpr
	%106 = load %fmt.Info*, %fmt.Info** %0, align 8
	%107 = getelementptr inbounds %fmt.Info, %fmt.Info* %106, i32 0, i32 4
	%108 = load i8, i8* %107, align 1
	%109 = trunc i8 %108 to i1
	br i1 %109, label %cmp.and-26, label %if.done-28

cmp.and-26:
	; SelectorExpr
	%110 = load %fmt.Info*, %fmt.Info** %0, align 8
	%111 = getelementptr inbounds %fmt.Info, %fmt.Info* %110, i32 0, i32 3
	%112 = load i8, i8* %111, align 1
	%113 = trunc i8 %112 to i1
	br i1 %113, label %if.done-28, label %if.then-27

if.then-27:
	; AssignStmt
	%114 = load i8, i8* %15, align 1
	%115 = or i8 %114, 1
	store i8 %115, i8* %15
	br label %if.done-28

if.done-28:
	; IfStmt
	; SelectorExpr
	%116 = load %fmt.Info*, %fmt.Info** %0, align 8
	%117 = getelementptr inbounds %fmt.Info, %fmt.Info* %116, i32 0, i32 1
	%118 = load i8, i8* %117, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %if.then-29, label %if.done-30

if.then-29:
	; AssignStmt
	%120 = load i8, i8* %15, align 1
	%121 = or i8 %120, 2
	store i8 %121, i8* %15
	br label %if.done-30

if.done-30:
	; IfStmt
	; SelectorExpr
	%122 = load %fmt.Info*, %fmt.Info** %0, align 8
	%123 = getelementptr inbounds %fmt.Info, %fmt.Info* %122, i32 0, i32 2
	%124 = load i8, i8* %123, align 1
	%125 = trunc i8 %124 to i1
	br i1 %125, label %if.then-31, label %if.done-32

if.then-31:
	; AssignStmt
	%126 = load i8, i8* %15, align 1
	%127 = or i8 %126, 4
	store i8 %127, i8* %15
	br label %if.done-32

if.done-32:
	; s
	; SelectorExpr
	; SliceExpr
	%128 = load i64, i64* %14, align 8
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$73, i32 0, i32 0), i64 57}, i64 482, i64 30, i64 %128, i64 256, i64 256)
	%129 = getelementptr inbounds [256 x i8], [256 x i8]* %13, i32 0, i32 0
	%130 = getelementptr inbounds i8, i8* %129, i64 %128
	%131 = sub i64 256, %128
	%132 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %17, i32 0, i32 0
	store i8* %130, i8** %132
	%133 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %17, i32 0, i32 1
	store i64 %131, i64* %133
	%134 = load i64, i64* %1, align 8
	%135 = load i64, i64* %2, align 8
	%136 = load i8, i8* %3, align 1
	%137 = load i64, i64* %4, align 8
	%138 = load %..string, %..string* %5, align 8
	%139 = load i8, i8* %15, align 1
	%140 = trunc i8 %136 to i1
	; ZeroInit
	store %..string zeroinitializer, %..string* %18, align 1
	call void @strconv.append_bits(%..string* %18, {i8*, i64}* %17, i64 %134, i64 %135, i1 %140, i64 %137, %..string %138, i8 %139, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%141 = load %..string, %..string* %18, align 8
	store %..string %141, %..string* %16
	; IfStmt
	; SelectorExpr
	%142 = load %fmt.Info*, %fmt.Info** %0, align 8
	%143 = getelementptr inbounds %fmt.Info, %fmt.Info* %142, i32 0, i32 4
	%144 = load i8, i8* %143, align 1
	%145 = trunc i8 %144 to i1
	br i1 %145, label %cmp.and-33, label %if.done-46

cmp.and-33:
	; SelectorExpr
	%146 = load %fmt.Info*, %fmt.Info** %0, align 8
	%147 = getelementptr inbounds %fmt.Info, %fmt.Info* %146, i32 0, i32 3
	%148 = load i8, i8* %147, align 1
	%149 = trunc i8 %148 to i1
	br i1 %149, label %if.then-34, label %if.done-46

if.then-34:
	; c
	store i8 0, i8* %19
	; SwitchStmt
	%150 = load i64, i64* %2, align 8
	%151 = icmp eq i64 %150, 2
	br i1 %151, label %switch.case.body-36, label %switch.case.next-35

switch.case.next-35:
	%152 = icmp eq i64 %150, 8
	br i1 %152, label %switch.fall.body-38, label %switch.case.next-37

switch.case.body-36:
	; AssignStmt
	store i8 98, i8* %19
	br label %switch.done-43

switch.case.next-37:
	%153 = icmp eq i64 %150, 12
	br i1 %153, label %switch.fall.body-40, label %switch.case.next-39

switch.fall.body-38:
	; AssignStmt
	store i8 111, i8* %19
	br label %switch.done-43

switch.case.next-39:
	%154 = icmp eq i64 %150, 16
	br i1 %154, label %switch.fall.body-42, label %switch.case.next-41

switch.fall.body-40:
	; AssignStmt
	store i8 122, i8* %19
	br label %switch.done-43

switch.case.next-41:
	br label %switch.done-43

switch.fall.body-42:
	; AssignStmt
	store i8 120, i8* %19
	br label %switch.done-43

switch.done-43:
	; IfStmt
	%155 = load i8, i8* %19, align 1
	%156 = icmp ne i8 %155, 0
	%157 = zext i1 %156 to i8
	%158 = trunc i8 %157 to i1
	br i1 %158, label %if.then-44, label %if.done-45

if.then-44:
	; SelectorExpr
	; SelectorExpr
	%159 = load %fmt.Info*, %fmt.Info** %0, align 8
	%160 = getelementptr inbounds %fmt.Info, %fmt.Info* %159, i32 0, i32 12
	%161 = load %strings.Builder*, %strings.Builder** %160, align 8
	call void @strings.write_byte(%strings.Builder* %161, i8 48, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%162 = load %fmt.Info*, %fmt.Info** %0, align 8
	%163 = getelementptr inbounds %fmt.Info, %fmt.Info* %162, i32 0, i32 12
	%164 = load %strings.Builder*, %strings.Builder** %163, align 8
	%165 = load i8, i8* %19, align 1
	call void @strings.write_byte(%strings.Builder* %164, i8 %165, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-45

if.done-45:
	br label %if.done-46

if.done-46:
	; prev_zero
	; SelectorExpr
	%166 = load %fmt.Info*, %fmt.Info** %0, align 8
	%167 = getelementptr inbounds %fmt.Info, %fmt.Info* %166, i32 0, i32 3
	%168 = load i8, i8* %167, align 1
	store i8 %168, i8* %20
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%169 = load %fmt.Info*, %fmt.Info** %0, align 8
	%170 = getelementptr inbounds %fmt.Info, %fmt.Info* %169, i32 0, i32 3
	store i8 0, i8* %170
	%171 = load %fmt.Info*, %fmt.Info** %0, align 8
	%172 = load %..string, %..string* %16, align 8
	call void @fmt._pad(%fmt.Info* %171, %..string %172, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%173 = load %fmt.Info*, %fmt.Info** %0, align 8
	%174 = getelementptr inbounds %fmt.Info, %fmt.Info* %173, i32 0, i32 3
	%175 = load i8, i8* %20, align 1
	store i8 %175, i8* %174
	ret void
}

define void @fmt._fmt_int_128(%fmt.Info* %_.0, <2 x i64> %_.1, i64 %_.2, i1 %_.3, i64 %_.4, %..string %_.5, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i128, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca %..string, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i128, i8}, align 16
	%8 = alloca i64, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca i64, align 16
	%11 = alloca i8, align 16
	%12 = alloca %runtime.Source_Code_Location, align 16
	%13 = alloca [256 x i8], align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca %..string, align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca %..string, align 16
	%19 = alloca i8, align 16
	%20 = alloca i8, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	%21 = bitcast <2 x i64> %_.1 to i128
	store i128 %21, i128* %1
	store i64 %_.2, i64* %2
	%22 = zext i1 %_.3 to i8
	store i8 %22, i8* %3
	store i64 %_.4, i64* %4
	store %..string %_.5, %..string* %5
	; neg
	; SelectorExpr
	%23 = load i128, i128* %1, align 8
	%24 = load i8, i8* %3, align 1
	%25 = load i64, i64* %4, align 8
	%26 = bitcast i128 %23 to <2 x i64>
	%27 = trunc i8 %24 to i1
	%28 = bitcast {i128, i8}* %7 to %..rawptr
	; ZeroInit
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 24)
	call void @strconv.is_integer_negative_128({i128, i8}* %7, <2 x i64> %26, i1 %27, i64 %25, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%30 = load {i128, i8}, {i128, i8}* %7, align 8
	%31 = extractvalue {i128, i8} %30, 1
	store i8 %31, i8* %6
	; IfStmt
	; SelectorExpr
	%32 = load %fmt.Info*, %fmt.Info** %0, align 8
	%33 = getelementptr inbounds %fmt.Info, %fmt.Info* %32, i32 0, i32 5
	%34 = load i8, i8* %33, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%36 = load %fmt.Info*, %fmt.Info** %0, align 8
	%37 = getelementptr inbounds %fmt.Info, %fmt.Info* %36, i32 0, i32 6
	%38 = load i8, i8* %37, align 1
	%39 = trunc i8 %38 to i1
	br i1 %39, label %if.then-2, label %if.done-5

if.then-2:
	; width
	; SelectorExpr
	%40 = load %fmt.Info*, %fmt.Info** %0, align 8
	%41 = getelementptr inbounds %fmt.Info, %fmt.Info* %40, i32 0, i32 7
	%42 = load i64, i64* %41, align 8
	; SelectorExpr
	%43 = load %fmt.Info*, %fmt.Info** %0, align 8
	%44 = getelementptr inbounds %fmt.Info, %fmt.Info* %43, i32 0, i32 8
	%45 = load i64, i64* %44, align 8
	%46 = add i64 %42, %45
	%47 = add i64 %46, 3
	store i64 %47, i64* %8
	; IfStmt
	%48 = load i64, i64* %8, align 8
	%49 = icmp sgt i64 %48, 256
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-3, label %if.done-4

if.then-3:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$74, i32 0, i32 0), i64 57}, i64 512, i64 4, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$75, i32 0, i32 0), i64 12}, i64 9010117293535947639}, %runtime.Source_Code_Location* %9
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([54 x i8], [54 x i8]* @str$76, i32 0, i32 0), i64 53}, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %if.done-4

if.done-4:
	br label %if.done-5

if.done-5:
	; prec
	store i64 0, i64* %10
	; IfStmt
	; SelectorExpr
	%52 = load %fmt.Info*, %fmt.Info** %0, align 8
	%53 = getelementptr inbounds %fmt.Info, %fmt.Info* %52, i32 0, i32 6
	%54 = load i8, i8* %53, align 1
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-6, label %if.else-10

if.then-6:
	; AssignStmt
	; SelectorExpr
	%56 = load %fmt.Info*, %fmt.Info** %0, align 8
	%57 = getelementptr inbounds %fmt.Info, %fmt.Info* %56, i32 0, i32 8
	%58 = load i64, i64* %57, align 8
	store i64 %58, i64* %10
	; IfStmt
	%59 = load i64, i64* %10, align 8
	%60 = icmp eq i64 %59, 0
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %cmp.and-7, label %if.done-9

cmp.and-7:
	%63 = load i128, i128* %1, align 8
	%64 = icmp eq i128 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-8, label %if.done-9

if.then-8:
	; prev_zero
	; SelectorExpr
	%67 = load %fmt.Info*, %fmt.Info** %0, align 8
	%68 = getelementptr inbounds %fmt.Info, %fmt.Info* %67, i32 0, i32 3
	%69 = load i8, i8* %68, align 1
	store i8 %69, i8* %11
	; AssignStmt
	; SelectorExpr
	%70 = load %fmt.Info*, %fmt.Info** %0, align 8
	%71 = getelementptr inbounds %fmt.Info, %fmt.Info* %70, i32 0, i32 3
	store i8 0, i8* %71
	%72 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SelectorExpr
	%73 = load %fmt.Info*, %fmt.Info** %0, align 8
	%74 = getelementptr inbounds %fmt.Info, %fmt.Info* %73, i32 0, i32 7
	%75 = load i64, i64* %74, align 8
	call void @fmt.fmt_write_padding(%fmt.Info* %72, i64 %75, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	; SelectorExpr
	%76 = load %fmt.Info*, %fmt.Info** %0, align 8
	%77 = getelementptr inbounds %fmt.Info, %fmt.Info* %76, i32 0, i32 3
	%78 = load i8, i8* %11, align 1
	store i8 %78, i8* %77
	; ReturnStmt
	ret void

if.done-9:
	br label %if.done-18

if.else-10:
	; IfStmt
	; SelectorExpr
	%79 = load %fmt.Info*, %fmt.Info** %0, align 8
	%80 = getelementptr inbounds %fmt.Info, %fmt.Info* %79, i32 0, i32 3
	%81 = load i8, i8* %80, align 1
	%82 = trunc i8 %81 to i1
	br i1 %82, label %cmp.and-11, label %if.done-17

cmp.and-11:
	; SelectorExpr
	%83 = load %fmt.Info*, %fmt.Info** %0, align 8
	%84 = getelementptr inbounds %fmt.Info, %fmt.Info* %83, i32 0, i32 5
	%85 = load i8, i8* %84, align 1
	%86 = trunc i8 %85 to i1
	br i1 %86, label %if.then-12, label %if.done-17

if.then-12:
	; AssignStmt
	; SelectorExpr
	%87 = load %fmt.Info*, %fmt.Info** %0, align 8
	%88 = getelementptr inbounds %fmt.Info, %fmt.Info* %87, i32 0, i32 7
	%89 = load i64, i64* %88, align 8
	store i64 %89, i64* %10
	; IfStmt
	%90 = load i8, i8* %6, align 1
	%91 = trunc i8 %90 to i1
	br i1 %91, label %if.then-15, label %cmp.or-13

cmp.or-13:
	; SelectorExpr
	%92 = load %fmt.Info*, %fmt.Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Info, %fmt.Info* %92, i32 0, i32 1
	%94 = load i8, i8* %93, align 1
	%95 = trunc i8 %94 to i1
	br i1 %95, label %if.then-15, label %cmp.or-14

cmp.or-14:
	; SelectorExpr
	%96 = load %fmt.Info*, %fmt.Info** %0, align 8
	%97 = getelementptr inbounds %fmt.Info, %fmt.Info* %96, i32 0, i32 2
	%98 = load i8, i8* %97, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.then-15, label %if.done-16

if.then-15:
	; AssignStmt
	%100 = load i64, i64* %10, align 8
	%101 = sub i64 %100, 1
	store i64 %101, i64* %10
	br label %if.done-16

if.done-16:
	br label %if.done-17

if.done-17:
	br label %if.done-18

if.done-18:
	; SwitchStmt
	%102 = load i64, i64* %2, align 8
	%103 = icmp eq i64 %102, 2
	br i1 %103, label %switch.case.body-24, label %switch.case.next-19

switch.case.next-19:
	%104 = icmp eq i64 %102, 8
	br i1 %104, label %switch.case.body-24, label %switch.case.next-20

switch.case.next-20:
	%105 = icmp eq i64 %102, 10
	br i1 %105, label %switch.case.body-24, label %switch.case.next-21

switch.case.next-21:
	%106 = icmp eq i64 %102, 12
	br i1 %106, label %switch.case.body-24, label %switch.case.next-22

switch.case.next-22:
	%107 = icmp eq i64 %102, 16
	br i1 %107, label %switch.case.body-24, label %switch.case.next-23

switch.case.next-23:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$77, i32 0, i32 0), i64 57}, i64 538, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$78, i32 0, i32 0), i64 12}, i64 9010085407698754700}, %runtime.Source_Code_Location* %12
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([31 x i8], [31 x i8]* @str$79, i32 0, i32 0), i64 30}, %runtime.Source_Code_Location* %12, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-25

switch.case.body-24:
	; break
	br label %switch.done-25

switch.done-25:
	; buf
	%108 = bitcast [256 x i8]* %13 to %..rawptr
	; ZeroInit
	%109 = call %..rawptr @mem.zero(%..rawptr %108, i64 256)
	; start
	store i64 0, i64* %14
	; flags
	; ZeroInit
	store i8 zeroinitializer, i8* %15, align 1
	; IfStmt
	; SelectorExpr
	%110 = load %fmt.Info*, %fmt.Info** %0, align 8
	%111 = getelementptr inbounds %fmt.Info, %fmt.Info* %110, i32 0, i32 4
	%112 = load i8, i8* %111, align 1
	%113 = trunc i8 %112 to i1
	br i1 %113, label %cmp.and-26, label %if.done-28

cmp.and-26:
	; SelectorExpr
	%114 = load %fmt.Info*, %fmt.Info** %0, align 8
	%115 = getelementptr inbounds %fmt.Info, %fmt.Info* %114, i32 0, i32 3
	%116 = load i8, i8* %115, align 1
	%117 = trunc i8 %116 to i1
	br i1 %117, label %if.done-28, label %if.then-27

if.then-27:
	; AssignStmt
	%118 = load i8, i8* %15, align 1
	%119 = or i8 %118, 1
	store i8 %119, i8* %15
	br label %if.done-28

if.done-28:
	; IfStmt
	; SelectorExpr
	%120 = load %fmt.Info*, %fmt.Info** %0, align 8
	%121 = getelementptr inbounds %fmt.Info, %fmt.Info* %120, i32 0, i32 1
	%122 = load i8, i8* %121, align 1
	%123 = trunc i8 %122 to i1
	br i1 %123, label %if.then-29, label %if.done-30

if.then-29:
	; AssignStmt
	%124 = load i8, i8* %15, align 1
	%125 = or i8 %124, 2
	store i8 %125, i8* %15
	br label %if.done-30

if.done-30:
	; IfStmt
	; SelectorExpr
	%126 = load %fmt.Info*, %fmt.Info** %0, align 8
	%127 = getelementptr inbounds %fmt.Info, %fmt.Info* %126, i32 0, i32 2
	%128 = load i8, i8* %127, align 1
	%129 = trunc i8 %128 to i1
	br i1 %129, label %if.then-31, label %if.done-32

if.then-31:
	; AssignStmt
	%130 = load i8, i8* %15, align 1
	%131 = or i8 %130, 4
	store i8 %131, i8* %15
	br label %if.done-32

if.done-32:
	; s
	; SelectorExpr
	; SliceExpr
	%132 = load i64, i64* %14, align 8
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$7a, i32 0, i32 0), i64 57}, i64 548, i64 34, i64 %132, i64 256, i64 256)
	%133 = getelementptr inbounds [256 x i8], [256 x i8]* %13, i32 0, i32 0
	%134 = getelementptr inbounds i8, i8* %133, i64 %132
	%135 = sub i64 256, %132
	%136 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %17, i32 0, i32 0
	store i8* %134, i8** %136
	%137 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %17, i32 0, i32 1
	store i64 %135, i64* %137
	%138 = load i128, i128* %1, align 8
	%139 = load i64, i64* %2, align 8
	%140 = load i8, i8* %3, align 1
	%141 = load i64, i64* %4, align 8
	%142 = load %..string, %..string* %5, align 8
	%143 = load i8, i8* %15, align 1
	%144 = bitcast i128 %138 to <2 x i64>
	%145 = trunc i8 %140 to i1
	; ZeroInit
	store %..string zeroinitializer, %..string* %18, align 1
	call void @strconv.append_bits_128(%..string* %18, {i8*, i64}* %17, <2 x i64> %144, i64 %139, i1 %145, i64 %141, %..string %142, i8 %143, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%146 = load %..string, %..string* %18, align 8
	store %..string %146, %..string* %16
	; IfStmt
	; SelectorExpr
	%147 = load %fmt.Info*, %fmt.Info** %0, align 8
	%148 = getelementptr inbounds %fmt.Info, %fmt.Info* %147, i32 0, i32 4
	%149 = load i8, i8* %148, align 1
	%150 = trunc i8 %149 to i1
	br i1 %150, label %cmp.and-33, label %if.done-46

cmp.and-33:
	; SelectorExpr
	%151 = load %fmt.Info*, %fmt.Info** %0, align 8
	%152 = getelementptr inbounds %fmt.Info, %fmt.Info* %151, i32 0, i32 3
	%153 = load i8, i8* %152, align 1
	%154 = trunc i8 %153 to i1
	br i1 %154, label %if.then-34, label %if.done-46

if.then-34:
	; c
	store i8 0, i8* %19
	; SwitchStmt
	%155 = load i64, i64* %2, align 8
	%156 = icmp eq i64 %155, 2
	br i1 %156, label %switch.case.body-36, label %switch.case.next-35

switch.case.next-35:
	%157 = icmp eq i64 %155, 8
	br i1 %157, label %switch.fall.body-38, label %switch.case.next-37

switch.case.body-36:
	; AssignStmt
	store i8 98, i8* %19
	br label %switch.done-43

switch.case.next-37:
	%158 = icmp eq i64 %155, 12
	br i1 %158, label %switch.fall.body-40, label %switch.case.next-39

switch.fall.body-38:
	; AssignStmt
	store i8 111, i8* %19
	br label %switch.done-43

switch.case.next-39:
	%159 = icmp eq i64 %155, 16
	br i1 %159, label %switch.fall.body-42, label %switch.case.next-41

switch.fall.body-40:
	; AssignStmt
	store i8 122, i8* %19
	br label %switch.done-43

switch.case.next-41:
	br label %switch.done-43

switch.fall.body-42:
	; AssignStmt
	store i8 120, i8* %19
	br label %switch.done-43

switch.done-43:
	; IfStmt
	%160 = load i8, i8* %19, align 1
	%161 = icmp ne i8 %160, 0
	%162 = zext i1 %161 to i8
	%163 = trunc i8 %162 to i1
	br i1 %163, label %if.then-44, label %if.done-45

if.then-44:
	; SelectorExpr
	; SelectorExpr
	%164 = load %fmt.Info*, %fmt.Info** %0, align 8
	%165 = getelementptr inbounds %fmt.Info, %fmt.Info* %164, i32 0, i32 12
	%166 = load %strings.Builder*, %strings.Builder** %165, align 8
	call void @strings.write_byte(%strings.Builder* %166, i8 48, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%167 = load %fmt.Info*, %fmt.Info** %0, align 8
	%168 = getelementptr inbounds %fmt.Info, %fmt.Info* %167, i32 0, i32 12
	%169 = load %strings.Builder*, %strings.Builder** %168, align 8
	%170 = load i8, i8* %19, align 1
	call void @strings.write_byte(%strings.Builder* %169, i8 %170, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-45

if.done-45:
	br label %if.done-46

if.done-46:
	; prev_zero
	; SelectorExpr
	%171 = load %fmt.Info*, %fmt.Info** %0, align 8
	%172 = getelementptr inbounds %fmt.Info, %fmt.Info* %171, i32 0, i32 3
	%173 = load i8, i8* %172, align 1
	store i8 %173, i8* %20
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%174 = load %fmt.Info*, %fmt.Info** %0, align 8
	%175 = getelementptr inbounds %fmt.Info, %fmt.Info* %174, i32 0, i32 3
	store i8 0, i8* %175
	%176 = load %fmt.Info*, %fmt.Info** %0, align 8
	%177 = load %..string, %..string* %16, align 8
	call void @fmt._pad(%fmt.Info* %176, %..string %177, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%178 = load %fmt.Info*, %fmt.Info** %0, align 8
	%179 = getelementptr inbounds %fmt.Info, %fmt.Info* %178, i32 0, i32 3
	%180 = load i8, i8* %20, align 1
	store i8 %180, i8* %179
	ret void
}

define void @fmt.fmt_rune(%fmt.Info* %_.0, i32 %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i32, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i32 %_.1, i32* %1
	store i32 %_.2, i32* %2
	; SwitchStmt
	%3 = load i32, i32* %2, align 4
	%4 = icmp eq i32 %3, 99
	br i1 %4, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%5 = icmp eq i32 %3, 114
	br i1 %5, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%6 = icmp eq i32 %3, 118
	br i1 %6, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%7 = load %fmt.Info*, %fmt.Info** %0, align 8
	%8 = load i32, i32* %1, align 4
	%9 = sext i32 %8 to i64
	%10 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %7, i64 %9, i1 false, i64 32, i32 %10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-5

switch.case.body-4:
	; SelectorExpr
	; SelectorExpr
	%11 = load %fmt.Info*, %fmt.Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Info, %fmt.Info* %11, i32 0, i32 12
	%13 = load %strings.Builder*, %strings.Builder** %12, align 8
	%14 = load i32, i32* %1, align 4
	%15 = call i64 @strings.write_rune(%strings.Builder* %13, i32 %14, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-5

switch.done-5:
	ret void
}

define void @fmt.fmt_int(%fmt.Info* %_.0, i64 %_.1, i1 %_.2, i64 %_.3, i32 %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i32, align 16
	%5 = alloca i32, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i64 %_.1, i64* %1
	%6 = zext i1 %_.2 to i8
	store i8 %6, i8* %2
	store i64 %_.3, i64* %3
	store i32 %_.4, i32* %4
	; SwitchStmt
	%7 = load i32, i32* %4, align 4
	%8 = icmp eq i32 %7, 118
	br i1 %8, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 98
	br i1 %9, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%10 = load %fmt.Info*, %fmt.Info** %0, align 8
	%11 = load i64, i64* %1, align 8
	%12 = load i8, i8* %2, align 1
	%13 = load i64, i64* %3, align 8
	%14 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%15 = trunc i8 %12 to i1
	call void @fmt._fmt_int(%fmt.Info* %10, i64 %11, i64 10, i1 %15, i64 %13, %..string %14, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-3:
	%16 = icmp eq i32 %7, 111
	br i1 %16, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%17 = load %fmt.Info*, %fmt.Info** %0, align 8
	%18 = load i64, i64* %1, align 8
	%19 = load i8, i8* %2, align 1
	%20 = load i64, i64* %3, align 8
	%21 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%22 = trunc i8 %19 to i1
	call void @fmt._fmt_int(%fmt.Info* %17, i64 %18, i64 2, i1 %22, i64 %20, %..string %21, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-5:
	%23 = icmp eq i32 %7, 100
	br i1 %23, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%24 = load %fmt.Info*, %fmt.Info** %0, align 8
	%25 = load i64, i64* %1, align 8
	%26 = load i8, i8* %2, align 1
	%27 = load i64, i64* %3, align 8
	%28 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%29 = trunc i8 %26 to i1
	call void @fmt._fmt_int(%fmt.Info* %24, i64 %25, i64 8, i1 %29, i64 %27, %..string %28, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-7:
	%30 = icmp eq i32 %7, 122
	br i1 %30, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%31 = load %fmt.Info*, %fmt.Info** %0, align 8
	%32 = load i64, i64* %1, align 8
	%33 = load i8, i8* %2, align 1
	%34 = load i64, i64* %3, align 8
	%35 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%36 = trunc i8 %33 to i1
	call void @fmt._fmt_int(%fmt.Info* %31, i64 %32, i64 10, i1 %36, i64 %34, %..string %35, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-9:
	%37 = icmp eq i32 %7, 120
	br i1 %37, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%38 = load %fmt.Info*, %fmt.Info** %0, align 8
	%39 = load i64, i64* %1, align 8
	%40 = load i8, i8* %2, align 1
	%41 = load i64, i64* %3, align 8
	%42 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%43 = trunc i8 %40 to i1
	call void @fmt._fmt_int(%fmt.Info* %38, i64 %39, i64 12, i1 %43, i64 %41, %..string %42, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-11:
	%44 = icmp eq i32 %7, 88
	br i1 %44, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%45 = load %fmt.Info*, %fmt.Info** %0, align 8
	%46 = load i64, i64* %1, align 8
	%47 = load i8, i8* %2, align 1
	%48 = load i64, i64* %3, align 8
	%49 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%50 = trunc i8 %47 to i1
	call void @fmt._fmt_int(%fmt.Info* %45, i64 %46, i64 16, i1 %50, i64 %48, %..string %49, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-13:
	%51 = icmp eq i32 %7, 99
	br i1 %51, label %switch.fall.body-17, label %switch.case.next-15

switch.fall.body-14:
	%52 = load %fmt.Info*, %fmt.Info** %0, align 8
	%53 = load i64, i64* %1, align 8
	%54 = load i8, i8* %2, align 1
	%55 = load i64, i64* %3, align 8
	%56 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	%57 = trunc i8 %54 to i1
	call void @fmt._fmt_int(%fmt.Info* %52, i64 %53, i64 16, i1 %57, i64 %55, %..string %56, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-15:
	%58 = icmp eq i32 %7, 114
	br i1 %58, label %switch.fall.body-17, label %switch.case.next-16

switch.case.next-16:
	%59 = icmp eq i32 %7, 85
	br i1 %59, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	%60 = load %fmt.Info*, %fmt.Info** %0, align 8
	%61 = load i64, i64* %1, align 8
	%62 = trunc i64 %61 to i32
	%63 = load i32, i32* %4, align 4
	call void @fmt.fmt_rune(%fmt.Info* %60, i32 %62, i32 %63, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-18:
	%64 = load %fmt.Info*, %fmt.Info** %0, align 8
	%65 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %64, i32 %65, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.fall.body-19:
	; r
	%66 = load i64, i64* %1, align 8
	%67 = trunc i64 %66 to i32
	store i32 %67, i32* %5
	; IfStmt
	%68 = load i32, i32* %5, align 4
	%69 = icmp slt i32 %68, 0
	%70 = zext i1 %69 to i8
	%71 = trunc i8 %70 to i1
	br i1 %71, label %if.then-21, label %cmp.or-20

cmp.or-20:
	%72 = load i32, i32* %5, align 4
	%73 = icmp sgt i32 %72, 1114111
	%74 = zext i1 %73 to i8
	%75 = trunc i8 %74 to i1
	br i1 %75, label %if.then-21, label %if.else-22

if.then-21:
	%76 = load %fmt.Info*, %fmt.Info** %0, align 8
	%77 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %76, i32 %77, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-23

if.else-22:
	; SelectorExpr
	; SelectorExpr
	%78 = load %fmt.Info*, %fmt.Info** %0, align 8
	%79 = getelementptr inbounds %fmt.Info, %fmt.Info* %78, i32 0, i32 12
	%80 = load %strings.Builder*, %strings.Builder** %79, align 8
	call void @strings.write_string(%strings.Builder* %80, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7b, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%81 = load %fmt.Info*, %fmt.Info** %0, align 8
	%82 = load i64, i64* %1, align 8
	%83 = load i64, i64* %3, align 8
	%84 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %81, i64 %82, i64 16, i1 false, i64 %83, %..string %84, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-23

if.done-23:
	br label %switch.done-24

switch.done-24:
	ret void
}

define void @fmt.fmt_int_128(%fmt.Info* %_.0, <2 x i64> %_.1, i1 %_.2, i64 %_.3, i32 %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i128, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca i32, align 16
	%5 = alloca i32, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	%6 = bitcast <2 x i64> %_.1 to i128
	store i128 %6, i128* %1
	%7 = zext i1 %_.2 to i8
	store i8 %7, i8* %2
	store i64 %_.3, i64* %3
	store i32 %_.4, i32* %4
	; SwitchStmt
	%8 = load i32, i32* %4, align 4
	%9 = icmp eq i32 %8, 118
	br i1 %9, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i32 %8, 98
	br i1 %10, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%11 = load %fmt.Info*, %fmt.Info** %0, align 8
	%12 = load i128, i128* %1, align 8
	%13 = load i8, i8* %2, align 1
	%14 = load i64, i64* %3, align 8
	%15 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%16 = bitcast i128 %12 to <2 x i64>
	%17 = trunc i8 %13 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %11, <2 x i64> %16, i64 10, i1 %17, i64 %14, %..string %15, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-3:
	%18 = icmp eq i32 %8, 111
	br i1 %18, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%19 = load %fmt.Info*, %fmt.Info** %0, align 8
	%20 = load i128, i128* %1, align 8
	%21 = load i8, i8* %2, align 1
	%22 = load i64, i64* %3, align 8
	%23 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%24 = bitcast i128 %20 to <2 x i64>
	%25 = trunc i8 %21 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %19, <2 x i64> %24, i64 2, i1 %25, i64 %22, %..string %23, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-5:
	%26 = icmp eq i32 %8, 100
	br i1 %26, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%27 = load %fmt.Info*, %fmt.Info** %0, align 8
	%28 = load i128, i128* %1, align 8
	%29 = load i8, i8* %2, align 1
	%30 = load i64, i64* %3, align 8
	%31 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%32 = bitcast i128 %28 to <2 x i64>
	%33 = trunc i8 %29 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %27, <2 x i64> %32, i64 8, i1 %33, i64 %30, %..string %31, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-7:
	%34 = icmp eq i32 %8, 122
	br i1 %34, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%35 = load %fmt.Info*, %fmt.Info** %0, align 8
	%36 = load i128, i128* %1, align 8
	%37 = load i8, i8* %2, align 1
	%38 = load i64, i64* %3, align 8
	%39 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%40 = bitcast i128 %36 to <2 x i64>
	%41 = trunc i8 %37 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %35, <2 x i64> %40, i64 10, i1 %41, i64 %38, %..string %39, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-9:
	%42 = icmp eq i32 %8, 120
	br i1 %42, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%43 = load %fmt.Info*, %fmt.Info** %0, align 8
	%44 = load i128, i128* %1, align 8
	%45 = load i8, i8* %2, align 1
	%46 = load i64, i64* %3, align 8
	%47 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%48 = bitcast i128 %44 to <2 x i64>
	%49 = trunc i8 %45 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %43, <2 x i64> %48, i64 12, i1 %49, i64 %46, %..string %47, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-11:
	%50 = icmp eq i32 %8, 88
	br i1 %50, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%51 = load %fmt.Info*, %fmt.Info** %0, align 8
	%52 = load i128, i128* %1, align 8
	%53 = load i8, i8* %2, align 1
	%54 = load i64, i64* %3, align 8
	%55 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	%56 = bitcast i128 %52 to <2 x i64>
	%57 = trunc i8 %53 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %51, <2 x i64> %56, i64 16, i1 %57, i64 %54, %..string %55, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-13:
	%58 = icmp eq i32 %8, 99
	br i1 %58, label %switch.fall.body-17, label %switch.case.next-15

switch.fall.body-14:
	%59 = load %fmt.Info*, %fmt.Info** %0, align 8
	%60 = load i128, i128* %1, align 8
	%61 = load i8, i8* %2, align 1
	%62 = load i64, i64* %3, align 8
	%63 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	%64 = bitcast i128 %60 to <2 x i64>
	%65 = trunc i8 %61 to i1
	call void @fmt._fmt_int_128(%fmt.Info* %59, <2 x i64> %64, i64 16, i1 %65, i64 %62, %..string %63, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-15:
	%66 = icmp eq i32 %8, 114
	br i1 %66, label %switch.fall.body-17, label %switch.case.next-16

switch.case.next-16:
	%67 = icmp eq i32 %8, 85
	br i1 %67, label %switch.fall.body-19, label %switch.case.next-18

switch.fall.body-17:
	%68 = load %fmt.Info*, %fmt.Info** %0, align 8
	%69 = load i128, i128* %1, align 8
	%70 = trunc i128 %69 to i32
	%71 = load i32, i32* %4, align 4
	call void @fmt.fmt_rune(%fmt.Info* %68, i32 %70, i32 %71, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-18:
	%72 = load %fmt.Info*, %fmt.Info** %0, align 8
	%73 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %72, i32 %73, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.fall.body-19:
	; r
	%74 = load i128, i128* %1, align 8
	%75 = trunc i128 %74 to i32
	store i32 %75, i32* %5
	; IfStmt
	%76 = load i32, i32* %5, align 4
	%77 = icmp slt i32 %76, 0
	%78 = zext i1 %77 to i8
	%79 = trunc i8 %78 to i1
	br i1 %79, label %if.then-21, label %cmp.or-20

cmp.or-20:
	%80 = load i32, i32* %5, align 4
	%81 = icmp sgt i32 %80, 1114111
	%82 = zext i1 %81 to i8
	%83 = trunc i8 %82 to i1
	br i1 %83, label %if.then-21, label %if.else-22

if.then-21:
	%84 = load %fmt.Info*, %fmt.Info** %0, align 8
	%85 = load i32, i32* %4, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %84, i32 %85, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-23

if.else-22:
	; SelectorExpr
	; SelectorExpr
	%86 = load %fmt.Info*, %fmt.Info** %0, align 8
	%87 = getelementptr inbounds %fmt.Info, %fmt.Info* %86, i32 0, i32 12
	%88 = load %strings.Builder*, %strings.Builder** %87, align 8
	call void @strings.write_string(%strings.Builder* %88, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$7c, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%89 = load %fmt.Info*, %fmt.Info** %0, align 8
	%90 = load i128, i128* %1, align 8
	%91 = load i64, i64* %3, align 8
	%92 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	%93 = bitcast i128 %90 to <2 x i64>
	call void @fmt._fmt_int_128(%fmt.Info* %89, <2 x i64> %93, i64 16, i1 false, i64 %91, %..string %92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-23

if.done-23:
	br label %switch.done-24

switch.done-24:
	ret void
}

define void @fmt._pad(%fmt.Info* %_.0, %..string %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i64, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..string %_.1, %..string* %1
	; IfStmt
	; SelectorExpr
	%3 = load %fmt.Info*, %fmt.Info** %0, align 8
	%4 = getelementptr inbounds %fmt.Info, %fmt.Info* %3, i32 0, i32 5
	%5 = load i8, i8* %4, align 1
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.done-2, label %if.then-1

if.then-1:
	; SelectorExpr
	; SelectorExpr
	%7 = load %fmt.Info*, %fmt.Info** %0, align 8
	%8 = getelementptr inbounds %fmt.Info, %fmt.Info* %7, i32 0, i32 12
	%9 = load %strings.Builder*, %strings.Builder** %8, align 8
	%10 = load %..string, %..string* %1, align 8
	call void @strings.write_string(%strings.Builder* %9, %..string %10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; width
	; SelectorExpr
	%11 = load %fmt.Info*, %fmt.Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Info, %fmt.Info* %11, i32 0, i32 7
	%13 = load i64, i64* %12, align 8
	; SelectorExpr
	%14 = load %..string, %..string* %1, align 8
	%15 = call i64 @utf8.rune_count_in_string(%..string %14, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%16 = sub i64 %13, %15
	store i64 %16, i64* %2
	; IfStmt
	; SelectorExpr
	%17 = load %fmt.Info*, %fmt.Info** %0, align 8
	%18 = getelementptr inbounds %fmt.Info, %fmt.Info* %17, i32 0, i32 0
	%19 = load i8, i8* %18, align 1
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-3, label %if.else-4

if.then-3:
	; SelectorExpr
	; SelectorExpr
	%21 = load %fmt.Info*, %fmt.Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Info, %fmt.Info* %21, i32 0, i32 12
	%23 = load %strings.Builder*, %strings.Builder** %22, align 8
	%24 = load %..string, %..string* %1, align 8
	call void @strings.write_string(%strings.Builder* %23, %..string %24, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%25 = load %fmt.Info*, %fmt.Info** %0, align 8
	%26 = load i64, i64* %2, align 8
	call void @fmt.fmt_write_padding(%fmt.Info* %25, i64 %26, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-5

if.else-4:
	%27 = load %fmt.Info*, %fmt.Info** %0, align 8
	%28 = load i64, i64* %2, align 8
	call void @fmt.fmt_write_padding(%fmt.Info* %27, i64 %28, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%29 = load %fmt.Info*, %fmt.Info** %0, align 8
	%30 = getelementptr inbounds %fmt.Info, %fmt.Info* %29, i32 0, i32 12
	%31 = load %strings.Builder*, %strings.Builder** %30, align 8
	%32 = load %..string, %..string* %1, align 8
	call void @strings.write_string(%strings.Builder* %31, %..string %32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-5

if.done-5:
	ret void
}

define void @fmt.fmt_float(%fmt.Info* %_.0, double %_.1, i64 %_.2, i32 %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca double, align 16
	%2 = alloca i64, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca [386 x i8], align 16
	%6 = alloca %..string, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca %..string, align 16
	%9 = alloca {i8*, i64}, align 16
	%10 = alloca %..string, align 16
	%11 = alloca %..string, align 16
	%12 = alloca %..string, align 16
	%13 = alloca %..string, align 16
	%14 = alloca i64, align 16
	%15 = alloca [386 x i8], align 16
	%16 = alloca %..string, align 16
	%17 = alloca {i8*, i64}, align 16
	%18 = alloca %..string, align 16
	%19 = alloca {i8*, i64}, align 16
	%20 = alloca %..string, align 16
	%21 = alloca %..string, align 16
	%22 = alloca %..string, align 16
	%23 = alloca %..string, align 16
	%24 = alloca %fmt.Info, align 16
	%25 = alloca i64, align 16
	%26 = alloca %runtime.Source_Code_Location, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store double %_.1, double* %1
	store i64 %_.2, i64* %2
	store i32 %_.3, i32* %3
	; SwitchStmt
	%27 = load i32, i32* %3, align 4
	%28 = icmp eq i32 %27, 102
	br i1 %28, label %switch.case.body-4, label %switch.case.next-1

switch.case.next-1:
	%29 = icmp eq i32 %27, 70
	br i1 %29, label %switch.case.body-4, label %switch.case.next-2

switch.case.next-2:
	%30 = icmp eq i32 %27, 118
	br i1 %30, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%31 = icmp eq i32 %27, 101
	br i1 %31, label %switch.fall.body-30, label %switch.case.next-28

switch.case.body-4:
	; prec
	store i64 3, i64* %4
	; IfStmt
	; SelectorExpr
	%32 = load %fmt.Info*, %fmt.Info** %0, align 8
	%33 = getelementptr inbounds %fmt.Info, %fmt.Info* %32, i32 0, i32 6
	%34 = load i8, i8* %33, align 1
	%35 = trunc i8 %34 to i1
	br i1 %35, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%36 = load %fmt.Info*, %fmt.Info** %0, align 8
	%37 = getelementptr inbounds %fmt.Info, %fmt.Info* %36, i32 0, i32 8
	%38 = load i64, i64* %37, align 8
	store i64 %38, i64* %4
	br label %if.done-6

if.done-6:
	; buf
	%39 = bitcast [386 x i8]* %5 to %..rawptr
	; ZeroInit
	%40 = call %..rawptr @mem.zero(%..rawptr %39, i64 386)
	; str
	; SelectorExpr
	; SliceExpr
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$7d, i32 0, i32 0), i64 57}, i64 656, i64 34, i64 1, i64 386, i64 386)
	%41 = getelementptr inbounds [386 x i8], [386 x i8]* %5, i32 0, i32 0
	%42 = getelementptr inbounds i8, i8* %41, i64 1
	%43 = sub i64 386, 1
	%44 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 0
	store i8* %42, i8** %44
	%45 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 1
	store i64 %43, i64* %45
	%46 = load double, double* %1, align 8
	%47 = load i64, i64* %4, align 8
	%48 = load i64, i64* %2, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %8, align 1
	call void @strconv.append_float(%..string* %8, {i8*, i64}* %7, double %46, i8 102, i64 %47, i64 %48, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%49 = load %..string, %..string* %8, align 8
	store %..string %49, %..string* %6
	; AssignStmt
	; SliceExpr
	%50 = load %..string, %..string* %6, align 8
	%51 = extractvalue %..string %50, 1
	%52 = add i64 %51, 1
	call void @runtime.slice_expr_error_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$7e, i32 0, i32 0), i64 57}, i64 657, i64 19, i64 %52, i64 386)
	%53 = getelementptr inbounds [386 x i8], [386 x i8]* %5, i32 0, i32 0
	%54 = getelementptr inbounds i8, i8* %53, i64 0
	%55 = sub i64 %52, 0
	%56 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %9, i32 0, i32 0
	store i8* %54, i8** %56
	%57 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %9, i32 0, i32 1
	store i64 %55, i64* %57
	%58 = load {i8*, i64}, {i8*, i64}* %9, align 8
	%59 = extractvalue {i8*, i64} %58, 0
	%60 = extractvalue {i8*, i64} %58, 1
	%61 = getelementptr inbounds %..string, %..string* %10, i32 0, i32 0
	store i8* %59, i8** %61
	%62 = getelementptr inbounds %..string, %..string* %10, i32 0, i32 1
	store i64 %60, i64* %62
	%63 = load %..string, %..string* %10, align 8
	store %..string %63, %..string* %6
	; IfStmt
	; IndexExpr
	%64 = load %..string, %..string* %6, align 8
	%65 = extractvalue %..string %64, 0
	%66 = extractvalue %..string %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$7f, i32 0, i32 0), i64 57}, i64 658, i64 10, i64 1, i64 %66)
	%67 = getelementptr inbounds i8, i8* %65, i64 1
	%68 = load i8, i8* %67, align 1
	%69 = icmp eq i8 %68, 43
	%70 = zext i1 %69 to i8
	%71 = trunc i8 %70 to i1
	br i1 %71, label %if.then-8, label %cmp.or-7

cmp.or-7:
	; IndexExpr
	%72 = load %..string, %..string* %6, align 8
	%73 = extractvalue %..string %72, 0
	%74 = extractvalue %..string %72, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$80, i32 0, i32 0), i64 57}, i64 658, i64 27, i64 1, i64 %74)
	%75 = getelementptr inbounds i8, i8* %73, i64 1
	%76 = load i8, i8* %75, align 1
	%77 = icmp eq i8 %76, 45
	%78 = zext i1 %77 to i8
	%79 = trunc i8 %78 to i1
	br i1 %79, label %if.then-8, label %if.else-9

if.then-8:
	; AssignStmt
	; SliceExpr
	%80 = load %..string, %..string* %6, align 8
	%81 = extractvalue %..string %80, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$81, i32 0, i32 0), i64 57}, i64 659, i64 13, i64 1, i64 %81, i64 %81)
	%82 = extractvalue %..string %80, 0
	%83 = getelementptr inbounds i8, i8* %82, i64 1
	%84 = sub i64 %81, 1
	%85 = getelementptr inbounds %..string, %..string* %11, i32 0, i32 0
	store i8* %83, i8** %85
	%86 = getelementptr inbounds %..string, %..string* %11, i32 0, i32 1
	store i64 %84, i64* %86
	%87 = load %..string, %..string* %11, align 8
	store %..string %87, %..string* %6
	br label %if.done-10

if.else-9:
	; AssignStmt
	; IndexExpr
	%88 = load %..string, %..string* %6, align 8
	%89 = extractvalue %..string %88, 0
	%90 = extractvalue %..string %88, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$82, i32 0, i32 0), i64 57}, i64 661, i64 8, i64 0, i64 %90)
	%91 = getelementptr inbounds i8, i8* %89, i64 0
	store i8 43, i8* %91
	br label %if.done-10

if.done-10:
	; IfStmt
	; SelectorExpr
	%92 = load %fmt.Info*, %fmt.Info** %0, align 8
	%93 = getelementptr inbounds %fmt.Info, %fmt.Info* %92, i32 0, i32 2
	%94 = load i8, i8* %93, align 1
	%95 = trunc i8 %94 to i1
	br i1 %95, label %cmp.and-11, label %if.done-14

cmp.and-11:
	; SelectorExpr
	%96 = load %fmt.Info*, %fmt.Info** %0, align 8
	%97 = getelementptr inbounds %fmt.Info, %fmt.Info* %96, i32 0, i32 1
	%98 = load i8, i8* %97, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %if.done-14, label %cmp.and-12

cmp.and-12:
	; IndexExpr
	%100 = load %..string, %..string* %6, align 8
	%101 = extractvalue %..string %100, 0
	%102 = extractvalue %..string %100, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$83, i32 0, i32 0), i64 57}, i64 664, i64 34, i64 0, i64 %102)
	%103 = getelementptr inbounds i8, i8* %101, i64 0
	%104 = load i8, i8* %103, align 1
	%105 = icmp eq i8 %104, 43
	%106 = zext i1 %105 to i8
	%107 = trunc i8 %106 to i1
	br i1 %107, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; IndexExpr
	%108 = load %..string, %..string* %6, align 8
	%109 = extractvalue %..string %108, 0
	%110 = extractvalue %..string %108, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$84, i32 0, i32 0), i64 57}, i64 665, i64 8, i64 0, i64 %110)
	%111 = getelementptr inbounds i8, i8* %109, i64 0
	store i8 32, i8* %111
	br label %if.done-14

if.done-14:
	; IfStmt
	%112 = load %..string, %..string* %6, align 8
	%113 = extractvalue %..string %112, 1
	%114 = icmp sgt i64 %113, 1
	%115 = zext i1 %114 to i8
	%116 = trunc i8 %115 to i1
	br i1 %116, label %cmp.and-15, label %if.done-18

cmp.and-15:
	; IndexExpr
	%117 = load %..string, %..string* %6, align 8
	%118 = extractvalue %..string %117, 0
	%119 = extractvalue %..string %117, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$85, i32 0, i32 0), i64 57}, i64 668, i64 27, i64 1, i64 %119)
	%120 = getelementptr inbounds i8, i8* %118, i64 1
	%121 = load i8, i8* %120, align 1
	%122 = icmp eq i8 %121, 78
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-17, label %cmp.or-16

cmp.or-16:
	; IndexExpr
	%125 = load %..string, %..string* %6, align 8
	%126 = extractvalue %..string %125, 0
	%127 = extractvalue %..string %125, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$86, i32 0, i32 0), i64 57}, i64 668, i64 44, i64 1, i64 %127)
	%128 = getelementptr inbounds i8, i8* %126, i64 1
	%129 = load i8, i8* %128, align 1
	%130 = icmp eq i8 %129, 73
	%131 = zext i1 %130 to i8
	%132 = trunc i8 %131 to i1
	br i1 %132, label %if.then-17, label %if.done-18

if.then-17:
	; SelectorExpr
	; SelectorExpr
	%133 = load %fmt.Info*, %fmt.Info** %0, align 8
	%134 = getelementptr inbounds %fmt.Info, %fmt.Info* %133, i32 0, i32 12
	%135 = load %strings.Builder*, %strings.Builder** %134, align 8
	%136 = load %..string, %..string* %6, align 8
	call void @strings.write_string(%strings.Builder* %135, %..string %136, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-18:
	; IfStmt
	; SelectorExpr
	%137 = load %fmt.Info*, %fmt.Info** %0, align 8
	%138 = getelementptr inbounds %fmt.Info, %fmt.Info* %137, i32 0, i32 1
	%139 = load i8, i8* %138, align 1
	%140 = trunc i8 %139 to i1
	br i1 %140, label %if.then-20, label %cmp.or-19

cmp.or-19:
	; IndexExpr
	%141 = load %..string, %..string* %6, align 8
	%142 = extractvalue %..string %141, 0
	%143 = extractvalue %..string %141, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$87, i32 0, i32 0), i64 57}, i64 673, i64 21, i64 0, i64 %143)
	%144 = getelementptr inbounds i8, i8* %142, i64 0
	%145 = load i8, i8* %144, align 1
	%146 = icmp ne i8 %145, 43
	%147 = zext i1 %146 to i8
	%148 = trunc i8 %147 to i1
	br i1 %148, label %if.then-20, label %if.else-26

if.then-20:
	; IfStmt
	; SelectorExpr
	%149 = load %fmt.Info*, %fmt.Info** %0, align 8
	%150 = getelementptr inbounds %fmt.Info, %fmt.Info* %149, i32 0, i32 3
	%151 = load i8, i8* %150, align 1
	%152 = trunc i8 %151 to i1
	br i1 %152, label %cmp.and-21, label %if.else-24

cmp.and-21:
	; SelectorExpr
	%153 = load %fmt.Info*, %fmt.Info** %0, align 8
	%154 = getelementptr inbounds %fmt.Info, %fmt.Info* %153, i32 0, i32 5
	%155 = load i8, i8* %154, align 1
	%156 = trunc i8 %155 to i1
	br i1 %156, label %cmp.and-22, label %if.else-24

cmp.and-22:
	; SelectorExpr
	%157 = load %fmt.Info*, %fmt.Info** %0, align 8
	%158 = getelementptr inbounds %fmt.Info, %fmt.Info* %157, i32 0, i32 7
	%159 = load i64, i64* %158, align 8
	%160 = load %..string, %..string* %6, align 8
	%161 = extractvalue %..string %160, 1
	%162 = icmp sgt i64 %159, %161
	%163 = zext i1 %162 to i8
	%164 = trunc i8 %163 to i1
	br i1 %164, label %if.then-23, label %if.else-24

if.then-23:
	; SelectorExpr
	; SelectorExpr
	%165 = load %fmt.Info*, %fmt.Info** %0, align 8
	%166 = getelementptr inbounds %fmt.Info, %fmt.Info* %165, i32 0, i32 12
	%167 = load %strings.Builder*, %strings.Builder** %166, align 8
	; IndexExpr
	%168 = load %..string, %..string* %6, align 8
	%169 = extractvalue %..string %168, 0
	%170 = extractvalue %..string %168, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$88, i32 0, i32 0), i64 57}, i64 675, i64 36, i64 0, i64 %170)
	%171 = getelementptr inbounds i8, i8* %169, i64 0
	%172 = load i8, i8* %171, align 1
	call void @strings.write_byte(%strings.Builder* %167, i8 %172, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%173 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SelectorExpr
	%174 = load %fmt.Info*, %fmt.Info** %0, align 8
	%175 = getelementptr inbounds %fmt.Info, %fmt.Info* %174, i32 0, i32 7
	%176 = load i64, i64* %175, align 8
	%177 = load %..string, %..string* %6, align 8
	%178 = extractvalue %..string %177, 1
	%179 = sub i64 %176, %178
	call void @fmt.fmt_write_padding(%fmt.Info* %173, i64 %179, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%180 = load %fmt.Info*, %fmt.Info** %0, align 8
	%181 = getelementptr inbounds %fmt.Info, %fmt.Info* %180, i32 0, i32 12
	%182 = load %strings.Builder*, %strings.Builder** %181, align 8
	; SliceExpr
	%183 = load %..string, %..string* %6, align 8
	%184 = extractvalue %..string %183, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$89, i32 0, i32 0), i64 57}, i64 677, i64 37, i64 1, i64 %184, i64 %184)
	%185 = extractvalue %..string %183, 0
	%186 = getelementptr inbounds i8, i8* %185, i64 1
	%187 = sub i64 %184, 1
	%188 = getelementptr inbounds %..string, %..string* %12, i32 0, i32 0
	store i8* %186, i8** %188
	%189 = getelementptr inbounds %..string, %..string* %12, i32 0, i32 1
	store i64 %187, i64* %189
	%190 = load %..string, %..string* %12, align 8
	call void @strings.write_string(%strings.Builder* %182, %..string %190, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-25

if.else-24:
	%191 = load %fmt.Info*, %fmt.Info** %0, align 8
	%192 = load %..string, %..string* %6, align 8
	call void @fmt._pad(%fmt.Info* %191, %..string %192, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-25

if.done-25:
	br label %if.done-27

if.else-26:
	%193 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SliceExpr
	%194 = load %..string, %..string* %6, align 8
	%195 = extractvalue %..string %194, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$8a, i32 0, i32 0), i64 57}, i64 682, i64 16, i64 1, i64 %195, i64 %195)
	%196 = extractvalue %..string %194, 0
	%197 = getelementptr inbounds i8, i8* %196, i64 1
	%198 = sub i64 %195, 1
	%199 = getelementptr inbounds %..string, %..string* %13, i32 0, i32 0
	store i8* %197, i8** %199
	%200 = getelementptr inbounds %..string, %..string* %13, i32 0, i32 1
	store i64 %198, i64* %200
	%201 = load %..string, %..string* %13, align 8
	call void @fmt._pad(%fmt.Info* %193, %..string %201, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-27

if.done-27:
	br label %switch.done-65

switch.case.next-28:
	%202 = icmp eq i32 %27, 69
	br i1 %202, label %switch.fall.body-30, label %switch.case.next-29

switch.case.next-29:
	%203 = icmp eq i32 %27, 104
	br i1 %203, label %switch.fall.body-56, label %switch.case.next-54

switch.fall.body-30:
	; prec
	store i64 3, i64* %14
	; IfStmt
	; SelectorExpr
	%204 = load %fmt.Info*, %fmt.Info** %0, align 8
	%205 = getelementptr inbounds %fmt.Info, %fmt.Info* %204, i32 0, i32 6
	%206 = load i8, i8* %205, align 1
	%207 = trunc i8 %206 to i1
	br i1 %207, label %if.then-31, label %if.done-32

if.then-31:
	; AssignStmt
	; SelectorExpr
	%208 = load %fmt.Info*, %fmt.Info** %0, align 8
	%209 = getelementptr inbounds %fmt.Info, %fmt.Info* %208, i32 0, i32 8
	%210 = load i64, i64* %209, align 8
	store i64 %210, i64* %14
	br label %if.done-32

if.done-32:
	; buf
	%211 = bitcast [386 x i8]* %15 to %..rawptr
	; ZeroInit
	%212 = call %..rawptr @mem.zero(%..rawptr %211, i64 386)
	; str
	; SelectorExpr
	; SliceExpr
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$8b, i32 0, i32 0), i64 57}, i64 690, i64 34, i64 1, i64 386, i64 386)
	%213 = getelementptr inbounds [386 x i8], [386 x i8]* %15, i32 0, i32 0
	%214 = getelementptr inbounds i8, i8* %213, i64 1
	%215 = sub i64 386, 1
	%216 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %17, i32 0, i32 0
	store i8* %214, i8** %216
	%217 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %17, i32 0, i32 1
	store i64 %215, i64* %217
	%218 = load double, double* %1, align 8
	%219 = load i64, i64* %14, align 8
	%220 = load i64, i64* %2, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %18, align 1
	call void @strconv.append_float(%..string* %18, {i8*, i64}* %17, double %218, i8 101, i64 %219, i64 %220, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%221 = load %..string, %..string* %18, align 8
	store %..string %221, %..string* %16
	; AssignStmt
	; SliceExpr
	%222 = load %..string, %..string* %16, align 8
	%223 = extractvalue %..string %222, 1
	%224 = add i64 %223, 1
	call void @runtime.slice_expr_error_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$8c, i32 0, i32 0), i64 57}, i64 691, i64 19, i64 %224, i64 386)
	%225 = getelementptr inbounds [386 x i8], [386 x i8]* %15, i32 0, i32 0
	%226 = getelementptr inbounds i8, i8* %225, i64 0
	%227 = sub i64 %224, 0
	%228 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %19, i32 0, i32 0
	store i8* %226, i8** %228
	%229 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %19, i32 0, i32 1
	store i64 %227, i64* %229
	%230 = load {i8*, i64}, {i8*, i64}* %19, align 8
	%231 = extractvalue {i8*, i64} %230, 0
	%232 = extractvalue {i8*, i64} %230, 1
	%233 = getelementptr inbounds %..string, %..string* %20, i32 0, i32 0
	store i8* %231, i8** %233
	%234 = getelementptr inbounds %..string, %..string* %20, i32 0, i32 1
	store i64 %232, i64* %234
	%235 = load %..string, %..string* %20, align 8
	store %..string %235, %..string* %16
	; IfStmt
	; IndexExpr
	%236 = load %..string, %..string* %16, align 8
	%237 = extractvalue %..string %236, 0
	%238 = extractvalue %..string %236, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$8d, i32 0, i32 0), i64 57}, i64 692, i64 10, i64 1, i64 %238)
	%239 = getelementptr inbounds i8, i8* %237, i64 1
	%240 = load i8, i8* %239, align 1
	%241 = icmp eq i8 %240, 43
	%242 = zext i1 %241 to i8
	%243 = trunc i8 %242 to i1
	br i1 %243, label %if.then-34, label %cmp.or-33

cmp.or-33:
	; IndexExpr
	%244 = load %..string, %..string* %16, align 8
	%245 = extractvalue %..string %244, 0
	%246 = extractvalue %..string %244, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$8e, i32 0, i32 0), i64 57}, i64 692, i64 27, i64 1, i64 %246)
	%247 = getelementptr inbounds i8, i8* %245, i64 1
	%248 = load i8, i8* %247, align 1
	%249 = icmp eq i8 %248, 45
	%250 = zext i1 %249 to i8
	%251 = trunc i8 %250 to i1
	br i1 %251, label %if.then-34, label %if.else-35

if.then-34:
	; AssignStmt
	; SliceExpr
	%252 = load %..string, %..string* %16, align 8
	%253 = extractvalue %..string %252, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$8f, i32 0, i32 0), i64 57}, i64 693, i64 13, i64 1, i64 %253, i64 %253)
	%254 = extractvalue %..string %252, 0
	%255 = getelementptr inbounds i8, i8* %254, i64 1
	%256 = sub i64 %253, 1
	%257 = getelementptr inbounds %..string, %..string* %21, i32 0, i32 0
	store i8* %255, i8** %257
	%258 = getelementptr inbounds %..string, %..string* %21, i32 0, i32 1
	store i64 %256, i64* %258
	%259 = load %..string, %..string* %21, align 8
	store %..string %259, %..string* %16
	br label %if.done-36

if.else-35:
	; AssignStmt
	; IndexExpr
	%260 = load %..string, %..string* %16, align 8
	%261 = extractvalue %..string %260, 0
	%262 = extractvalue %..string %260, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$90, i32 0, i32 0), i64 57}, i64 695, i64 8, i64 0, i64 %262)
	%263 = getelementptr inbounds i8, i8* %261, i64 0
	store i8 43, i8* %263
	br label %if.done-36

if.done-36:
	; IfStmt
	; SelectorExpr
	%264 = load %fmt.Info*, %fmt.Info** %0, align 8
	%265 = getelementptr inbounds %fmt.Info, %fmt.Info* %264, i32 0, i32 2
	%266 = load i8, i8* %265, align 1
	%267 = trunc i8 %266 to i1
	br i1 %267, label %cmp.and-37, label %if.done-40

cmp.and-37:
	; SelectorExpr
	%268 = load %fmt.Info*, %fmt.Info** %0, align 8
	%269 = getelementptr inbounds %fmt.Info, %fmt.Info* %268, i32 0, i32 1
	%270 = load i8, i8* %269, align 1
	%271 = trunc i8 %270 to i1
	br i1 %271, label %if.done-40, label %cmp.and-38

cmp.and-38:
	; IndexExpr
	%272 = load %..string, %..string* %16, align 8
	%273 = extractvalue %..string %272, 0
	%274 = extractvalue %..string %272, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$91, i32 0, i32 0), i64 57}, i64 698, i64 34, i64 0, i64 %274)
	%275 = getelementptr inbounds i8, i8* %273, i64 0
	%276 = load i8, i8* %275, align 1
	%277 = icmp eq i8 %276, 43
	%278 = zext i1 %277 to i8
	%279 = trunc i8 %278 to i1
	br i1 %279, label %if.then-39, label %if.done-40

if.then-39:
	; AssignStmt
	; IndexExpr
	%280 = load %..string, %..string* %16, align 8
	%281 = extractvalue %..string %280, 0
	%282 = extractvalue %..string %280, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$92, i32 0, i32 0), i64 57}, i64 699, i64 8, i64 0, i64 %282)
	%283 = getelementptr inbounds i8, i8* %281, i64 0
	store i8 32, i8* %283
	br label %if.done-40

if.done-40:
	; IfStmt
	%284 = load %..string, %..string* %16, align 8
	%285 = extractvalue %..string %284, 1
	%286 = icmp sgt i64 %285, 1
	%287 = zext i1 %286 to i8
	%288 = trunc i8 %287 to i1
	br i1 %288, label %cmp.and-41, label %if.done-44

cmp.and-41:
	; IndexExpr
	%289 = load %..string, %..string* %16, align 8
	%290 = extractvalue %..string %289, 0
	%291 = extractvalue %..string %289, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$93, i32 0, i32 0), i64 57}, i64 702, i64 27, i64 1, i64 %291)
	%292 = getelementptr inbounds i8, i8* %290, i64 1
	%293 = load i8, i8* %292, align 1
	%294 = icmp eq i8 %293, 78
	%295 = zext i1 %294 to i8
	%296 = trunc i8 %295 to i1
	br i1 %296, label %if.then-43, label %cmp.or-42

cmp.or-42:
	; IndexExpr
	%297 = load %..string, %..string* %16, align 8
	%298 = extractvalue %..string %297, 0
	%299 = extractvalue %..string %297, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$94, i32 0, i32 0), i64 57}, i64 702, i64 44, i64 1, i64 %299)
	%300 = getelementptr inbounds i8, i8* %298, i64 1
	%301 = load i8, i8* %300, align 1
	%302 = icmp eq i8 %301, 73
	%303 = zext i1 %302 to i8
	%304 = trunc i8 %303 to i1
	br i1 %304, label %if.then-43, label %if.done-44

if.then-43:
	; SelectorExpr
	; SelectorExpr
	%305 = load %fmt.Info*, %fmt.Info** %0, align 8
	%306 = getelementptr inbounds %fmt.Info, %fmt.Info* %305, i32 0, i32 12
	%307 = load %strings.Builder*, %strings.Builder** %306, align 8
	%308 = load %..string, %..string* %16, align 8
	call void @strings.write_string(%strings.Builder* %307, %..string %308, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-44:
	; IfStmt
	; SelectorExpr
	%309 = load %fmt.Info*, %fmt.Info** %0, align 8
	%310 = getelementptr inbounds %fmt.Info, %fmt.Info* %309, i32 0, i32 1
	%311 = load i8, i8* %310, align 1
	%312 = trunc i8 %311 to i1
	br i1 %312, label %if.then-46, label %cmp.or-45

cmp.or-45:
	; IndexExpr
	%313 = load %..string, %..string* %16, align 8
	%314 = extractvalue %..string %313, 0
	%315 = extractvalue %..string %313, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$95, i32 0, i32 0), i64 57}, i64 707, i64 21, i64 0, i64 %315)
	%316 = getelementptr inbounds i8, i8* %314, i64 0
	%317 = load i8, i8* %316, align 1
	%318 = icmp ne i8 %317, 43
	%319 = zext i1 %318 to i8
	%320 = trunc i8 %319 to i1
	br i1 %320, label %if.then-46, label %if.else-52

if.then-46:
	; IfStmt
	; SelectorExpr
	%321 = load %fmt.Info*, %fmt.Info** %0, align 8
	%322 = getelementptr inbounds %fmt.Info, %fmt.Info* %321, i32 0, i32 3
	%323 = load i8, i8* %322, align 1
	%324 = trunc i8 %323 to i1
	br i1 %324, label %cmp.and-47, label %if.else-50

cmp.and-47:
	; SelectorExpr
	%325 = load %fmt.Info*, %fmt.Info** %0, align 8
	%326 = getelementptr inbounds %fmt.Info, %fmt.Info* %325, i32 0, i32 5
	%327 = load i8, i8* %326, align 1
	%328 = trunc i8 %327 to i1
	br i1 %328, label %cmp.and-48, label %if.else-50

cmp.and-48:
	; SelectorExpr
	%329 = load %fmt.Info*, %fmt.Info** %0, align 8
	%330 = getelementptr inbounds %fmt.Info, %fmt.Info* %329, i32 0, i32 7
	%331 = load i64, i64* %330, align 8
	%332 = load %..string, %..string* %16, align 8
	%333 = extractvalue %..string %332, 1
	%334 = icmp sgt i64 %331, %333
	%335 = zext i1 %334 to i8
	%336 = trunc i8 %335 to i1
	br i1 %336, label %if.then-49, label %if.else-50

if.then-49:
	; SelectorExpr
	; SelectorExpr
	%337 = load %fmt.Info*, %fmt.Info** %0, align 8
	%338 = getelementptr inbounds %fmt.Info, %fmt.Info* %337, i32 0, i32 12
	%339 = load %strings.Builder*, %strings.Builder** %338, align 8
	; IndexExpr
	%340 = load %..string, %..string* %16, align 8
	%341 = extractvalue %..string %340, 0
	%342 = extractvalue %..string %340, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$96, i32 0, i32 0), i64 57}, i64 709, i64 36, i64 0, i64 %342)
	%343 = getelementptr inbounds i8, i8* %341, i64 0
	%344 = load i8, i8* %343, align 1
	call void @strings.write_byte(%strings.Builder* %339, i8 %344, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%345 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SelectorExpr
	%346 = load %fmt.Info*, %fmt.Info** %0, align 8
	%347 = getelementptr inbounds %fmt.Info, %fmt.Info* %346, i32 0, i32 7
	%348 = load i64, i64* %347, align 8
	%349 = load %..string, %..string* %16, align 8
	%350 = extractvalue %..string %349, 1
	%351 = sub i64 %348, %350
	call void @fmt.fmt_write_padding(%fmt.Info* %345, i64 %351, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%352 = load %fmt.Info*, %fmt.Info** %0, align 8
	%353 = getelementptr inbounds %fmt.Info, %fmt.Info* %352, i32 0, i32 12
	%354 = load %strings.Builder*, %strings.Builder** %353, align 8
	; SliceExpr
	%355 = load %..string, %..string* %16, align 8
	%356 = extractvalue %..string %355, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$97, i32 0, i32 0), i64 57}, i64 711, i64 37, i64 1, i64 %356, i64 %356)
	%357 = extractvalue %..string %355, 0
	%358 = getelementptr inbounds i8, i8* %357, i64 1
	%359 = sub i64 %356, 1
	%360 = getelementptr inbounds %..string, %..string* %22, i32 0, i32 0
	store i8* %358, i8** %360
	%361 = getelementptr inbounds %..string, %..string* %22, i32 0, i32 1
	store i64 %359, i64* %361
	%362 = load %..string, %..string* %22, align 8
	call void @strings.write_string(%strings.Builder* %354, %..string %362, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-51

if.else-50:
	%363 = load %fmt.Info*, %fmt.Info** %0, align 8
	%364 = load %..string, %..string* %16, align 8
	call void @fmt._pad(%fmt.Info* %363, %..string %364, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-51

if.done-51:
	br label %if.done-53

if.else-52:
	%365 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SliceExpr
	%366 = load %..string, %..string* %16, align 8
	%367 = extractvalue %..string %366, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$98, i32 0, i32 0), i64 57}, i64 716, i64 16, i64 1, i64 %367, i64 %367)
	%368 = extractvalue %..string %366, 0
	%369 = getelementptr inbounds i8, i8* %368, i64 1
	%370 = sub i64 %367, 1
	%371 = getelementptr inbounds %..string, %..string* %23, i32 0, i32 0
	store i8* %369, i8** %371
	%372 = getelementptr inbounds %..string, %..string* %23, i32 0, i32 1
	store i64 %370, i64* %372
	%373 = load %..string, %..string* %23, align 8
	call void @fmt._pad(%fmt.Info* %365, %..string %373, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-53

if.done-53:
	br label %switch.done-65

switch.case.next-54:
	%374 = icmp eq i32 %27, 72
	br i1 %374, label %switch.fall.body-56, label %switch.case.next-55

switch.case.next-55:
	%375 = load %fmt.Info*, %fmt.Info** %0, align 8
	%376 = load i32, i32* %3, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %375, i32 %376, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-65

switch.fall.body-56:
	; prev_fi
	%377 = load %fmt.Info*, %fmt.Info** %0, align 8
	%378 = getelementptr inbounds %fmt.Info, %fmt.Info* %377, i64 0
	%379 = load %fmt.Info, %fmt.Info* %378, align 8
	store %fmt.Info %379, %fmt.Info* %24
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%380 = load %fmt.Info*, %fmt.Info** %0, align 8
	%381 = getelementptr inbounds %fmt.Info, %fmt.Info* %380, i32 0, i32 4
	store i8 0, i8* %381
	; AssignStmt
	; SelectorExpr
	%382 = load %fmt.Info*, %fmt.Info** %0, align 8
	%383 = getelementptr inbounds %fmt.Info, %fmt.Info* %382, i32 0, i32 7
	%384 = load i64, i64* %2, align 8
	store i64 %384, i64* %383
	; AssignStmt
	; SelectorExpr
	%385 = load %fmt.Info*, %fmt.Info** %0, align 8
	%386 = getelementptr inbounds %fmt.Info, %fmt.Info* %385, i32 0, i32 3
	store i8 1, i8* %386
	; AssignStmt
	; SelectorExpr
	%387 = load %fmt.Info*, %fmt.Info** %0, align 8
	%388 = getelementptr inbounds %fmt.Info, %fmt.Info* %387, i32 0, i32 1
	store i8 0, i8* %388
	; u
	; ZeroInit
	store i64 zeroinitializer, i64* %25, align 1
	; SwitchStmt
	%389 = load i64, i64* %2, align 8
	%390 = icmp eq i64 %389, 32
	br i1 %390, label %switch.case.body-58, label %switch.case.next-57

switch.case.next-57:
	%391 = icmp eq i64 %389, 64
	br i1 %391, label %switch.fall.body-60, label %switch.case.next-59

switch.case.body-58:
	; AssignStmt
	%392 = load double, double* %1, align 8
	%393 = fptrunc double %392 to float
	%394 = bitcast float %393 to i32
	%395 = zext i32 %394 to i64
	store i64 %395, i64* %25
	br label %switch.done-61

switch.case.next-59:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$99, i32 0, i32 0), i64 57}, i64 731, i64 9, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$9a, i32 0, i32 0), i64 9}, i64 9010167871071313617}, %runtime.Source_Code_Location* %26
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$9b, i32 0, i32 0), i64 20}, %runtime.Source_Code_Location* %26, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-61

switch.fall.body-60:
	; AssignStmt
	%396 = load double, double* %1, align 8
	%397 = bitcast double %396 to i64
	store i64 %397, i64* %25
	br label %switch.done-61

switch.done-61:
	; SelectorExpr
	; SelectorExpr
	%398 = load %fmt.Info*, %fmt.Info** %0, align 8
	%399 = getelementptr inbounds %fmt.Info, %fmt.Info* %398, i32 0, i32 12
	%400 = load %strings.Builder*, %strings.Builder** %399, align 8
	call void @strings.write_string(%strings.Builder* %400, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$9c, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%401 = load %fmt.Info*, %fmt.Info** %0, align 8
	%402 = load i64, i64* %25, align 8
	%403 = load i64, i64* %2, align 8
	; TernaryExpr
	%404 = load i32, i32* %3, align 4
	%405 = icmp eq i32 %404, 104
	%406 = zext i1 %405 to i8
	%407 = trunc i8 %406 to i1
	br i1 %407, label %if.then-62, label %if.else-63

if.then-62:
	%408 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	br label %if.done-64

if.else-63:
	%409 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	br label %if.done-64

if.done-64:
	%410 = phi %..string [ %408, %if.then-62 ], [ %409, %if.else-63 ]
	call void @fmt._fmt_int(%fmt.Info* %401, i64 %402, i64 16, i1 false, i64 %403, %..string %410, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; defer
	; AssignStmt
	%411 = load %fmt.Info*, %fmt.Info** %0, align 8
	%412 = getelementptr inbounds %fmt.Info, %fmt.Info* %411, i64 0
	%413 = load %fmt.Info, %fmt.Info* %24, align 8
	store %fmt.Info %413, %fmt.Info* %412
	br label %switch.done-65

switch.done-65:
	ret void
}

define void @fmt.fmt_string(%fmt.Info* %_.0, %..string %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i32, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %..string, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..string %_.1, %..string* %1
	store i32 %_.2, i32* %2
	; SwitchStmt
	%8 = load i32, i32* %2, align 4
	%9 = icmp eq i32 %8, 115
	br i1 %9, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%10 = icmp eq i32 %8, 118
	br i1 %10, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%11 = icmp eq i32 %8, 113
	br i1 %11, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; SelectorExpr
	; SelectorExpr
	%12 = load %fmt.Info*, %fmt.Info** %0, align 8
	%13 = getelementptr inbounds %fmt.Info, %fmt.Info* %12, i32 0, i32 12
	%14 = load %strings.Builder*, %strings.Builder** %13, align 8
	%15 = load %..string, %..string* %1, align 8
	call void @strings.write_string(%strings.Builder* %14, %..string %15, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-4:
	%16 = icmp eq i32 %8, 120
	br i1 %16, label %switch.fall.body-8, label %switch.case.next-6

switch.fall.body-5:
	; SelectorExpr
	; SelectorExpr
	%17 = load %fmt.Info*, %fmt.Info** %0, align 8
	%18 = getelementptr inbounds %fmt.Info, %fmt.Info* %17, i32 0, i32 12
	%19 = load %strings.Builder*, %strings.Builder** %18, align 8
	%20 = load %..string, %..string* %1, align 8
	call void @strings.write_quoted_string(%strings.Builder* %19, %..string %20, i8 34, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-6:
	%21 = icmp eq i32 %8, 88
	br i1 %21, label %switch.fall.body-8, label %switch.case.next-7

switch.case.next-7:
	%22 = load %fmt.Info*, %fmt.Info** %0, align 8
	%23 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %22, i32 %23, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.fall.body-8:
	; space
	; SelectorExpr
	%24 = load %fmt.Info*, %fmt.Info** %0, align 8
	%25 = getelementptr inbounds %fmt.Info, %fmt.Info* %24, i32 0, i32 2
	%26 = load i8, i8* %25, align 1
	store i8 %26, i8* %3
	; AssignStmt
	; SelectorExpr
	%27 = load %fmt.Info*, %fmt.Info** %0, align 8
	%28 = getelementptr inbounds %fmt.Info, %fmt.Info* %27, i32 0, i32 2
	store i8 0, i8* %28
	; DeferStmt
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %4, align 1
	store i64 0, i64* %5
	store i64 0, i64* %6
	br label %for.interval.loop-9

for.interval.loop-9:
	%29 = load %..string, %..string* %1, align 8
	%30 = extractvalue %..string %29, 1
	%31 = load i64, i64* %5, align 8
	%32 = icmp slt i64 %31, %30
	br i1 %32, label %for.interval.body-10, label %for.interval.done-16

for.interval.body-10:
	%33 = load i64, i64* %5, align 8
	%34 = load i64, i64* %5, align 8
	%35 = add i64 %34, 1
	store i64 %35, i64* %5
	%36 = load i64, i64* %6, align 8
	%37 = add i64 %36, 1
	store i64 %37, i64* %6
	store i64 %33, i64* %4
	; IfStmt
	%38 = load i64, i64* %4, align 8
	%39 = icmp sgt i64 %38, 0
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %cmp.and-11, label %if.done-13

cmp.and-11:
	%42 = load i8, i8* %3, align 1
	%43 = trunc i8 %42 to i1
	br i1 %43, label %if.then-12, label %if.done-13

if.then-12:
	; SelectorExpr
	; SelectorExpr
	%44 = load %fmt.Info*, %fmt.Info** %0, align 8
	%45 = getelementptr inbounds %fmt.Info, %fmt.Info* %44, i32 0, i32 12
	%46 = load %strings.Builder*, %strings.Builder** %45, align 8
	call void @strings.write_byte(%strings.Builder* %46, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-13

if.done-13:
	; char_set
	%47 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	store %..string %47, %..string* %7
	; IfStmt
	%48 = load i32, i32* %2, align 4
	%49 = icmp eq i32 %48, 120
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-14, label %if.done-15

if.then-14:
	; AssignStmt
	%52 = load %..string, %..string* @fmt.__DIGITS_LOWER, align 8
	store %..string %52, %..string* %7
	br label %if.done-15

if.done-15:
	%53 = load %fmt.Info*, %fmt.Info** %0, align 8
	; IndexExpr
	%54 = load %..string, %..string* %1, align 8
	%55 = extractvalue %..string %54, 0
	%56 = extractvalue %..string %54, 1
	%57 = load i64, i64* %4, align 8
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$9d, i32 0, i32 0), i64 57}, i64 761, i64 23, i64 %57, i64 %56)
	%58 = getelementptr inbounds i8, i8* %55, i64 %57
	%59 = load i8, i8* %58, align 1
	%60 = zext i8 %59 to i64
	%61 = load %..string, %..string* %7, align 8
	call void @fmt._fmt_int(%fmt.Info* %53, i64 %60, i64 16, i1 false, i64 8, %..string %61, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-9

for.interval.done-16:
	; defer
	; AssignStmt
	; SelectorExpr
	%62 = load %fmt.Info*, %fmt.Info** %0, align 8
	%63 = getelementptr inbounds %fmt.Info, %fmt.Info* %62, i32 0, i32 2
	%64 = load i8, i8* %3, align 1
	store i8 %64, i8* %63
	br label %switch.done-17

switch.done-17:
	ret void
}

define void @fmt.fmt_cstring(%fmt.Info* %_.0, i8* %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i8*, align 16
	%2 = alloca i32, align 16
	%3 = alloca %..string, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i8* %_.1, i8** %1
	store i32 %_.2, i32* %2
	%4 = load %fmt.Info*, %fmt.Info** %0, align 8
	%5 = load i8*, i8** %1, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %3, align 1
	call void @runtime.cstring_to_string(%..string* %3, i8* %5)
	%6 = load %..string, %..string* %3, align 8
	%7 = load i32, i32* %2, align 4
	call void @fmt.fmt_string(%fmt.Info* %4, %..string %6, i32 %7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @fmt.fmt_pointer(%fmt.Info* %_.0, %..rawptr %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i32, align 16
	%3 = alloca i64, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..rawptr %_.1, %..rawptr* %1
	store i32 %_.2, i32* %2
	; u
	%4 = load %..rawptr, %..rawptr* %1, align 8
	%5 = ptrtoint %..rawptr %4 to i64
	%6 = bitcast i64 %5 to i64
	store i64 %6, i64* %3
	; SwitchStmt
	%7 = load i32, i32* %2, align 4
	%8 = icmp eq i32 %7, 112
	br i1 %8, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 118
	br i1 %9, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%10 = icmp eq i32 %7, 98
	br i1 %10, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-3:
	; IfStmt
	; SelectorExpr
	%11 = load %fmt.Info*, %fmt.Info** %0, align 8
	%12 = getelementptr inbounds %fmt.Info, %fmt.Info* %11, i32 0, i32 4
	%13 = load i8, i8* %12, align 1
	%14 = trunc i8 %13 to i1
	br i1 %14, label %cmp.or-4, label %if.then-5

cmp.or-4:
	%15 = load i32, i32* %2, align 4
	%16 = icmp eq i32 %15, 118
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-5, label %if.done-6

if.then-5:
	; SelectorExpr
	; SelectorExpr
	%19 = load %fmt.Info*, %fmt.Info** %0, align 8
	%20 = getelementptr inbounds %fmt.Info, %fmt.Info* %19, i32 0, i32 12
	%21 = load %strings.Builder*, %strings.Builder** %20, align 8
	call void @strings.write_string(%strings.Builder* %21, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$9e, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-6

if.done-6:
	%22 = load %fmt.Info*, %fmt.Info** %0, align 8
	%23 = load i64, i64* %3, align 8
	%24 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %22, i64 %23, i64 16, i1 false, i64 64, %..string %24, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-7:
	%25 = icmp eq i32 %7, 111
	br i1 %25, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%26 = load %fmt.Info*, %fmt.Info** %0, align 8
	%27 = load i64, i64* %3, align 8
	%28 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %26, i64 %27, i64 2, i1 false, i64 64, %..string %28, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-9:
	%29 = icmp eq i32 %7, 100
	br i1 %29, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%30 = load %fmt.Info*, %fmt.Info** %0, align 8
	%31 = load i64, i64* %3, align 8
	%32 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %30, i64 %31, i64 8, i1 false, i64 64, %..string %32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-11:
	%33 = icmp eq i32 %7, 120
	br i1 %33, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%34 = load %fmt.Info*, %fmt.Info** %0, align 8
	%35 = load i64, i64* %3, align 8
	%36 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %34, i64 %35, i64 10, i1 false, i64 64, %..string %36, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-13:
	%37 = icmp eq i32 %7, 88
	br i1 %37, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%38 = load %fmt.Info*, %fmt.Info** %0, align 8
	%39 = load i64, i64* %3, align 8
	%40 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %38, i64 %39, i64 16, i1 false, i64 64, %..string %40, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.case.next-15:
	%41 = load %fmt.Info*, %fmt.Info** %0, align 8
	%42 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %41, i32 %42, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.fall.body-16:
	%43 = load %fmt.Info*, %fmt.Info** %0, align 8
	%44 = load i64, i64* %3, align 8
	%45 = load %..string, %..string* @fmt.__DIGITS_UPPER, align 8
	call void @fmt._fmt_int(%fmt.Info* %43, i64 %44, i64 16, i1 false, i64 64, %..string %45, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-17

switch.done-17:
	ret void
}

define void @fmt.enum_value_to_string({%..string, i8}* sret noalias %agg.result, %..any %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..any, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca %runtime.Type_Info_Enum, align 16
	%4 = alloca %..any, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info*, align 16
	%7 = alloca i32, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca i8, align 16
	%11 = alloca {%..string, i8}, align 16
	%12 = alloca {%..string, i8}, align 16
	%13 = alloca i16, align 16
	%14 = alloca {%..string, i8}, align 16
	%15 = alloca {%..string, i8}, align 16
	%16 = alloca i32, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	%19 = alloca i64, align 16
	%20 = alloca {%..string, i8}, align 16
	%21 = alloca {%..string, i8}, align 16
	%22 = alloca i64, align 16
	%23 = alloca {%..string, i8}, align 16
	%24 = alloca {%..string, i8}, align 16
	%25 = alloca i8, align 16
	%26 = alloca {%..string, i8}, align 16
	%27 = alloca {%..string, i8}, align 16
	%28 = alloca i16, align 16
	%29 = alloca {%..string, i8}, align 16
	%30 = alloca {%..string, i8}, align 16
	%31 = alloca i32, align 16
	%32 = alloca {%..string, i8}, align 16
	%33 = alloca {%..string, i8}, align 16
	%34 = alloca i64, align 16
	%35 = alloca {%..string, i8}, align 16
	%36 = alloca {%..string, i8}, align 16
	%37 = alloca i64, align 16
	%38 = alloca {%..string, i8}, align 16
	%39 = alloca {%..string, i8}, align 16
	%40 = alloca i64, align 16
	%41 = alloca {%..string, i8}, align 16
	%42 = alloca {%..string, i8}, align 16
	%43 = alloca {[0 x i64], [88 x i8], i64}, align 16
	%44 = alloca {%..string, i8}, align 16
	%45 = alloca {%..string, i8}, align 16
	store %..any %_.0, %..any* %0
	; v
	%46 = load %..any, %..any* %0, align 8
	store %..any %46, %..any* %1
	; AssignStmt
	; SelectorExpr
	%47 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%48 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%49 = load %..typeid, %..typeid* %48, align 8
	%50 = call %..typeid @runtime.typeid_base(%..typeid %49)
	store %..typeid %50, %..typeid* %47
	; type_info
	; SelectorExpr
	%51 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%52 = load %..typeid, %..typeid* %51, align 8
	%53 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %52)
	store %runtime.Type_Info* %53, %runtime.Type_Info** %2
	; TypeSwitchStmt
	; SelectorExpr
	%54 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%55 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %54, i32 0, i32 3
	%56 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %55, align 8
	; get union's tag
	%57 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %55, i64 0, i32 2 ; UnionTagPtr
	%58 = load i64, i64* %57, align 8
	%59 = bitcast {[0 x i64], [88 x i8], i64}* %55 to %..rawptr
	%60 = icmp eq i64 %58, 19
	br i1 %60, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	store {[0 x i64], [88 x i8], i64} %56, {[0 x i64], [88 x i8], i64}* %43
	; ReturnStmt
	%61 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %44, i32 0, i32 0
	store %..string zeroinitializer, %..string* %61
	%62 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %44, i32 0, i32 1
	store i8 0, i8* %62
	%63 = load {%..string, i8}, {%..string, i8}* %44, align 8
	store {%..string, i8} %63, {%..string, i8}* %agg.result
	ret void

typeswitch.body-2:
	%64 = bitcast %..rawptr %59 to %runtime.Type_Info_Enum*
	%65 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %64, align 8
	store %runtime.Type_Info_Enum %65, %runtime.Type_Info_Enum* %3
	; a
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %5, align 1
	store %..any zeroinitializer, %..any* %5
	; SelectorExpr
	%66 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = getelementptr inbounds %..any, %..any* %5, i32 0, i32 0
	store %..rawptr %67, %..rawptr* %68
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%69 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %3, i32 0, i32 0
	%70 = load %runtime.Type_Info*, %runtime.Type_Info** %69, align 8
	%71 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %70)
	store %runtime.Type_Info* %71, %runtime.Type_Info** %6
	%72 = load %runtime.Type_Info*, %runtime.Type_Info** %6, align 8
	%73 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %72, i32 0, i32 2
	%74 = load %..typeid, %..typeid* %73, align 8
	%75 = getelementptr inbounds %..any, %..any* %5, i32 0, i32 1
	store %..typeid %74, %..typeid* %75
	%76 = load %..any, %..any* %5, align 8
	store %..any %76, %..any* %4
	; TypeSwitchStmt
	%77 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%78 = load %..typeid, %..typeid* %77, align 8
	%79 = icmp eq %..typeid %78, 4755801206503243840
	br i1 %79, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%80 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%81 = load %..typeid, %..typeid* %80, align 8
	%82 = icmp eq %..typeid %81, 4683743612465315905
	br i1 %82, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%83 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%84 = load %..rawptr, %..rawptr* %83, align 8
	%85 = bitcast %..rawptr %84 to i32*
	%86 = load i32, i32* %85, align 4
	store i32 %86, i32* %7
	; ReturnStmt
	%87 = load i32, i32* %7, align 4
	%88 = bitcast {%..string, i8}* %8 to %..rawptr
	; ZeroInit
	%89 = call %..rawptr @mem.zero(%..rawptr %88, i64 24)
	call void @fmt.enum_value_to_string.get_str-0({%..string, i8}* %8, i32 %87, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%90 = load {%..string, i8}, {%..string, i8}* %8, align 8
	%91 = extractvalue {%..string, i8} %90, 0
	%92 = extractvalue {%..string, i8} %90, 1
	%93 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string %91, %..string* %93
	%94 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 %92, i8* %94
	%95 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %95, {%..string, i8}* %agg.result
	ret void

typeswitch.next-5:
	%96 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%97 = load %..typeid, %..typeid* %96, align 8
	%98 = icmp eq %..typeid %97, 4683743612465315906
	br i1 %98, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.body-6:
	%99 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%100 = load %..rawptr, %..rawptr* %99, align 8
	%101 = bitcast %..rawptr %100 to i8*
	%102 = load i8, i8* %101, align 1
	store i8 %102, i8* %10
	; ReturnStmt
	%103 = load i8, i8* %10, align 1
	%104 = bitcast {%..string, i8}* %11 to %..rawptr
	; ZeroInit
	%105 = call %..rawptr @mem.zero(%..rawptr %104, i64 24)
	call void @fmt.enum_value_to_string.get_str-1({%..string, i8}* %11, i8 %103, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%106 = load {%..string, i8}, {%..string, i8}* %11, align 8
	%107 = extractvalue {%..string, i8} %106, 0
	%108 = extractvalue {%..string, i8} %106, 1
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %12, i32 0, i32 0
	store %..string %107, %..string* %109
	%110 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %12, i32 0, i32 1
	store i8 %108, i8* %110
	%111 = load {%..string, i8}, {%..string, i8}* %12, align 8
	store {%..string, i8} %111, {%..string, i8}* %agg.result
	ret void

typeswitch.next-7:
	%112 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%113 = load %..typeid, %..typeid* %112, align 8
	%114 = icmp eq %..typeid %113, 4683743612465315907
	br i1 %114, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%115 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%116 = load %..rawptr, %..rawptr* %115, align 8
	%117 = bitcast %..rawptr %116 to i16*
	%118 = load i16, i16* %117, align 2
	store i16 %118, i16* %13
	; ReturnStmt
	%119 = load i16, i16* %13, align 2
	%120 = bitcast {%..string, i8}* %14 to %..rawptr
	; ZeroInit
	%121 = call %..rawptr @mem.zero(%..rawptr %120, i64 24)
	call void @fmt.enum_value_to_string.get_str-2({%..string, i8}* %14, i16 %119, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%122 = load {%..string, i8}, {%..string, i8}* %14, align 8
	%123 = extractvalue {%..string, i8} %122, 0
	%124 = extractvalue {%..string, i8} %122, 1
	%125 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %15, i32 0, i32 0
	store %..string %123, %..string* %125
	%126 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %15, i32 0, i32 1
	store i8 %124, i8* %126
	%127 = load {%..string, i8}, {%..string, i8}* %15, align 8
	store {%..string, i8} %127, {%..string, i8}* %agg.result
	ret void

typeswitch.next-9:
	%128 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%129 = load %..typeid, %..typeid* %128, align 8
	%130 = icmp eq %..typeid %129, 4683743612465315908
	br i1 %130, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%131 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%132 = load %..rawptr, %..rawptr* %131, align 8
	%133 = bitcast %..rawptr %132 to i32*
	%134 = load i32, i32* %133, align 4
	store i32 %134, i32* %16
	; ReturnStmt
	%135 = load i32, i32* %16, align 4
	%136 = bitcast {%..string, i8}* %17 to %..rawptr
	; ZeroInit
	%137 = call %..rawptr @mem.zero(%..rawptr %136, i64 24)
	call void @fmt.enum_value_to_string.get_str-3({%..string, i8}* %17, i32 %135, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%138 = load {%..string, i8}, {%..string, i8}* %17, align 8
	%139 = extractvalue {%..string, i8} %138, 0
	%140 = extractvalue {%..string, i8} %138, 1
	%141 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string %139, %..string* %141
	%142 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 %140, i8* %142
	%143 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %143, {%..string, i8}* %agg.result
	ret void

typeswitch.next-11:
	%144 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%145 = load %..typeid, %..typeid* %144, align 8
	%146 = icmp eq %..typeid %145, 4683743612465315844
	br i1 %146, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%147 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%148 = load %..rawptr, %..rawptr* %147, align 8
	%149 = bitcast %..rawptr %148 to i64*
	%150 = load i64, i64* %149, align 8
	store i64 %150, i64* %19
	; ReturnStmt
	%151 = load i64, i64* %19, align 8
	%152 = bitcast {%..string, i8}* %20 to %..rawptr
	; ZeroInit
	%153 = call %..rawptr @mem.zero(%..rawptr %152, i64 24)
	call void @fmt.enum_value_to_string.get_str-4({%..string, i8}* %20, i64 %151, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%154 = load {%..string, i8}, {%..string, i8}* %20, align 8
	%155 = extractvalue {%..string, i8} %154, 0
	%156 = extractvalue {%..string, i8} %154, 1
	%157 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %21, i32 0, i32 0
	store %..string %155, %..string* %157
	%158 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %21, i32 0, i32 1
	store i8 %156, i8* %158
	%159 = load {%..string, i8}, {%..string, i8}* %21, align 8
	store {%..string, i8} %159, {%..string, i8}* %agg.result
	ret void

typeswitch.next-13:
	%160 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%161 = load %..typeid, %..typeid* %160, align 8
	%162 = icmp eq %..typeid %161, 72057594037927939
	br i1 %162, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%163 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%164 = load %..rawptr, %..rawptr* %163, align 8
	%165 = bitcast %..rawptr %164 to i64*
	%166 = load i64, i64* %165, align 8
	store i64 %166, i64* %22
	; ReturnStmt
	%167 = load i64, i64* %22, align 8
	%168 = bitcast {%..string, i8}* %23 to %..rawptr
	; ZeroInit
	%169 = call %..rawptr @mem.zero(%..rawptr %168, i64 24)
	call void @fmt.enum_value_to_string.get_str-5({%..string, i8}* %23, i64 %167, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%170 = load {%..string, i8}, {%..string, i8}* %23, align 8
	%171 = extractvalue {%..string, i8} %170, 0
	%172 = extractvalue {%..string, i8} %170, 1
	%173 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %24, i32 0, i32 0
	store %..string %171, %..string* %173
	%174 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %24, i32 0, i32 1
	store i8 %172, i8* %174
	%175 = load {%..string, i8}, {%..string, i8}* %24, align 8
	store {%..string, i8} %175, {%..string, i8}* %agg.result
	ret void

typeswitch.next-15:
	%176 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%177 = load %..typeid, %..typeid* %176, align 8
	%178 = icmp eq %..typeid %177, 72057594037928005
	br i1 %178, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-16:
	%179 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%180 = load %..rawptr, %..rawptr* %179, align 8
	%181 = bitcast %..rawptr %180 to i8*
	%182 = load i8, i8* %181, align 1
	store i8 %182, i8* %25
	; ReturnStmt
	%183 = load i8, i8* %25, align 1
	%184 = bitcast {%..string, i8}* %26 to %..rawptr
	; ZeroInit
	%185 = call %..rawptr @mem.zero(%..rawptr %184, i64 24)
	call void @fmt.enum_value_to_string.get_str-6({%..string, i8}* %26, i8 %183, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%186 = load {%..string, i8}, {%..string, i8}* %26, align 8
	%187 = extractvalue {%..string, i8} %186, 0
	%188 = extractvalue {%..string, i8} %186, 1
	%189 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %27, i32 0, i32 0
	store %..string %187, %..string* %189
	%190 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %27, i32 0, i32 1
	store i8 %188, i8* %190
	%191 = load {%..string, i8}, {%..string, i8}* %27, align 8
	store {%..string, i8} %191, {%..string, i8}* %agg.result
	ret void

typeswitch.next-17:
	%192 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%193 = load %..typeid, %..typeid* %192, align 8
	%194 = icmp eq %..typeid %193, 72057594037928006
	br i1 %194, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%195 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%196 = load %..rawptr, %..rawptr* %195, align 8
	%197 = bitcast %..rawptr %196 to i16*
	%198 = load i16, i16* %197, align 2
	store i16 %198, i16* %28
	; ReturnStmt
	%199 = load i16, i16* %28, align 2
	%200 = bitcast {%..string, i8}* %29 to %..rawptr
	; ZeroInit
	%201 = call %..rawptr @mem.zero(%..rawptr %200, i64 24)
	call void @fmt.enum_value_to_string.get_str-7({%..string, i8}* %29, i16 %199, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%202 = load {%..string, i8}, {%..string, i8}* %29, align 8
	%203 = extractvalue {%..string, i8} %202, 0
	%204 = extractvalue {%..string, i8} %202, 1
	%205 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %30, i32 0, i32 0
	store %..string %203, %..string* %205
	%206 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %30, i32 0, i32 1
	store i8 %204, i8* %206
	%207 = load {%..string, i8}, {%..string, i8}* %30, align 8
	store {%..string, i8} %207, {%..string, i8}* %agg.result
	ret void

typeswitch.next-19:
	%208 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%209 = load %..typeid, %..typeid* %208, align 8
	%210 = icmp eq %..typeid %209, 72057594037928007
	br i1 %210, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%211 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%212 = load %..rawptr, %..rawptr* %211, align 8
	%213 = bitcast %..rawptr %212 to i32*
	%214 = load i32, i32* %213, align 4
	store i32 %214, i32* %31
	; ReturnStmt
	%215 = load i32, i32* %31, align 4
	%216 = bitcast {%..string, i8}* %32 to %..rawptr
	; ZeroInit
	%217 = call %..rawptr @mem.zero(%..rawptr %216, i64 24)
	call void @fmt.enum_value_to_string.get_str-8({%..string, i8}* %32, i32 %215, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%218 = load {%..string, i8}, {%..string, i8}* %32, align 8
	%219 = extractvalue {%..string, i8} %218, 0
	%220 = extractvalue {%..string, i8} %218, 1
	%221 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %33, i32 0, i32 0
	store %..string %219, %..string* %221
	%222 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %33, i32 0, i32 1
	store i8 %220, i8* %222
	%223 = load {%..string, i8}, {%..string, i8}* %33, align 8
	store {%..string, i8} %223, {%..string, i8}* %agg.result
	ret void

typeswitch.next-21:
	%224 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%225 = load %..typeid, %..typeid* %224, align 8
	%226 = icmp eq %..typeid %225, 72057594037928008
	br i1 %226, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%227 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%228 = load %..rawptr, %..rawptr* %227, align 8
	%229 = bitcast %..rawptr %228 to i64*
	%230 = load i64, i64* %229, align 8
	store i64 %230, i64* %34
	; ReturnStmt
	%231 = load i64, i64* %34, align 8
	%232 = bitcast {%..string, i8}* %35 to %..rawptr
	; ZeroInit
	%233 = call %..rawptr @mem.zero(%..rawptr %232, i64 24)
	call void @fmt.enum_value_to_string.get_str-9({%..string, i8}* %35, i64 %231, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%234 = load {%..string, i8}, {%..string, i8}* %35, align 8
	%235 = extractvalue {%..string, i8} %234, 0
	%236 = extractvalue {%..string, i8} %234, 1
	%237 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %36, i32 0, i32 0
	store %..string %235, %..string* %237
	%238 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %36, i32 0, i32 1
	store i8 %236, i8* %238
	%239 = load {%..string, i8}, {%..string, i8}* %36, align 8
	store {%..string, i8} %239, {%..string, i8}* %agg.result
	ret void

typeswitch.next-23:
	%240 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 1
	%241 = load %..typeid, %..typeid* %240, align 8
	%242 = icmp eq %..typeid %241, 72057594037927989
	br i1 %242, label %typeswitch.body-26, label %typeswitch.next-25

typeswitch.body-24:
	%243 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%244 = load %..rawptr, %..rawptr* %243, align 8
	%245 = bitcast %..rawptr %244 to i64*
	%246 = load i64, i64* %245, align 8
	store i64 %246, i64* %37
	; ReturnStmt
	%247 = load i64, i64* %37, align 8
	%248 = bitcast {%..string, i8}* %38 to %..rawptr
	; ZeroInit
	%249 = call %..rawptr @mem.zero(%..rawptr %248, i64 24)
	call void @fmt.enum_value_to_string.get_str-10({%..string, i8}* %38, i64 %247, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%250 = load {%..string, i8}, {%..string, i8}* %38, align 8
	%251 = extractvalue {%..string, i8} %250, 0
	%252 = extractvalue {%..string, i8} %250, 1
	%253 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %39, i32 0, i32 0
	store %..string %251, %..string* %253
	%254 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %39, i32 0, i32 1
	store i8 %252, i8* %254
	%255 = load {%..string, i8}, {%..string, i8}* %39, align 8
	store {%..string, i8} %255, {%..string, i8}* %agg.result
	ret void

typeswitch.next-25:
	; ReturnStmt
	%256 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %45, i32 0, i32 0
	store %..string zeroinitializer, %..string* %256
	%257 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %45, i32 0, i32 1
	store i8 0, i8* %257
	%258 = load {%..string, i8}, {%..string, i8}* %45, align 8
	store {%..string, i8} %258, {%..string, i8}* %agg.result
	ret void

typeswitch.body-26:
	%259 = getelementptr inbounds %..any, %..any* %4, i32 0, i32 0
	%260 = load %..rawptr, %..rawptr* %259, align 8
	%261 = bitcast %..rawptr %260 to i64*
	%262 = load i64, i64* %261, align 8
	store i64 %262, i64* %40
	; ReturnStmt
	%263 = load i64, i64* %40, align 8
	%264 = bitcast {%..string, i8}* %41 to %..rawptr
	; ZeroInit
	%265 = call %..rawptr @mem.zero(%..rawptr %264, i64 24)
	call void @fmt.enum_value_to_string.get_str-11({%..string, i8}* %41, i64 %263, %runtime.Type_Info_Enum* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%266 = load {%..string, i8}, {%..string, i8}* %41, align 8
	%267 = extractvalue {%..string, i8} %266, 0
	%268 = extractvalue {%..string, i8} %266, 1
	%269 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %42, i32 0, i32 0
	store %..string %267, %..string* %269
	%270 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %42, i32 0, i32 1
	store i8 %268, i8* %270
	%271 = load {%..string, i8}, {%..string, i8}* %42, align 8
	store {%..string, i8} %271, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-0({%..string, i8}* sret noalias %agg.result, i32 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %_.0, i32* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i32, i8} zeroinitializer, {i32, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 1
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%40 = load i32, i32* %39, align 4
	store i32 %40, i32* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i32, i8}, {i32, i8}* %7, align 4
	%42 = extractvalue {i32, i8} %41, 0
	%43 = extractvalue {i32, i8} %41, 1
	store i32 %42, i32* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i32, i32* %5, align 4
	%47 = load i32, i32* %0, align 4
	%48 = icmp eq i32 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$9f, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i32, i8} zeroinitializer, {i32, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 1
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%87 = load i32, i32* %86, align 4
	store i32 %87, i32* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i32, i8}, {i32, i8}* %16, align 4
	%89 = extractvalue {i32, i8} %88, 0
	%90 = extractvalue {i32, i8} %88, 1
	store i32 %89, i32* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i32, i32* %14, align 4
	%94 = load i32, i32* %0, align 4
	%95 = icmp eq i32 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a0, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-1({%..string, i8}* sret noalias %agg.result, i8 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i8, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i8, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i8 %_.0, i8* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i8, i8} zeroinitializer, {i8, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 2
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i8*
	%40 = load i8, i8* %39, align 1
	store i8 %40, i8* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i8, i8}, {i8, i8}* %7, align 1
	%42 = extractvalue {i8, i8} %41, 0
	%43 = extractvalue {i8, i8} %41, 1
	store i8 %42, i8* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i8, i8* %5, align 1
	%47 = load i8, i8* %0, align 1
	%48 = icmp eq i8 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a1, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i8, i8} zeroinitializer, {i8, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 2
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i8*
	%87 = load i8, i8* %86, align 1
	store i8 %87, i8* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i8, i8}, {i8, i8}* %16, align 1
	%89 = extractvalue {i8, i8} %88, 0
	%90 = extractvalue {i8, i8} %88, 1
	store i8 %89, i8* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i8, i8* %14, align 1
	%94 = load i8, i8* %0, align 1
	%95 = icmp eq i8 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a2, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-2({%..string, i8}* sret noalias %agg.result, i16 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i16, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i16, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i16, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i16, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i16, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i16 %_.0, i16* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i16, i8} zeroinitializer, {i16, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 3
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i16*
	%40 = load i16, i16* %39, align 2
	store i16 %40, i16* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i16, i8}, {i16, i8}* %7, align 2
	%42 = extractvalue {i16, i8} %41, 0
	%43 = extractvalue {i16, i8} %41, 1
	store i16 %42, i16* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i16, i16* %5, align 2
	%47 = load i16, i16* %0, align 2
	%48 = icmp eq i16 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a3, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i16, i8} zeroinitializer, {i16, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 3
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i16*
	%87 = load i16, i16* %86, align 2
	store i16 %87, i16* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i16, i8}, {i16, i8}* %16, align 2
	%89 = extractvalue {i16, i8} %88, 0
	%90 = extractvalue {i16, i8} %88, 1
	store i16 %89, i16* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i16, i16* %14, align 2
	%94 = load i16, i16* %0, align 2
	%95 = icmp eq i16 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a4, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-3({%..string, i8}* sret noalias %agg.result, i32 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %_.0, i32* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i32, i8} zeroinitializer, {i32, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 4
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%40 = load i32, i32* %39, align 4
	store i32 %40, i32* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i32, i8}, {i32, i8}* %7, align 4
	%42 = extractvalue {i32, i8} %41, 0
	%43 = extractvalue {i32, i8} %41, 1
	store i32 %42, i32* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i32, i32* %5, align 4
	%47 = load i32, i32* %0, align 4
	%48 = icmp eq i32 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a5, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i32, i8} zeroinitializer, {i32, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 4
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%87 = load i32, i32* %86, align 4
	store i32 %87, i32* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i32, i8}, {i32, i8}* %16, align 4
	%89 = extractvalue {i32, i8} %88, 0
	%90 = extractvalue {i32, i8} %88, 1
	store i32 %89, i32* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i32, i32* %14, align 4
	%94 = load i32, i32* %0, align 4
	%95 = icmp eq i32 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a6, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-4({%..string, i8}* sret noalias %agg.result, i64 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 5
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i64, i8}, {i64, i8}* %7, align 8
	%42 = extractvalue {i64, i8} %41, 0
	%43 = extractvalue {i64, i8} %41, 1
	store i64 %42, i64* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %0, align 8
	%48 = icmp eq i64 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a7, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 5
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%87 = load i64, i64* %86, align 8
	store i64 %87, i64* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i64, i8}, {i64, i8}* %16, align 8
	%89 = extractvalue {i64, i8} %88, 0
	%90 = extractvalue {i64, i8} %88, 1
	store i64 %89, i64* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i64, i64* %14, align 8
	%94 = load i64, i64* %0, align 8
	%95 = icmp eq i64 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a8, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-5({%..string, i8}* sret noalias %agg.result, i64 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 6
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i64, i8}, {i64, i8}* %7, align 8
	%42 = extractvalue {i64, i8} %41, 0
	%43 = extractvalue {i64, i8} %41, 1
	store i64 %42, i64* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %0, align 8
	%48 = icmp eq i64 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$a9, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 6
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%87 = load i64, i64* %86, align 8
	store i64 %87, i64* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i64, i8}, {i64, i8}* %16, align 8
	%89 = extractvalue {i64, i8} %88, 0
	%90 = extractvalue {i64, i8} %88, 1
	store i64 %89, i64* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i64, i64* %14, align 8
	%94 = load i64, i64* %0, align 8
	%95 = icmp eq i64 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$aa, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-6({%..string, i8}* sret noalias %agg.result, i8 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i8, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i8, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i8, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i8, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i8 %_.0, i8* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i8, i8} zeroinitializer, {i8, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 7
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i8, i8}, {i8, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i8*
	%40 = load i8, i8* %39, align 1
	store i8 %40, i8* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i8, i8}, {i8, i8}* %7, align 1
	%42 = extractvalue {i8, i8} %41, 0
	%43 = extractvalue {i8, i8} %41, 1
	store i8 %42, i8* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i8, i8* %5, align 1
	%47 = load i8, i8* %0, align 1
	%48 = icmp eq i8 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ab, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i8, i8} zeroinitializer, {i8, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 7
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i8, i8}, {i8, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i8*
	%87 = load i8, i8* %86, align 1
	store i8 %87, i8* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i8, i8}, {i8, i8}* %16, align 1
	%89 = extractvalue {i8, i8} %88, 0
	%90 = extractvalue {i8, i8} %88, 1
	store i8 %89, i8* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i8, i8* %14, align 1
	%94 = load i8, i8* %0, align 1
	%95 = icmp eq i8 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ac, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-7({%..string, i8}* sret noalias %agg.result, i16 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i16, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i16, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i16, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i16, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i16, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i16 %_.0, i16* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i16, i8} zeroinitializer, {i16, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 8
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i16, i8}, {i16, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i16*
	%40 = load i16, i16* %39, align 2
	store i16 %40, i16* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i16, i8}, {i16, i8}* %7, align 2
	%42 = extractvalue {i16, i8} %41, 0
	%43 = extractvalue {i16, i8} %41, 1
	store i16 %42, i16* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i16, i16* %5, align 2
	%47 = load i16, i16* %0, align 2
	%48 = icmp eq i16 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ad, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i16, i8} zeroinitializer, {i16, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 8
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i16, i8}, {i16, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i16*
	%87 = load i16, i16* %86, align 2
	store i16 %87, i16* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i16, i8}, {i16, i8}* %16, align 2
	%89 = extractvalue {i16, i8} %88, 0
	%90 = extractvalue {i16, i8} %88, 1
	store i16 %89, i16* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i16, i16* %14, align 2
	%94 = load i16, i16* %0, align 2
	%95 = icmp eq i16 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ae, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-8({%..string, i8}* sret noalias %agg.result, i32 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i32, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i32, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i32 %_.0, i32* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i32, i8} zeroinitializer, {i32, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 9
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i32, i8}, {i32, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i32*
	%40 = load i32, i32* %39, align 4
	store i32 %40, i32* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i32, i8}, {i32, i8}* %7, align 4
	%42 = extractvalue {i32, i8} %41, 0
	%43 = extractvalue {i32, i8} %41, 1
	store i32 %42, i32* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i32, i32* %5, align 4
	%47 = load i32, i32* %0, align 4
	%48 = icmp eq i32 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$af, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i32, i8} zeroinitializer, {i32, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 9
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i32, i8}, {i32, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i32*
	%87 = load i32, i32* %86, align 4
	store i32 %87, i32* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i32, i8}, {i32, i8}* %16, align 4
	%89 = extractvalue {i32, i8} %88, 0
	%90 = extractvalue {i32, i8} %88, 1
	store i32 %89, i32* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i32, i32* %14, align 4
	%94 = load i32, i32* %0, align 4
	%95 = icmp eq i32 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b0, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-9({%..string, i8}* sret noalias %agg.result, i64 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 10
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i64, i8}, {i64, i8}* %7, align 8
	%42 = extractvalue {i64, i8} %41, 0
	%43 = extractvalue {i64, i8} %41, 1
	store i64 %42, i64* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %0, align 8
	%48 = icmp eq i64 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b1, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 10
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%87 = load i64, i64* %86, align 8
	store i64 %87, i64* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i64, i8}, {i64, i8}* %16, align 8
	%89 = extractvalue {i64, i8} %88, 0
	%90 = extractvalue {i64, i8} %88, 1
	store i64 %89, i64* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i64, i64* %14, align 8
	%94 = load i64, i64* %0, align 8
	%95 = icmp eq i64 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b2, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-10({%..string, i8}* sret noalias %agg.result, i64 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 11
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i64, i8}, {i64, i8}* %7, align 8
	%42 = extractvalue {i64, i8} %41, 0
	%43 = extractvalue {i64, i8} %41, 1
	store i64 %42, i64* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %0, align 8
	%48 = icmp eq i64 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b3, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 11
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%87 = load i64, i64* %86, align 8
	store i64 %87, i64* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i64, i8}, {i64, i8}* %16, align 8
	%89 = extractvalue {i64, i8} %88, 0
	%90 = extractvalue {i64, i8} %88, 1
	store i64 %89, i64* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i64, i64* %14, align 8
	%94 = load i64, i64* %0, align 8
	%95 = icmp eq i64 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b4, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.enum_value_to_string.get_str-11({%..string, i8}* sret noalias %agg.result, i64 %_.0, %runtime.Type_Info_Enum* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %runtime.Type_Info_Enum_Value, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca {i64, i8}, align 16
	%8 = alloca {%..string, i8}, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca %runtime.Type_Info_Enum_Value, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i64, i8}, align 16
	%17 = alloca {%..string, i8}, align 16
	%18 = alloca {%..string, i8}, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%19 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 0
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %19, align 8
	%21 = call i8 @reflect.is_string(%runtime.Type_Info* %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-1, label %if.else-10

if.then-1:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %1, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %2, align 1
	; SelectorExpr
	%23 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%24 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %23, align 8
	%25 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 1
	store i64 %25, i64* %3
	store i64 -1, i64* %4
	br label %for.index.loop-2

for.index.loop-2:
	%26 = load i64, i64* %4, align 8
	%27 = add i64 %26, 1
	store i64 %27, i64* %4
	%28 = load i64, i64* %3, align 8
	%29 = icmp slt i64 %27, %28
	br i1 %29, label %for.index.body-3, label %for.index.done-9

for.index.body-3:
	%30 = load i64, i64* %4, align 8
	%31 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %24, 0
	%32 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %31, i64 %30
	%33 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %32, align 8
	store %runtime.Type_Info_Enum_Value %33, %runtime.Type_Info_Enum_Value* %1
	store i64 %30, i64* %2
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %7, align 1
	%34 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = icmp eq i64 %35, 12
	br i1 %36, label %union_cast.ok-4, label %union_cast.end-5

union_cast.ok-4:
	%37 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 0
	%38 = getelementptr inbounds {i64, i8}, {i64, i8}* %7, i32 0, i32 1
	%39 = bitcast %runtime.Type_Info_Enum_Value* %1 to i64*
	%40 = load i64, i64* %39, align 8
	store i64 %40, i64* %37
	store i8 1, i8* %38
	br label %union_cast.end-5

union_cast.end-5:
	%41 = load {i64, i8}, {i64, i8}* %7, align 8
	%42 = extractvalue {i64, i8} %41, 0
	%43 = extractvalue {i64, i8} %41, 1
	store i64 %42, i64* %5
	store i8 %43, i8* %6
	%44 = load i8, i8* %6, align 1
	%45 = trunc i8 %44 to i1
	br i1 %45, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%46 = load i64, i64* %5, align 8
	%47 = load i64, i64* %0, align 8
	%48 = icmp eq i64 %46, %47
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%51 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%52 = load {%..string*, i64}, {%..string*, i64}* %51, align 8
	%53 = extractvalue {%..string*, i64} %52, 0
	%54 = load i64, i64* %2, align 8
	%55 = extractvalue {%..string*, i64} %52, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b5, i32 0, i32 0), i64 57}, i64 804, i64 22, i64 %54, i64 %55)
	%56 = getelementptr inbounds %..string, %..string* %53, i64 %54
	%57 = load %..string, %..string* %56, align 8
	%58 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 0
	store %..string %57, %..string* %58
	%59 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %8, i32 0, i32 1
	store i8 1, i8* %59
	%60 = load {%..string, i8}, {%..string, i8}* %8, align 8
	store {%..string, i8} %60, {%..string, i8}* %agg.result
	ret void

if.done-8:
	br label %for.index.loop-2

for.index.done-9:
	br label %if.done-21

if.else-10:
	; IfStmt
	; SelectorExpr
	%61 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%62 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %61, align 8
	%63 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %62, 1
	%64 = icmp eq i64 %63, 0
	%65 = zext i1 %64 to i8
	%66 = trunc i8 %65 to i1
	br i1 %66, label %if.then-11, label %if.else-12

if.then-11:
	; ReturnStmt
	%67 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 0
	store %..string zeroinitializer, %..string* %67
	%68 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %9, i32 0, i32 1
	store i8 1, i8* %68
	%69 = load {%..string, i8}, {%..string, i8}* %9, align 8
	store {%..string, i8} %69, {%..string, i8}* %agg.result
	ret void

if.else-12:
	; RangeStmt
	; val
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %10, align 1
	; idx
	; ZeroInit
	store i64 zeroinitializer, i64* %11, align 1
	; SelectorExpr
	%70 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 2
	%71 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %70, align 8
	%72 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 1
	store i64 %72, i64* %12
	store i64 -1, i64* %13
	br label %for.index.loop-13

for.index.loop-13:
	%73 = load i64, i64* %13, align 8
	%74 = add i64 %73, 1
	store i64 %74, i64* %13
	%75 = load i64, i64* %12, align 8
	%76 = icmp slt i64 %74, %75
	br i1 %76, label %for.index.body-14, label %for.index.done-20

for.index.body-14:
	%77 = load i64, i64* %13, align 8
	%78 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %71, 0
	%79 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %78, i64 %77
	%80 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %79, align 8
	store %runtime.Type_Info_Enum_Value %80, %runtime.Type_Info_Enum_Value* %10
	store i64 %77, i64* %11
	; IfStmt
	; v
	; ok
	; cast - union_cast
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %16, align 1
	%81 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %10, i64 0, i32 2 ; UnionTagPtr
	%82 = load i64, i64* %81, align 8
	%83 = icmp eq i64 %82, 12
	br i1 %83, label %union_cast.ok-15, label %union_cast.end-16

union_cast.ok-15:
	%84 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 0
	%85 = getelementptr inbounds {i64, i8}, {i64, i8}* %16, i32 0, i32 1
	%86 = bitcast %runtime.Type_Info_Enum_Value* %10 to i64*
	%87 = load i64, i64* %86, align 8
	store i64 %87, i64* %84
	store i8 1, i8* %85
	br label %union_cast.end-16

union_cast.end-16:
	%88 = load {i64, i8}, {i64, i8}* %16, align 8
	%89 = extractvalue {i64, i8} %88, 0
	%90 = extractvalue {i64, i8} %88, 1
	store i64 %89, i64* %14
	store i8 %90, i8* %15
	%91 = load i8, i8* %15, align 1
	%92 = trunc i8 %91 to i1
	br i1 %92, label %cmp.and-17, label %if.done-19

cmp.and-17:
	%93 = load i64, i64* %14, align 8
	%94 = load i64, i64* %0, align 8
	%95 = icmp eq i64 %93, %94
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%98 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %_.1, i32 0, i32 1
	%99 = load {%..string*, i64}, {%..string*, i64}* %98, align 8
	%100 = extractvalue {%..string*, i64} %99, 0
	%101 = load i64, i64* %11, align 8
	%102 = extractvalue {%..string*, i64} %99, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b6, i32 0, i32 0), i64 57}, i64 812, i64 22, i64 %101, i64 %102)
	%103 = getelementptr inbounds %..string, %..string* %100, i64 %101
	%104 = load %..string, %..string* %103, align 8
	%105 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 0
	store %..string %104, %..string* %105
	%106 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %17, i32 0, i32 1
	store i8 1, i8* %106
	%107 = load {%..string, i8}, {%..string, i8}* %17, align 8
	store {%..string, i8} %107, {%..string, i8}* %agg.result
	ret void

if.done-19:
	br label %for.index.loop-13

for.index.done-20:
	br label %if.done-21

if.done-21:
	; ReturnStmt
	%108 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 0
	store %..string zeroinitializer, %..string* %108
	%109 = getelementptr inbounds {%..string, i8}, {%..string, i8}* %18, i32 0, i32 1
	store i8 0, i8* %109
	%110 = load {%..string, i8}, {%..string, i8}* %18, align 8
	store {%..string, i8} %110, {%..string, i8}* %agg.result
	ret void
}

define void @fmt.fmt_enum(%fmt.Info* %_.0, %..any %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Enum, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info*, align 16
	%7 = alloca %..string, align 16
	%8 = alloca i8, align 16
	%9 = alloca {%..string, i8}, align 16
	%10 = alloca {[0 x i64], [88 x i8], i64}, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..any %_.1, %..any* %1
	store i32 %_.2, i32* %2
	; IfStmt
	; SelectorExpr
	%11 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%12 = load %..typeid, %..typeid* %11, align 8
	%13 = icmp eq %..typeid %12, 0
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%16 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%17 = load %..rawptr, %..rawptr* %16, align 8
	%18 = icmp eq %..rawptr %17, zeroinitializer
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-2, label %if.done-3

if.then-2:
	; SelectorExpr
	; SelectorExpr
	%21 = load %fmt.Info*, %fmt.Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Info, %fmt.Info* %21, i32 0, i32 12
	%23 = load %strings.Builder*, %strings.Builder** %22, align 8
	call void @strings.write_string(%strings.Builder* %23, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$b7, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-3:
	; type_info
	; SelectorExpr
	%24 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%25 = load %..typeid, %..typeid* %24, align 8
	%26 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %25)
	store %runtime.Type_Info* %26, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%27 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%28 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i32 0, i32 3
	%29 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %28, align 8
	; get union's tag
	%30 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %28, i64 0, i32 2 ; UnionTagPtr
	%31 = load i64, i64* %30, align 8
	%32 = bitcast {[0 x i64], [88 x i8], i64}* %28 to %..rawptr
	%33 = icmp eq i64 %31, 19
	br i1 %33, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	store {[0 x i64], [88 x i8], i64} %29, {[0 x i64], [88 x i8], i64}* %10
	%34 = load %fmt.Info*, %fmt.Info** %0, align 8
	%35 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %34, i32 %35, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-15

typeswitch.body-5:
	%36 = bitcast %..rawptr %32 to %runtime.Type_Info_Enum*
	%37 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %36, align 8
	store %runtime.Type_Info_Enum %37, %runtime.Type_Info_Enum* %4
	; SwitchStmt
	%38 = load i32, i32* %2, align 4
	%39 = icmp eq i32 %38, 100
	br i1 %39, label %switch.fall.body-8, label %switch.case.next-6

switch.case.next-6:
	%40 = icmp eq i32 %38, 102
	br i1 %40, label %switch.fall.body-8, label %switch.case.next-7

switch.case.next-7:
	%41 = icmp eq i32 %38, 115
	br i1 %41, label %switch.fall.body-11, label %switch.case.next-9

switch.fall.body-8:
	%42 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %5, align 1
	store %..any zeroinitializer, %..any* %5
	; SelectorExpr
	%43 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%44 = load %..rawptr, %..rawptr* %43, align 8
	%45 = getelementptr inbounds %..any, %..any* %5, i32 0, i32 0
	store %..rawptr %44, %..rawptr* %45
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%46 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %4, i32 0, i32 0
	%47 = load %runtime.Type_Info*, %runtime.Type_Info** %46, align 8
	%48 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %47)
	store %runtime.Type_Info* %48, %runtime.Type_Info** %6
	%49 = load %runtime.Type_Info*, %runtime.Type_Info** %6, align 8
	%50 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %49, i32 0, i32 2
	%51 = load %..typeid, %..typeid* %50, align 8
	%52 = getelementptr inbounds %..any, %..any* %5, i32 0, i32 1
	store %..typeid %51, %..typeid* %52
	%53 = load %..any, %..any* %5, align 8
	%54 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %42, %..any %53, i32 %54, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-14

switch.case.next-9:
	%55 = icmp eq i32 %38, 118
	br i1 %55, label %switch.fall.body-11, label %switch.case.next-10

switch.case.next-10:
	%56 = load %fmt.Info*, %fmt.Info** %0, align 8
	%57 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %56, i32 %57, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-14

switch.fall.body-11:
	; str
	; ok
	%58 = load %..any, %..any* %1, align 8
	%59 = bitcast {%..string, i8}* %9 to %..rawptr
	; ZeroInit
	%60 = call %..rawptr @mem.zero(%..rawptr %59, i64 24)
	call void @fmt.enum_value_to_string({%..string, i8}* %9, %..any %58, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%61 = load {%..string, i8}, {%..string, i8}* %9, align 8
	%62 = extractvalue {%..string, i8} %61, 0
	%63 = extractvalue {%..string, i8} %61, 1
	store %..string %62, %..string* %7
	store i8 %63, i8* %8
	; IfStmt
	%64 = load i8, i8* %8, align 1
	%65 = trunc i8 %64 to i1
	br i1 %65, label %if.done-13, label %if.then-12

if.then-12:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$b8, i32 0, i32 0), i64 18}, %..string* %7
	br label %if.done-13

if.done-13:
	; SelectorExpr
	; SelectorExpr
	%66 = load %fmt.Info*, %fmt.Info** %0, align 8
	%67 = getelementptr inbounds %fmt.Info, %fmt.Info* %66, i32 0, i32 12
	%68 = load %strings.Builder*, %strings.Builder** %67, align 8
	%69 = load %..string, %..string* %7, align 8
	call void @strings.write_string(%strings.Builder* %68, %..string %69, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-14

switch.done-14:
	br label %typeswitch.done-15

typeswitch.done-15:
	ret void
}

define i64 @fmt.enum_value_to_u64(%runtime.Type_Info_Enum_Value* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8, align 16
	%2 = alloca i16, align 16
	%3 = alloca i32, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i8, align 16
	%7 = alloca i16, align 16
	%8 = alloca i32, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	; TypeSwitchStmt
	; get union's tag
	%12 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %_.0, i64 0, i32 2 ; UnionTagPtr
	%13 = load i64, i64* %12, align 8
	%14 = bitcast %runtime.Type_Info_Enum_Value* %_.0 to %..rawptr
	%15 = icmp eq i64 %13, 1
	br i1 %15, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%16 = icmp eq i64 %13, 2
	br i1 %16, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%17 = bitcast %..rawptr %14 to i32*
	%18 = load i32, i32* %17, align 4
	store i32 %18, i32* %0
	; ReturnStmt
	%19 = load i32, i32* %0, align 4
	%20 = sext i32 %19 to i64
	ret i64 %20

typeswitch.next-3:
	%21 = icmp eq i64 %13, 3
	br i1 %21, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%22 = bitcast %..rawptr %14 to i8*
	%23 = load i8, i8* %22, align 1
	store i8 %23, i8* %1
	; ReturnStmt
	%24 = load i8, i8* %1, align 1
	%25 = sext i8 %24 to i64
	ret i64 %25

typeswitch.next-5:
	%26 = icmp eq i64 %13, 4
	br i1 %26, label %typeswitch.body-8, label %typeswitch.next-7

typeswitch.body-6:
	%27 = bitcast %..rawptr %14 to i16*
	%28 = load i16, i16* %27, align 2
	store i16 %28, i16* %2
	; ReturnStmt
	%29 = load i16, i16* %2, align 2
	%30 = sext i16 %29 to i64
	ret i64 %30

typeswitch.next-7:
	%31 = icmp eq i64 %13, 5
	br i1 %31, label %typeswitch.body-10, label %typeswitch.next-9

typeswitch.body-8:
	%32 = bitcast %..rawptr %14 to i32*
	%33 = load i32, i32* %32, align 4
	store i32 %33, i32* %3
	; ReturnStmt
	%34 = load i32, i32* %3, align 4
	%35 = sext i32 %34 to i64
	ret i64 %35

typeswitch.next-9:
	%36 = icmp eq i64 %13, 6
	br i1 %36, label %typeswitch.body-12, label %typeswitch.next-11

typeswitch.body-10:
	%37 = bitcast %..rawptr %14 to i64*
	%38 = load i64, i64* %37, align 8
	store i64 %38, i64* %4
	; ReturnStmt
	%39 = load i64, i64* %4, align 8
	%40 = bitcast i64 %39 to i64
	ret i64 %40

typeswitch.next-11:
	%41 = icmp eq i64 %13, 7
	br i1 %41, label %typeswitch.body-14, label %typeswitch.next-13

typeswitch.body-12:
	%42 = bitcast %..rawptr %14 to i64*
	%43 = load i64, i64* %42, align 8
	store i64 %43, i64* %5
	; ReturnStmt
	%44 = load i64, i64* %5, align 8
	%45 = bitcast i64 %44 to i64
	ret i64 %45

typeswitch.next-13:
	%46 = icmp eq i64 %13, 8
	br i1 %46, label %typeswitch.body-16, label %typeswitch.next-15

typeswitch.body-14:
	%47 = bitcast %..rawptr %14 to i8*
	%48 = load i8, i8* %47, align 1
	store i8 %48, i8* %6
	; ReturnStmt
	%49 = load i8, i8* %6, align 1
	%50 = zext i8 %49 to i64
	ret i64 %50

typeswitch.next-15:
	%51 = icmp eq i64 %13, 9
	br i1 %51, label %typeswitch.body-18, label %typeswitch.next-17

typeswitch.body-16:
	%52 = bitcast %..rawptr %14 to i16*
	%53 = load i16, i16* %52, align 2
	store i16 %53, i16* %7
	; ReturnStmt
	%54 = load i16, i16* %7, align 2
	%55 = zext i16 %54 to i64
	ret i64 %55

typeswitch.next-17:
	%56 = icmp eq i64 %13, 10
	br i1 %56, label %typeswitch.body-20, label %typeswitch.next-19

typeswitch.body-18:
	%57 = bitcast %..rawptr %14 to i32*
	%58 = load i32, i32* %57, align 4
	store i32 %58, i32* %8
	; ReturnStmt
	%59 = load i32, i32* %8, align 4
	%60 = zext i32 %59 to i64
	ret i64 %60

typeswitch.next-19:
	%61 = icmp eq i64 %13, 11
	br i1 %61, label %typeswitch.body-22, label %typeswitch.next-21

typeswitch.body-20:
	%62 = bitcast %..rawptr %14 to i64*
	%63 = load i64, i64* %62, align 8
	store i64 %63, i64* %9
	; ReturnStmt
	%64 = load i64, i64* %9, align 8
	ret i64 %64

typeswitch.next-21:
	%65 = icmp eq i64 %13, 12
	br i1 %65, label %typeswitch.body-24, label %typeswitch.next-23

typeswitch.body-22:
	%66 = bitcast %..rawptr %14 to i64*
	%67 = load i64, i64* %66, align 8
	store i64 %67, i64* %10
	; ReturnStmt
	%68 = load i64, i64* %10, align 8
	%69 = bitcast i64 %68 to i64
	ret i64 %69

typeswitch.next-23:
	; ReturnStmt
	ret i64 0

typeswitch.body-24:
	%70 = bitcast %..rawptr %14 to i64*
	%71 = load i64, i64* %70, align 8
	store i64 %71, i64* %11
	; ReturnStmt
	%72 = load i64, i64* %11, align 8
	%73 = bitcast i64 %72 to i64
	ret i64 %73
}

define void @fmt.fmt_bit_set(%fmt.Info* %_.0, %..any %_.1, %..string %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info_Bit_Set, align 16
	%7 = alloca i128, align 16
	%8 = alloca i128, align 16
	%9 = alloca i8, align 16
	%10 = alloca i8, align 16
	%11 = alloca i16, align 16
	%12 = alloca i32, align 16
	%13 = alloca i64, align 16
	%14 = alloca i128, align 16
	%15 = alloca %runtime.Source_Code_Location, align 16
	%16 = alloca %runtime.Type_Info*, align 16
	%17 = alloca %runtime.Type_Info_Enum, align 16
	%18 = alloca i8, align 16
	%19 = alloca {%runtime.Type_Info_Enum, i8}, align 16
	%20 = alloca i64, align 16
	%21 = alloca i128, align 16
	%22 = alloca i128, align 16
	%23 = alloca i64, align 16
	%24 = alloca %runtime.Type_Info_Enum_Value, align 16
	%25 = alloca i64, align 16
	%26 = alloca i64, align 16
	%27 = alloca i64, align 16
	%28 = alloca i64, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..any %_.1, %..any* %1
	store %..string %_.2, %..string* %2
	; type_info
	; SelectorExpr
	%29 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%30 = load %..typeid, %..typeid* %29, align 8
	%31 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %30)
	store %runtime.Type_Info* %31, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%32 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%33 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i32 0, i32 3
	; get union's tag
	%34 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %33, i64 0, i32 2 ; UnionTagPtr
	%35 = load i64, i64* %34, align 8
	%36 = bitcast {[0 x i64], [88 x i8], i64}* %33 to %..rawptr
	%37 = icmp eq i64 %35, 1
	br i1 %37, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%38 = icmp eq i64 %35, 22
	br i1 %38, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%39 = bitcast %..rawptr %36 to %runtime.Type_Info_Named*
	%40 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %39, align 8
	store %runtime.Type_Info_Named %40, %runtime.Type_Info_Named* %4
	; val
	%41 = load %..any, %..any* %1, align 8
	store %..any %41, %..any* %5
	; AssignStmt
	; SelectorExpr
	%42 = getelementptr inbounds %..any, %..any* %5, i32 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%43 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 1
	%44 = load %runtime.Type_Info*, %runtime.Type_Info** %43, align 8
	%45 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %44, i32 0, i32 2
	%46 = load %..typeid, %..typeid* %45, align 8
	store %..typeid %46, %..typeid* %42
	%47 = load %fmt.Info*, %fmt.Info** %0, align 8
	%48 = load %..any, %..any* %5, align 8
	; SelectorExpr
	%49 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 0
	%50 = load %..string, %..string* %49, align 8
	call void @fmt.fmt_bit_set(%fmt.Info* %47, %..any %48, %..string %50, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-45

typeswitch.next-3:
	br label %typeswitch.done-45

typeswitch.body-4:
	%51 = bitcast %..rawptr %36 to %runtime.Type_Info_Bit_Set*
	%52 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %51, align 8
	store %runtime.Type_Info_Bit_Set %52, %runtime.Type_Info_Bit_Set* %6
	; bits
	; ZeroInit
	store i128 zeroinitializer, i128* %7, align 1
	; bit_size
	; SelectorExpr
	%53 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%54 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %53, i32 0, i32 0
	%55 = load i64, i64* %54, align 8
	%56 = mul i64 8, %55
	%57 = sext i64 %56 to i128
	store i128 %57, i128* %8
	; do_byte_swap
	; SelectorExpr
	%58 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %6, i32 0, i32 1
	%59 = load %runtime.Type_Info*, %runtime.Type_Info** %58, align 8
	%60 = call i8 @fmt.fmt_bit_set.is_bit_set_different_endian_to_platform-0(%runtime.Type_Info* %59, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store i8 %60, i8* %9
	; SwitchStmt
	%61 = load i128, i128* %8, align 8
	%62 = icmp eq i128 %61, 0
	br i1 %62, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%63 = icmp eq i128 %61, 8
	br i1 %63, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	store i128 0, i128* %7
	br label %switch.done-25

switch.case.next-7:
	%64 = icmp eq i128 %61, 16
	br i1 %64, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; x
	; SelectorExpr
	%65 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%66 = load %..rawptr, %..rawptr* %65, align 8
	%67 = bitcast %..rawptr %66 to i8*
	%68 = getelementptr inbounds i8, i8* %67, i64 0
	%69 = load i8, i8* %68, align 1
	store i8 %69, i8* %10
	; AssignStmt
	%70 = load i8, i8* %10, align 1
	%71 = zext i8 %70 to i128
	store i128 %71, i128* %7
	br label %switch.done-25

switch.case.next-9:
	%72 = icmp eq i128 %61, 32
	br i1 %72, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-10:
	; x
	; SelectorExpr
	%73 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%74 = load %..rawptr, %..rawptr* %73, align 8
	%75 = bitcast %..rawptr %74 to i16*
	%76 = getelementptr inbounds i16, i16* %75, i64 0
	%77 = load i16, i16* %76, align 2
	store i16 %77, i16* %11
	; IfStmt
	%78 = load i8, i8* %9, align 1
	%79 = trunc i8 %78 to i1
	br i1 %79, label %if.then-11, label %if.done-12

if.then-11:
	; AssignStmt
	%80 = load i16, i16* %11, align 2
	%81 = call i16 @llvm.bswap.i16(i16 %80)
	store i16 %81, i16* %11
	br label %if.done-12

if.done-12:
	; AssignStmt
	%82 = load i16, i16* %11, align 2
	%83 = zext i16 %82 to i128
	store i128 %83, i128* %7
	br label %switch.done-25

switch.case.next-13:
	%84 = icmp eq i128 %61, 64
	br i1 %84, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-14:
	; x
	; SelectorExpr
	%85 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%86 = load %..rawptr, %..rawptr* %85, align 8
	%87 = bitcast %..rawptr %86 to i32*
	%88 = getelementptr inbounds i32, i32* %87, i64 0
	%89 = load i32, i32* %88, align 4
	store i32 %89, i32* %12
	; IfStmt
	%90 = load i8, i8* %9, align 1
	%91 = trunc i8 %90 to i1
	br i1 %91, label %if.then-15, label %if.done-16

if.then-15:
	; AssignStmt
	%92 = load i32, i32* %12, align 4
	%93 = call i32 @llvm.bswap.i32(i32 %92)
	store i32 %93, i32* %12
	br label %if.done-16

if.done-16:
	; AssignStmt
	%94 = load i32, i32* %12, align 4
	%95 = zext i32 %94 to i128
	store i128 %95, i128* %7
	br label %switch.done-25

switch.case.next-17:
	%96 = icmp eq i128 %61, 128
	br i1 %96, label %switch.fall.body-22, label %switch.case.next-21

switch.fall.body-18:
	; x
	; SelectorExpr
	%97 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%98 = load %..rawptr, %..rawptr* %97, align 8
	%99 = bitcast %..rawptr %98 to i64*
	%100 = getelementptr inbounds i64, i64* %99, i64 0
	%101 = load i64, i64* %100, align 8
	store i64 %101, i64* %13
	; IfStmt
	%102 = load i8, i8* %9, align 1
	%103 = trunc i8 %102 to i1
	br i1 %103, label %if.then-19, label %if.done-20

if.then-19:
	; AssignStmt
	%104 = load i64, i64* %13, align 8
	%105 = call i64 @llvm.bswap.i64(i64 %104)
	store i64 %105, i64* %13
	br label %if.done-20

if.done-20:
	; AssignStmt
	%106 = load i64, i64* %13, align 8
	%107 = zext i64 %106 to i128
	store i128 %107, i128* %7
	br label %switch.done-25

switch.case.next-21:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$b9, i32 0, i32 0), i64 57}, i64 948, i64 9, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$ba, i32 0, i32 0), i64 11}, i64 9010547202582728236}, %runtime.Source_Code_Location* %15
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$bb, i32 0, i32 0), i64 21}, %runtime.Source_Code_Location* %15, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-25

switch.fall.body-22:
	; x
	; SelectorExpr
	%108 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%109 = load %..rawptr, %..rawptr* %108, align 8
	%110 = bitcast %..rawptr %109 to i128*
	%111 = getelementptr inbounds i128, i128* %110, i64 0
	%112 = load i128, i128* %111, align 8
	store i128 %112, i128* %14
	; IfStmt
	%113 = load i8, i8* %9, align 1
	%114 = trunc i8 %113 to i1
	br i1 %114, label %if.then-23, label %if.done-24

if.then-23:
	; AssignStmt
	%115 = load i128, i128* %14, align 8
	%116 = call i128 @llvm.bswap.i128(i128 %115)
	store i128 %116, i128* %14
	br label %if.done-24

if.done-24:
	; AssignStmt
	%117 = load i128, i128* %14, align 8
	store i128 %117, i128* %7
	br label %switch.done-25

switch.done-25:
	; et
	; SelectorExpr
	; SelectorExpr
	%118 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %6, i32 0, i32 0
	%119 = load %runtime.Type_Info*, %runtime.Type_Info** %118, align 8
	%120 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %119)
	store %runtime.Type_Info* %120, %runtime.Type_Info** %16
	; IfStmt
	%121 = load %..string, %..string* %2, align 8
	%122 = call i8 @runtime.string_ne(%..string %121, %..string zeroinitializer)
	%123 = trunc i8 %122 to i1
	br i1 %123, label %if.then-26, label %if.else-27

if.then-26:
	; SelectorExpr
	; SelectorExpr
	%124 = load %fmt.Info*, %fmt.Info** %0, align 8
	%125 = getelementptr inbounds %fmt.Info, %fmt.Info* %124, i32 0, i32 12
	%126 = load %strings.Builder*, %strings.Builder** %125, align 8
	%127 = load %..string, %..string* %2, align 8
	call void @strings.write_string(%strings.Builder* %126, %..string %127, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-28

if.else-27:
	; SelectorExpr
	; SelectorExpr
	%128 = load %fmt.Info*, %fmt.Info** %0, align 8
	%129 = getelementptr inbounds %fmt.Info, %fmt.Info* %128, i32 0, i32 12
	%130 = load %strings.Builder*, %strings.Builder** %129, align 8
	%131 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	call void @reflect.write_type(%strings.Builder* %130, %runtime.Type_Info* %131, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-28

if.done-28:
	; SelectorExpr
	; SelectorExpr
	%132 = load %fmt.Info*, %fmt.Info** %0, align 8
	%133 = getelementptr inbounds %fmt.Info, %fmt.Info* %132, i32 0, i32 12
	%134 = load %strings.Builder*, %strings.Builder** %133, align 8
	call void @strings.write_byte(%strings.Builder* %134, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; e
	; is_enum
	; SelectorExpr
	%135 = load %runtime.Type_Info*, %runtime.Type_Info** %16, align 8
	%136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %135, i32 0, i32 3
	; cast - union_cast
	%137 = bitcast {%runtime.Type_Info_Enum, i8}* %19 to %..rawptr
	; ZeroInit
	%138 = call %..rawptr @mem.zero(%..rawptr %137, i64 48)
	%139 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %136, i64 0, i32 2 ; UnionTagPtr
	%140 = load i64, i64* %139, align 8
	%141 = icmp eq i64 %140, 19
	br i1 %141, label %union_cast.ok-29, label %union_cast.end-30

union_cast.ok-29:
	%142 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %19, i32 0, i32 0
	%143 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %19, i32 0, i32 1
	%144 = bitcast {[0 x i64], [88 x i8], i64}* %136 to %runtime.Type_Info_Enum*
	%145 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %144, align 8
	store %runtime.Type_Info_Enum %145, %runtime.Type_Info_Enum* %142
	store i8 1, i8* %143
	br label %union_cast.end-30

union_cast.end-30:
	%146 = load {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %19, align 8
	%147 = extractvalue {%runtime.Type_Info_Enum, i8} %146, 0
	%148 = extractvalue {%runtime.Type_Info_Enum, i8} %146, 1
	store %runtime.Type_Info_Enum %147, %runtime.Type_Info_Enum* %17
	store i8 %148, i8* %18
	; commas
	store i64 0, i64* %20
	; RangeStmt
	; i
	; ZeroInit
	store i128 zeroinitializer, i128* %21, align 1
	store i128 0, i128* %22
	store i64 0, i64* %23
	br label %for.interval.loop-31

for.interval.loop-31:
	%149 = load i128, i128* %8, align 8
	%150 = load i128, i128* %22, align 8
	%151 = icmp ult i128 %150, %149
	br i1 %151, label %for.interval.body-32, label %for.interval.done-44

for.interval.body-32:
	%152 = load i128, i128* %22, align 8
	%153 = load i128, i128* %22, align 8
	%154 = add i128 %153, 1
	store i128 %154, i128* %22
	%155 = load i64, i64* %23, align 8
	%156 = add i64 %155, 1
	store i64 %156, i64* %23
	store i128 %152, i128* %21
	; IfStmt
	%157 = load i128, i128* %7, align 8
	%158 = load i128, i128* %21, align 8
	%159 = shl i128 1, %158
	%160 = and i128 %157, %159
	%161 = icmp eq i128 %160, 0
	%162 = zext i1 %161 to i8
	%163 = trunc i8 %162 to i1
	br i1 %163, label %if.then-33, label %if.done-34

if.then-33:
	; continue
	br label %for.interval.loop-31

if.done-34:
	; IfStmt
	%164 = load i64, i64* %20, align 8
	%165 = icmp sgt i64 %164, 0
	%166 = zext i1 %165 to i8
	%167 = trunc i8 %166 to i1
	br i1 %167, label %if.then-35, label %if.done-36

if.then-35:
	; SelectorExpr
	; SelectorExpr
	%168 = load %fmt.Info*, %fmt.Info** %0, align 8
	%169 = getelementptr inbounds %fmt.Info, %fmt.Info* %168, i32 0, i32 12
	%170 = load %strings.Builder*, %strings.Builder** %169, align 8
	call void @strings.write_string(%strings.Builder* %170, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$bc, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-36

if.done-36:
	; IfStmt
	%171 = load i8, i8* %18, align 1
	%172 = trunc i8 %171 to i1
	br i1 %172, label %if.then-37, label %if.done-43

if.then-37:
	; RangeStmt
	; ev
	; ZeroInit
	store %runtime.Type_Info_Enum_Value zeroinitializer, %runtime.Type_Info_Enum_Value* %24, align 1
	; evi
	; ZeroInit
	store i64 zeroinitializer, i64* %25, align 1
	; SelectorExpr
	%173 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %17, i32 0, i32 2
	%174 = load {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %173, align 8
	%175 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %174, 1
	store i64 %175, i64* %26
	store i64 -1, i64* %27
	br label %for.index.loop-38

for.index.loop-38:
	%176 = load i64, i64* %27, align 8
	%177 = add i64 %176, 1
	store i64 %177, i64* %27
	%178 = load i64, i64* %26, align 8
	%179 = icmp slt i64 %177, %178
	br i1 %179, label %for.index.body-39, label %for.index.done-42

for.index.body-39:
	%180 = load i64, i64* %27, align 8
	%181 = extractvalue {%runtime.Type_Info_Enum_Value*, i64} %174, 0
	%182 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %181, i64 %180
	%183 = load %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %182, align 8
	store %runtime.Type_Info_Enum_Value %183, %runtime.Type_Info_Enum_Value* %24
	store i64 %180, i64* %25
	; v
	%184 = call i64 @fmt.enum_value_to_u64(%runtime.Type_Info_Enum_Value* %24, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store i64 %184, i64* %28
	; IfStmt
	%185 = load i64, i64* %28, align 8
	%186 = load i128, i128* %21, align 8
	%187 = trunc i128 %186 to i64
	%188 = icmp eq i64 %185, %187
	%189 = zext i1 %188 to i8
	%190 = trunc i8 %189 to i1
	br i1 %190, label %if.then-40, label %if.done-41

if.then-40:
	; SelectorExpr
	; SelectorExpr
	%191 = load %fmt.Info*, %fmt.Info** %0, align 8
	%192 = getelementptr inbounds %fmt.Info, %fmt.Info* %191, i32 0, i32 12
	%193 = load %strings.Builder*, %strings.Builder** %192, align 8
	; IndexExpr
	; SelectorExpr
	%194 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %17, i32 0, i32 1
	%195 = load {%..string*, i64}, {%..string*, i64}* %194, align 8
	%196 = extractvalue {%..string*, i64} %195, 0
	%197 = load i64, i64* %25, align 8
	%198 = extractvalue {%..string*, i64} %195, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$bd, i32 0, i32 0), i64 57}, i64 973, i64 43, i64 %197, i64 %198)
	%199 = getelementptr inbounds %..string, %..string* %196, i64 %197
	%200 = load %..string, %..string* %199, align 8
	call void @strings.write_string(%strings.Builder* %193, %..string %200, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%201 = load i64, i64* %20, align 8
	%202 = add i64 %201, 1
	store i64 %202, i64* %20
	; continue
	br label %for.interval.loop-31

if.done-41:
	br label %for.index.loop-38

for.index.done-42:
	br label %if.done-43

if.done-43:
	; SelectorExpr
	; SelectorExpr
	%203 = load %fmt.Info*, %fmt.Info** %0, align 8
	%204 = getelementptr inbounds %fmt.Info, %fmt.Info* %203, i32 0, i32 12
	%205 = load %strings.Builder*, %strings.Builder** %204, align 8
	%206 = load i128, i128* %21, align 8
	%207 = trunc i128 %206 to i64
	call void @strings.write_i64(%strings.Builder* %205, i64 %207, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%208 = load i64, i64* %20, align 8
	%209 = add i64 %208, 1
	store i64 %209, i64* %20
	br label %for.interval.loop-31

for.interval.done-44:
	; defer
	; SelectorExpr
	; SelectorExpr
	%210 = load %fmt.Info*, %fmt.Info** %0, align 8
	%211 = getelementptr inbounds %fmt.Info, %fmt.Info* %210, i32 0, i32 12
	%212 = load %strings.Builder*, %strings.Builder** %211, align 8
	call void @strings.write_byte(%strings.Builder* %212, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-45

typeswitch.done-45:
	ret void
}

define i8 @fmt.fmt_bit_set.is_bit_set_different_endian_to_platform-0(%runtime.Type_Info* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Integer, align 16
	store %runtime.Type_Info* %_.0, %runtime.Type_Info** %0
	; IfStmt
	%3 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%4 = icmp eq %runtime.Type_Info* %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; t
	; SelectorExpr
	%7 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%8 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %7)
	store %runtime.Type_Info* %8, %runtime.Type_Info** %1
	; TypeSwitchStmt
	; SelectorExpr
	%9 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%10 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %9, i32 0, i32 3
	; get union's tag
	%11 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %10, i64 0, i32 2 ; UnionTagPtr
	%12 = load i64, i64* %11, align 8
	%13 = bitcast {[0 x i64], [88 x i8], i64}* %10 to %..rawptr
	%14 = icmp eq i64 %12, 2
	br i1 %14, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	br label %typeswitch.done-11

typeswitch.body-4:
	%15 = bitcast %..rawptr %13 to %runtime.Type_Info_Integer*
	%16 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %15, align 1
	store %runtime.Type_Info_Integer %16, %runtime.Type_Info_Integer* %2
	; SwitchStmt
	; SelectorExpr
	%17 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2, i32 0, i32 1
	%18 = load i8, i8* %17, align 1
	%19 = icmp eq i8 %18, 0
	br i1 %19, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%20 = icmp eq i8 %18, 1
	br i1 %20, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; ReturnStmt
	ret i8 0

switch.case.next-7:
	%21 = icmp eq i8 %18, 2
	br i1 %21, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; ReturnStmt
	ret i8 0

switch.case.next-9:
	br label %typeswitch.done-11

switch.fall.body-10:
	; ReturnStmt
	ret i8 1

typeswitch.done-11:
	; ReturnStmt
	ret i8 0
}

define void @fmt.fmt_bit_field(%fmt.Info* %_.0, %..any %_.1, %..string %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %..string, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %..any, align 16
	%6 = alloca %runtime.Type_Info_Bit_Field, align 16
	%7 = alloca i64, align 16
	%8 = alloca %..string, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i64, align 16
	%16 = alloca i64, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..any %_.1, %..any* %1
	store %..string %_.2, %..string* %2
	; type_info
	; SelectorExpr
	%17 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%18 = load %..typeid, %..typeid* %17, align 8
	%19 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %18)
	store %runtime.Type_Info* %19, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%20 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%21 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %20, i32 0, i32 3
	; get union's tag
	%22 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %21, i64 0, i32 2 ; UnionTagPtr
	%23 = load i64, i64* %22, align 8
	%24 = bitcast {[0 x i64], [88 x i8], i64}* %21 to %..rawptr
	%25 = icmp eq i64 %23, 1
	br i1 %25, label %typeswitch.body-2, label %typeswitch.next-1

typeswitch.next-1:
	%26 = icmp eq i64 %23, 21
	br i1 %26, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.body-2:
	%27 = bitcast %..rawptr %24 to %runtime.Type_Info_Named*
	%28 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %27, align 8
	store %runtime.Type_Info_Named %28, %runtime.Type_Info_Named* %4
	; val
	%29 = load %..any, %..any* %1, align 8
	store %..any %29, %..any* %5
	; AssignStmt
	; SelectorExpr
	%30 = getelementptr inbounds %..any, %..any* %5, i32 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%31 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 1
	%32 = load %runtime.Type_Info*, %runtime.Type_Info** %31, align 8
	%33 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %32, i32 0, i32 2
	%34 = load %..typeid, %..typeid* %33, align 8
	store %..typeid %34, %..typeid* %30
	%35 = load %fmt.Info*, %fmt.Info** %0, align 8
	%36 = load %..any, %..any* %5, align 8
	; SelectorExpr
	%37 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 0
	%38 = load %..string, %..string* %37, align 8
	call void @fmt.fmt_bit_field(%fmt.Info* %35, %..any %36, %..string %38, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.next-3:
	br label %typeswitch.done-22

typeswitch.body-4:
	%39 = bitcast %..rawptr %24 to %runtime.Type_Info_Bit_Field*
	%40 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %39, align 8
	store %runtime.Type_Info_Bit_Field %40, %runtime.Type_Info_Bit_Field* %6
	; data
	store i64 0, i64* %7
	; SwitchStmt
	; SelectorExpr
	%41 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%42 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %41, i32 0, i32 0
	%43 = load i64, i64* %42, align 8
	%44 = icmp eq i64 %43, 1
	br i1 %44, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%45 = icmp eq i64 %43, 2
	br i1 %45, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; AssignStmt
	; SelectorExpr
	%46 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%47 = load %..rawptr, %..rawptr* %46, align 8
	%48 = bitcast %..rawptr %47 to i8*
	%49 = getelementptr inbounds i8, i8* %48, i64 0
	%50 = load i8, i8* %49, align 1
	%51 = zext i8 %50 to i64
	store i64 %51, i64* %7
	br label %switch.done-13

switch.case.next-7:
	%52 = icmp eq i64 %43, 4
	br i1 %52, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	; AssignStmt
	; SelectorExpr
	%53 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%54 = load %..rawptr, %..rawptr* %53, align 8
	%55 = bitcast %..rawptr %54 to i16*
	%56 = getelementptr inbounds i16, i16* %55, i64 0
	%57 = load i16, i16* %56, align 2
	%58 = zext i16 %57 to i64
	store i64 %58, i64* %7
	br label %switch.done-13

switch.case.next-9:
	%59 = icmp eq i64 %43, 8
	br i1 %59, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	; AssignStmt
	; SelectorExpr
	%60 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%61 = load %..rawptr, %..rawptr* %60, align 8
	%62 = bitcast %..rawptr %61 to i32*
	%63 = getelementptr inbounds i32, i32* %62, i64 0
	%64 = load i32, i32* %63, align 4
	%65 = zext i32 %64 to i64
	store i64 %65, i64* %7
	br label %switch.done-13

switch.case.next-11:
	br label %switch.done-13

switch.fall.body-12:
	; AssignStmt
	; SelectorExpr
	%66 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%67 = load %..rawptr, %..rawptr* %66, align 8
	%68 = bitcast %..rawptr %67 to i64*
	%69 = getelementptr inbounds i64, i64* %68, i64 0
	%70 = load i64, i64* %69, align 8
	store i64 %70, i64* %7
	br label %switch.done-13

switch.done-13:
	; IfStmt
	%71 = load %..string, %..string* %2, align 8
	%72 = call i8 @runtime.string_ne(%..string %71, %..string zeroinitializer)
	%73 = trunc i8 %72 to i1
	br i1 %73, label %if.then-14, label %if.else-15

if.then-14:
	; SelectorExpr
	; SelectorExpr
	%74 = load %fmt.Info*, %fmt.Info** %0, align 8
	%75 = getelementptr inbounds %fmt.Info, %fmt.Info* %74, i32 0, i32 12
	%76 = load %strings.Builder*, %strings.Builder** %75, align 8
	%77 = load %..string, %..string* %2, align 8
	call void @strings.write_string(%strings.Builder* %76, %..string %77, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%78 = load %fmt.Info*, %fmt.Info** %0, align 8
	%79 = getelementptr inbounds %fmt.Info, %fmt.Info* %78, i32 0, i32 12
	%80 = load %strings.Builder*, %strings.Builder** %79, align 8
	call void @strings.write_byte(%strings.Builder* %80, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-16

if.else-15:
	; SelectorExpr
	; SelectorExpr
	%81 = load %fmt.Info*, %fmt.Info** %0, align 8
	%82 = getelementptr inbounds %fmt.Info, %fmt.Info* %81, i32 0, i32 12
	%83 = load %strings.Builder*, %strings.Builder** %82, align 8
	call void @strings.write_string(%strings.Builder* %83, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$be, i32 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-16

if.done-16:
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %8, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %9, align 1
	; SelectorExpr
	%84 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i32 0, i32 0
	%85 = load {%..string*, i64}, {%..string*, i64}* %84, align 8
	%86 = extractvalue {%..string*, i64} %85, 1
	store i64 %86, i64* %10
	store i64 -1, i64* %11
	br label %for.index.loop-17

for.index.loop-17:
	%87 = load i64, i64* %11, align 8
	%88 = add i64 %87, 1
	store i64 %88, i64* %11
	%89 = load i64, i64* %10, align 8
	%90 = icmp slt i64 %88, %89
	br i1 %90, label %for.index.body-18, label %for.index.done-21

for.index.body-18:
	%91 = load i64, i64* %11, align 8
	%92 = extractvalue {%..string*, i64} %85, 0
	%93 = getelementptr inbounds %..string, %..string* %92, i64 %91
	%94 = load %..string, %..string* %93, align 8
	store %..string %94, %..string* %8
	store i64 %91, i64* %9
	; IfStmt
	%95 = load i64, i64* %9, align 8
	%96 = icmp sgt i64 %95, 0
	%97 = zext i1 %96 to i8
	%98 = trunc i8 %97 to i1
	br i1 %98, label %if.then-19, label %if.done-20

if.then-19:
	; SelectorExpr
	; SelectorExpr
	%99 = load %fmt.Info*, %fmt.Info** %0, align 8
	%100 = getelementptr inbounds %fmt.Info, %fmt.Info* %99, i32 0, i32 12
	%101 = load %strings.Builder*, %strings.Builder** %100, align 8
	call void @strings.write_string(%strings.Builder* %101, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$bf, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-20

if.done-20:
	; bits
	; IndexExpr
	; SelectorExpr
	%102 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i32 0, i32 1
	%103 = load {i32*, i64}, {i32*, i64}* %102, align 8
	%104 = extractvalue {i32*, i64} %103, 0
	%105 = load i64, i64* %9, align 8
	%106 = extractvalue {i32*, i64} %103, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$c0, i32 0, i32 0), i64 57}, i64 1009, i64 26, i64 %105, i64 %106)
	%107 = getelementptr inbounds i32, i32* %104, i64 %105
	%108 = load i32, i32* %107, align 4
	%109 = sext i32 %108 to i64
	store i64 %109, i64* %12
	; offset
	; IndexExpr
	; SelectorExpr
	%110 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %6, i32 0, i32 2
	%111 = load {i32*, i64}, {i32*, i64}* %110, align 8
	%112 = extractvalue {i32*, i64} %111, 0
	%113 = load i64, i64* %9, align 8
	%114 = extractvalue {i32*, i64} %111, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$c1, i32 0, i32 0), i64 57}, i64 1010, i64 31, i64 %113, i64 %114)
	%115 = getelementptr inbounds i32, i32* %112, i64 %113
	%116 = load i32, i32* %115, align 4
	%117 = sext i32 %116 to i64
	store i64 %117, i64* %13
	; SelectorExpr
	; SelectorExpr
	%118 = load %fmt.Info*, %fmt.Info** %0, align 8
	%119 = getelementptr inbounds %fmt.Info, %fmt.Info* %118, i32 0, i32 12
	%120 = load %strings.Builder*, %strings.Builder** %119, align 8
	%121 = load %..string, %..string* %8, align 8
	call void @strings.write_string(%strings.Builder* %120, %..string %121, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%122 = load %fmt.Info*, %fmt.Info** %0, align 8
	%123 = getelementptr inbounds %fmt.Info, %fmt.Info* %122, i32 0, i32 12
	%124 = load %strings.Builder*, %strings.Builder** %123, align 8
	call void @strings.write_string(%strings.Builder* %124, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$c2, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; n
	store i64 64, i64* %14
	; sa
	%125 = load i64, i64* %14, align 8
	%126 = load i64, i64* %12, align 8
	%127 = sub i64 %125, %126
	store i64 %127, i64* %15
	; u
	%128 = load i64, i64* %7, align 8
	%129 = load i64, i64* %13, align 8
	%130 = lshr i64 %128, %129
	store i64 %130, i64* %16
	; AssignStmt
	%131 = load i64, i64* %15, align 8
	%132 = load i64, i64* %16, align 8
	%133 = shl i64 %132, %131
	store i64 %133, i64* %16
	; AssignStmt
	%134 = load i64, i64* %15, align 8
	%135 = load i64, i64* %16, align 8
	%136 = lshr i64 %135, %134
	store i64 %136, i64* %16
	; SelectorExpr
	; SelectorExpr
	%137 = load %fmt.Info*, %fmt.Info** %0, align 8
	%138 = getelementptr inbounds %fmt.Info, %fmt.Info* %137, i32 0, i32 12
	%139 = load %strings.Builder*, %strings.Builder** %138, align 8
	%140 = load i64, i64* %16, align 8
	call void @strings.write_u64(%strings.Builder* %139, i64 %140, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-17

for.index.done-21:
	; SelectorExpr
	; SelectorExpr
	%141 = load %fmt.Info*, %fmt.Info** %0, align 8
	%142 = getelementptr inbounds %fmt.Info, %fmt.Info* %141, i32 0, i32 12
	%143 = load %strings.Builder*, %strings.Builder** %142, align 8
	call void @strings.write_byte(%strings.Builder* %143, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-22

typeswitch.done-22:
	ret void
}

define void @fmt.fmt_opaque(%fmt.Info* %_.0, %..any %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca %runtime.Type_Info_Opaque, align 16
	%4 = alloca i8, align 16
	%5 = alloca %runtime.Type_Info*, align 16
	%6 = alloca {%runtime.Type_Info_Opaque, i8}, align 16
	%7 = alloca %runtime.Type_Info*, align 16
	%8 = alloca {[0 x i64], [88 x i8], i64}, align 16
	%9 = alloca %..any, align 16
	%10 = alloca {[0 x i64], [88 x i8], i64}, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..any %_.1, %..any* %1
	; type_info
	; SelectorExpr
	%11 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%12 = load %..typeid, %..typeid* %11, align 8
	%13 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %12)
	store %runtime.Type_Info* %13, %runtime.Type_Info** %2
	; IfStmt
	; SelectorExpr
	%14 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%15 = load %..rawptr, %..rawptr* %14, align 8
	; SelectorExpr
	%16 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%17 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %16, i32 0, i32 0
	%18 = load i64, i64* %17, align 8
	%19 = call i8 @fmt.fmt_opaque.is_nil-0(%..rawptr %15, i64 %18, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	; SelectorExpr
	%21 = load %fmt.Info*, %fmt.Info** %0, align 8
	%22 = getelementptr inbounds %fmt.Info, %fmt.Info* %21, i32 0, i32 12
	%23 = load %strings.Builder*, %strings.Builder** %22, align 8
	call void @strings.write_string(%strings.Builder* %23, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$c3, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; IfStmt
	; ot
	; ok
	; SelectorExpr
	; SelectorExpr
	%24 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%25 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %24)
	store %runtime.Type_Info* %25, %runtime.Type_Info** %5
	%26 = load %runtime.Type_Info*, %runtime.Type_Info** %5, align 8
	%27 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %26, i32 0, i32 3
	; cast - union_cast
	; ZeroInit
	store {%runtime.Type_Info_Opaque, i8} zeroinitializer, {%runtime.Type_Info_Opaque, i8}* %6, align 1
	%28 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %27, i64 0, i32 2 ; UnionTagPtr
	%29 = load i64, i64* %28, align 8
	%30 = icmp eq i64 %29, 23
	br i1 %30, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%31 = getelementptr inbounds {%runtime.Type_Info_Opaque, i8}, {%runtime.Type_Info_Opaque, i8}* %6, i32 0, i32 0
	%32 = getelementptr inbounds {%runtime.Type_Info_Opaque, i8}, {%runtime.Type_Info_Opaque, i8}* %6, i32 0, i32 1
	%33 = bitcast {[0 x i64], [88 x i8], i64}* %27 to %runtime.Type_Info_Opaque*
	%34 = load %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %33, align 8
	store %runtime.Type_Info_Opaque %34, %runtime.Type_Info_Opaque* %31
	store i8 1, i8* %32
	br label %union_cast.end-4

union_cast.end-4:
	%35 = load {%runtime.Type_Info_Opaque, i8}, {%runtime.Type_Info_Opaque, i8}* %6, align 8
	%36 = extractvalue {%runtime.Type_Info_Opaque, i8} %35, 0
	%37 = extractvalue {%runtime.Type_Info_Opaque, i8} %35, 1
	store %runtime.Type_Info_Opaque %36, %runtime.Type_Info_Opaque* %3
	store i8 %37, i8* %4
	%38 = load i8, i8* %4, align 1
	%39 = trunc i8 %38 to i1
	br i1 %39, label %if.then-5, label %if.else-13

if.then-5:
	; elem
	; SelectorExpr
	; SelectorExpr
	%40 = getelementptr inbounds %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %3, i32 0, i32 0
	%41 = load %runtime.Type_Info*, %runtime.Type_Info** %40, align 8
	%42 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %41)
	store %runtime.Type_Info* %42, %runtime.Type_Info** %7
	; IfStmt
	%43 = load %runtime.Type_Info*, %runtime.Type_Info** %7, align 8
	%44 = icmp eq %runtime.Type_Info* %43, zeroinitializer
	%45 = zext i1 %44 to i8
	%46 = trunc i8 %45 to i1
	br i1 %46, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret void

if.done-7:
	; SelectorExpr
	; SelectorExpr
	%47 = load %fmt.Info*, %fmt.Info** %0, align 8
	%48 = getelementptr inbounds %fmt.Info, %fmt.Info* %47, i32 0, i32 12
	%49 = load %strings.Builder*, %strings.Builder** %48, align 8
	%50 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	call void @reflect.write_type(%strings.Builder* %49, %runtime.Type_Info* %50, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%51 = load %fmt.Info*, %fmt.Info** %0, align 8
	%52 = getelementptr inbounds %fmt.Info, %fmt.Info* %51, i32 0, i32 12
	%53 = load %strings.Builder*, %strings.Builder** %52, align 8
	call void @strings.write_byte(%strings.Builder* %53, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; TypeSwitchStmt
	; SelectorExpr
	%54 = load %runtime.Type_Info*, %runtime.Type_Info** %7, align 8
	%55 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %54, i32 0, i32 3
	%56 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %55, align 8
	; get union's tag
	%57 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %55, i64 0, i32 2 ; UnionTagPtr
	%58 = load i64, i64* %57, align 8
	%59 = bitcast {[0 x i64], [88 x i8], i64}* %55 to %..rawptr
	%60 = icmp eq i64 %58, 2
	br i1 %60, label %typeswitch.body-11, label %typeswitch.next-8

typeswitch.next-8:
	%61 = icmp eq i64 %58, 11
	br i1 %61, label %typeswitch.body-11, label %typeswitch.next-9

typeswitch.next-9:
	%62 = icmp eq i64 %58, 4
	br i1 %62, label %typeswitch.body-11, label %typeswitch.next-10

typeswitch.next-10:
	store {[0 x i64], [88 x i8], i64} %56, {[0 x i64], [88 x i8], i64}* %10
	br label %typeswitch.done-12

typeswitch.body-11:
	store {[0 x i64], [88 x i8], i64} %56, {[0 x i64], [88 x i8], i64}* %8
	%63 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %9, align 1
	store %..any zeroinitializer, %..any* %9
	; SelectorExpr
	%64 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%65 = load %..rawptr, %..rawptr* %64, align 8
	%66 = getelementptr inbounds %..any, %..any* %9, i32 0, i32 0
	store %..rawptr %65, %..rawptr* %66
	; SelectorExpr
	%67 = load %runtime.Type_Info*, %runtime.Type_Info** %7, align 8
	%68 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %67, i32 0, i32 2
	%69 = load %..typeid, %..typeid* %68, align 8
	%70 = getelementptr inbounds %..any, %..any* %9, i32 0, i32 1
	store %..typeid %69, %..typeid* %70
	%71 = load %..any, %..any* %9, align 8
	call void @fmt.fmt_value(%fmt.Info* %63, %..any %71, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-12

typeswitch.done-12:
	; defer
	; SelectorExpr
	; SelectorExpr
	%72 = load %fmt.Info*, %fmt.Info** %0, align 8
	%73 = getelementptr inbounds %fmt.Info, %fmt.Info* %72, i32 0, i32 12
	%74 = load %strings.Builder*, %strings.Builder** %73, align 8
	call void @strings.write_byte(%strings.Builder* %74, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-14

if.else-13:
	; SelectorExpr
	; SelectorExpr
	%75 = load %fmt.Info*, %fmt.Info** %0, align 8
	%76 = getelementptr inbounds %fmt.Info, %fmt.Info* %75, i32 0, i32 12
	%77 = load %strings.Builder*, %strings.Builder** %76, align 8
	%78 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	call void @reflect.write_type(%strings.Builder* %77, %runtime.Type_Info* %78, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%79 = load %fmt.Info*, %fmt.Info** %0, align 8
	%80 = getelementptr inbounds %fmt.Info, %fmt.Info* %79, i32 0, i32 12
	%81 = load %strings.Builder*, %strings.Builder** %80, align 8
	call void @strings.write_byte(%strings.Builder* %81, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%82 = load %fmt.Info*, %fmt.Info** %0, align 8
	%83 = getelementptr inbounds %fmt.Info, %fmt.Info* %82, i32 0, i32 12
	%84 = load %strings.Builder*, %strings.Builder** %83, align 8
	call void @strings.write_byte(%strings.Builder* %84, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-14

if.done-14:
	ret void
}

define i8 @fmt.fmt_opaque.is_nil-0(%..rawptr %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8*, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i64 %_.1, i64* %1
	; IfStmt
	%6 = load %..rawptr, %..rawptr* %0, align 8
	%7 = icmp eq %..rawptr %6, zeroinitializer
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 1

if.done-2:
	; IfStmt
	%10 = load i64, i64* %1, align 8
	%11 = icmp eq i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; a
	%14 = load %..rawptr, %..rawptr* %0, align 8
	%15 = bitcast %..rawptr %14 to i8*
	store i8* %15, i8** %2
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %3, align 1
	store i64 0, i64* %4
	store i64 0, i64* %5
	br label %for.interval.loop-5

for.interval.loop-5:
	%16 = load i64, i64* %1, align 8
	%17 = load i64, i64* %4, align 8
	%18 = icmp slt i64 %17, %16
	br i1 %18, label %for.interval.body-6, label %for.interval.done-9

for.interval.body-6:
	%19 = load i64, i64* %4, align 8
	%20 = load i64, i64* %4, align 8
	%21 = add i64 %20, 1
	store i64 %21, i64* %4
	%22 = load i64, i64* %5, align 8
	%23 = add i64 %22, 1
	store i64 %23, i64* %5
	store i64 %19, i64* %3
	; IfStmt
	; SelectorExpr
	%24 = load i8*, i8** %2, align 8
	%25 = load i64, i64* %3, align 8
	%26 = call i8* @mem.ptr_offset-5849(i8* %24, i64 %25)
	%27 = getelementptr inbounds i8, i8* %26, i64 0
	%28 = load i8, i8* %27, align 1
	%29 = icmp ne i8 %28, 0
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	br label %for.interval.loop-5

for.interval.done-9:
	; ReturnStmt
	ret i8 1
}

define void @fmt.fmt_value(%fmt.Info* %_.0, %..any %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info_Named, align 16
	%5 = alloca %runtime.Type_Info_Struct, align 16
	%6 = alloca i8, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca %..string, align 16
	%10 = alloca i64, align 16
	%11 = alloca i64, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca %runtime.Type_Info*, align 16
	%16 = alloca %..rawptr, align 16
	%17 = alloca %..any, align 16
	%18 = alloca i64, align 16
	%19 = alloca i64, align 16
	%20 = alloca %runtime.Type_Info_Bit_Set, align 16
	%21 = alloca %runtime.Type_Info_Bit_Field, align 16
	%22 = alloca %runtime.Type_Info_Opaque, align 16
	%23 = alloca {[0 x i64], [88 x i8], i64}, align 16
	%24 = alloca %..any, align 16
	%25 = alloca %runtime.Type_Info_Boolean, align 16
	%26 = alloca %runtime.Type_Info_Integer, align 16
	%27 = alloca %runtime.Type_Info_Rune, align 16
	%28 = alloca %runtime.Type_Info_Float, align 16
	%29 = alloca %runtime.Type_Info_Complex, align 16
	%30 = alloca %runtime.Type_Info_Quaternion, align 16
	%31 = alloca %runtime.Type_Info_String, align 16
	%32 = alloca %runtime.Type_Info_Pointer, align 16
	%33 = alloca %..rawptr, align 16
	%34 = alloca %..any, align 16
	%35 = alloca %..any, align 16
	%36 = alloca %runtime.Type_Info*, align 16
	%37 = alloca {[0 x i64], [88 x i8], i64}, align 16
	%38 = alloca {[0 x i64], [88 x i8], i64}, align 16
	%39 = alloca %runtime.Type_Info_Array, align 16
	%40 = alloca i64, align 16
	%41 = alloca i64, align 16
	%42 = alloca i64, align 16
	%43 = alloca i64, align 16
	%44 = alloca %..any, align 16
	%45 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%46 = alloca %mem.Raw_Dynamic_Array*, align 16
	%47 = alloca %mem.Raw_Dynamic_Array*, align 16
	%48 = alloca i64, align 16
	%49 = alloca i64, align 16
	%50 = alloca i64, align 16
	%51 = alloca i64, align 16
	%52 = alloca %..any, align 16
	%53 = alloca %runtime.Type_Info_Simd_Vector, align 16
	%54 = alloca i64, align 16
	%55 = alloca i64, align 16
	%56 = alloca i64, align 16
	%57 = alloca i64, align 16
	%58 = alloca %..any, align 16
	%59 = alloca %runtime.Type_Info_Slice, align 16
	%60 = alloca %mem.Raw_Slice*, align 16
	%61 = alloca %mem.Raw_Slice*, align 16
	%62 = alloca i64, align 16
	%63 = alloca i64, align 16
	%64 = alloca i64, align 16
	%65 = alloca i64, align 16
	%66 = alloca %..any, align 16
	%67 = alloca %runtime.Type_Info_Map, align 16
	%68 = alloca %mem.Raw_Map*, align 16
	%69 = alloca %mem.Raw_Dynamic_Array*, align 16
	%70 = alloca %runtime.Type_Info_Struct, align 16
	%71 = alloca %runtime.Type_Info*, align 16
	%72 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%73 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%74 = alloca %runtime.Type_Info*, align 16
	%75 = alloca {%runtime.Type_Info_Dynamic_Array, i8}, align 16
	%76 = alloca %runtime.Type_Info_Struct, align 16
	%77 = alloca {%runtime.Type_Info_Struct, i8}, align 16
	%78 = alloca i64, align 16
	%79 = alloca i64, align 16
	%80 = alloca i64, align 16
	%81 = alloca i64, align 16
	%82 = alloca i64, align 16
	%83 = alloca %runtime.Map_Entry_Header*, align 16
	%84 = alloca %fmt.Info, align 16
	%85 = alloca %fmt.Info, align 16
	%86 = alloca %..any, align 16
	%87 = alloca i64, align 16
	%88 = alloca %..any, align 16
	%89 = alloca %runtime.Type_Info_Struct, align 16
	%90 = alloca i8, align 16
	%91 = alloca i64, align 16
	%92 = alloca i64, align 16
	%93 = alloca i64, align 16
	%94 = alloca i64, align 16
	%95 = alloca i64, align 16
	%96 = alloca %runtime.Type_Info*, align 16
	%97 = alloca i64, align 16
	%98 = alloca %..any, align 16
	%99 = alloca %runtime.Type_Info_Union, align 16
	%100 = alloca i64, align 16
	%101 = alloca %..any, align 16
	%102 = alloca %..any, align 16
	%103 = alloca i64, align 16
	%104 = alloca i8, align 16
	%105 = alloca i8, align 16
	%106 = alloca i16, align 16
	%107 = alloca i16, align 16
	%108 = alloca i32, align 16
	%109 = alloca i32, align 16
	%110 = alloca i64, align 16
	%111 = alloca i64, align 16
	%112 = alloca %..any, align 16
	%113 = alloca %runtime.Source_Code_Location, align 16
	%114 = alloca %runtime.Source_Code_Location, align 16
	%115 = alloca %..typeid, align 16
	%116 = alloca %..any, align 16
	%117 = alloca %..typeid, align 16
	%118 = alloca %..any, align 16
	%119 = alloca %runtime.Type_Info_Enum, align 16
	%120 = alloca %runtime.Type_Info_Procedure, align 16
	%121 = alloca %..rawptr, align 16
	%122 = alloca %runtime.Type_Info_Type_Id, align 16
	%123 = alloca %..typeid, align 16
	%124 = alloca %runtime.Type_Info_Bit_Field, align 16
	%125 = alloca %runtime.Type_Info_Bit_Set, align 16
	%126 = alloca %runtime.Type_Info_Opaque, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..any %_.1, %..any* %1
	store i32 %_.2, i32* %2
	; IfStmt
	; SelectorExpr
	%127 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%128 = load %..rawptr, %..rawptr* %127, align 8
	%129 = icmp eq %..rawptr %128, zeroinitializer
	%130 = zext i1 %129 to i8
	%131 = trunc i8 %130 to i1
	br i1 %131, label %if.then-2, label %cmp.or-1

cmp.or-1:
	; SelectorExpr
	%132 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%133 = load %..typeid, %..typeid* %132, align 8
	%134 = icmp eq %..typeid %133, 0
	%135 = zext i1 %134 to i8
	%136 = trunc i8 %135 to i1
	br i1 %136, label %if.then-2, label %if.done-3

if.then-2:
	; SelectorExpr
	; SelectorExpr
	%137 = load %fmt.Info*, %fmt.Info** %0, align 8
	%138 = getelementptr inbounds %fmt.Info, %fmt.Info* %137, i32 0, i32 12
	%139 = load %strings.Builder*, %strings.Builder** %138, align 8
	call void @strings.write_string(%strings.Builder* %139, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$c4, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-3:
	; type_info
	; SelectorExpr
	%140 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%141 = load %..typeid, %..typeid* %140, align 8
	%142 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %141)
	store %runtime.Type_Info* %142, %runtime.Type_Info** %3
	; TypeSwitchStmt
	; SelectorExpr
	%143 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %143, i32 0, i32 3
	; get union's tag
	%145 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %144, i64 0, i32 2 ; UnionTagPtr
	%146 = load i64, i64* %145, align 8
	%147 = bitcast {[0 x i64], [88 x i8], i64}* %144 to %..rawptr
	%148 = icmp eq i64 %146, 1
	br i1 %148, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	%149 = icmp eq i64 %146, 8
	br i1 %149, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-5:
	%150 = bitcast %..rawptr %147 to %runtime.Type_Info_Named*
	%151 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %150, align 8
	store %runtime.Type_Info_Named %151, %runtime.Type_Info_Named* %4
	; TypeSwitchStmt
	; SelectorExpr
	; SelectorExpr
	%152 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 1
	%153 = load %runtime.Type_Info*, %runtime.Type_Info** %152, align 8
	%154 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %153, i32 0, i32 3
	%155 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %154, align 8
	; get union's tag
	%156 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %154, i64 0, i32 2 ; UnionTagPtr
	%157 = load i64, i64* %156, align 8
	%158 = bitcast {[0 x i64], [88 x i8], i64}* %154 to %..rawptr
	%159 = icmp eq i64 %157, 17
	br i1 %159, label %typeswitch.body-7, label %typeswitch.next-6

typeswitch.next-6:
	%160 = icmp eq i64 %157, 22
	br i1 %160, label %typeswitch.body-36, label %typeswitch.next-35

typeswitch.body-7:
	%161 = bitcast %..rawptr %158 to %runtime.Type_Info_Struct*
	%162 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %161, align 8
	store %runtime.Type_Info_Struct %162, %runtime.Type_Info_Struct* %5
	; IfStmt
	%163 = load i32, i32* %2, align 4
	%164 = icmp ne i32 %163, 118
	%165 = zext i1 %164 to i8
	%166 = trunc i8 %165 to i1
	br i1 %166, label %if.then-8, label %if.done-9

if.then-8:
	%167 = load %fmt.Info*, %fmt.Info** %0, align 8
	%168 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %167, i32 %168, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-9:
	; IfStmt
	; SelectorExpr
	%169 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i32 0, i32 6
	%170 = load i8, i8* %169, align 1
	%171 = trunc i8 %170 to i1
	br i1 %171, label %if.then-10, label %if.done-11

if.then-10:
	; SelectorExpr
	; SelectorExpr
	%172 = load %fmt.Info*, %fmt.Info** %0, align 8
	%173 = getelementptr inbounds %fmt.Info, %fmt.Info* %172, i32 0, i32 12
	%174 = load %strings.Builder*, %strings.Builder** %173, align 8
	; SelectorExpr
	%175 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 0
	%176 = load %..string, %..string* %175, align 8
	call void @strings.write_string(%strings.Builder* %174, %..string %176, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%177 = load %fmt.Info*, %fmt.Info** %0, align 8
	%178 = getelementptr inbounds %fmt.Info, %fmt.Info* %177, i32 0, i32 12
	%179 = load %strings.Builder*, %strings.Builder** %178, align 8
	call void @strings.write_string(%strings.Builder* %179, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$c5, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-11:
	; SelectorExpr
	; SelectorExpr
	%180 = load %fmt.Info*, %fmt.Info** %0, align 8
	%181 = getelementptr inbounds %fmt.Info, %fmt.Info* %180, i32 0, i32 12
	%182 = load %strings.Builder*, %strings.Builder** %181, align 8
	; SelectorExpr
	%183 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 0
	%184 = load %..string, %..string* %183, align 8
	call void @strings.write_string(%strings.Builder* %182, %..string %184, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%185 = load %fmt.Info*, %fmt.Info** %0, align 8
	%186 = getelementptr inbounds %fmt.Info, %fmt.Info* %185, i32 0, i32 12
	%187 = load %strings.Builder*, %strings.Builder** %186, align 8
	call void @strings.write_byte(%strings.Builder* %187, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; hash
	; SelectorExpr
	%188 = load %fmt.Info*, %fmt.Info** %0, align 8
	%189 = getelementptr inbounds %fmt.Info, %fmt.Info* %188, i32 0, i32 4
	%190 = load i8, i8* %189, align 1
	store i8 %190, i8* %6
	; DeferStmt
	; indent
	; SelectorExpr
	%191 = load %fmt.Info*, %fmt.Info** %0, align 8
	%192 = getelementptr inbounds %fmt.Info, %fmt.Info* %191, i32 0, i32 9
	%193 = load i64, i64* %192, align 8
	store i64 %193, i64* %7
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%194 = load %fmt.Info*, %fmt.Info** %0, align 8
	%195 = getelementptr inbounds %fmt.Info, %fmt.Info* %194, i32 0, i32 4
	store i8 0, i8* %195
	; AssignStmt
	; SelectorExpr
	%196 = load %fmt.Info*, %fmt.Info** %0, align 8
	%197 = getelementptr inbounds %fmt.Info, %fmt.Info* %196, i32 0, i32 9
	%198 = load i64, i64* %197, align 8
	%199 = add i64 %198, 1
	store i64 %199, i64* %197
	; IfStmt
	%200 = load i8, i8* %6, align 1
	%201 = trunc i8 %200 to i1
	br i1 %201, label %if.then-12, label %if.done-13

if.then-12:
	; SelectorExpr
	; SelectorExpr
	%202 = load %fmt.Info*, %fmt.Info** %0, align 8
	%203 = getelementptr inbounds %fmt.Info, %fmt.Info* %202, i32 0, i32 12
	%204 = load %strings.Builder*, %strings.Builder** %203, align 8
	call void @strings.write_byte(%strings.Builder* %204, i8 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-13

if.done-13:
	; field_count
	store i64 -1, i64* %8
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %9, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %10, align 1
	; SelectorExpr
	%205 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i32 0, i32 1
	%206 = load {%..string*, i64}, {%..string*, i64}* %205, align 8
	%207 = extractvalue {%..string*, i64} %206, 1
	store i64 %207, i64* %11
	store i64 -1, i64* %12
	br label %for.index.loop-14

for.index.loop-14:
	%208 = load i64, i64* %12, align 8
	%209 = add i64 %208, 1
	store i64 %209, i64* %12
	%210 = load i64, i64* %11, align 8
	%211 = icmp slt i64 %209, %210
	br i1 %211, label %for.index.body-15, label %for.index.done-29

for.index.body-15:
	%212 = load i64, i64* %12, align 8
	%213 = extractvalue {%..string*, i64} %206, 0
	%214 = getelementptr inbounds %..string, %..string* %213, i64 %212
	%215 = load %..string, %..string* %214, align 8
	store %..string %215, %..string* %9
	store i64 %212, i64* %10
	; AssignStmt
	%216 = load i64, i64* %8, align 8
	%217 = add i64 %216, 1
	store i64 %217, i64* %8
	; IfStmt
	%218 = load i8, i8* %6, align 1
	%219 = trunc i8 %218 to i1
	br i1 %219, label %if.done-18, label %cmp.and-16

cmp.and-16:
	%220 = load i64, i64* %8, align 8
	%221 = icmp sgt i64 %220, 0
	%222 = zext i1 %221 to i8
	%223 = trunc i8 %222 to i1
	br i1 %223, label %if.then-17, label %if.done-18

if.then-17:
	; SelectorExpr
	; SelectorExpr
	%224 = load %fmt.Info*, %fmt.Info** %0, align 8
	%225 = getelementptr inbounds %fmt.Info, %fmt.Info* %224, i32 0, i32 12
	%226 = load %strings.Builder*, %strings.Builder** %225, align 8
	call void @strings.write_string(%strings.Builder* %226, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$c6, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-18

if.done-18:
	; IfStmt
	%227 = load i8, i8* %6, align 1
	%228 = trunc i8 %227 to i1
	br i1 %228, label %if.then-19, label %if.done-23

if.then-19:
	; RangeStmt
	store i64 0, i64* %13
	store i64 0, i64* %14
	br label %for.interval.loop-20

for.interval.loop-20:
	; SelectorExpr
	%229 = load %fmt.Info*, %fmt.Info** %0, align 8
	%230 = getelementptr inbounds %fmt.Info, %fmt.Info* %229, i32 0, i32 9
	%231 = load i64, i64* %230, align 8
	%232 = load i64, i64* %13, align 8
	%233 = icmp slt i64 %232, %231
	br i1 %233, label %for.interval.body-21, label %for.interval.done-22

for.interval.body-21:
	%234 = load i64, i64* %13, align 8
	%235 = add i64 %234, 1
	store i64 %235, i64* %13
	%236 = load i64, i64* %14, align 8
	%237 = add i64 %236, 1
	store i64 %237, i64* %14
	; SelectorExpr
	; SelectorExpr
	%238 = load %fmt.Info*, %fmt.Info** %0, align 8
	%239 = getelementptr inbounds %fmt.Info, %fmt.Info* %238, i32 0, i32 12
	%240 = load %strings.Builder*, %strings.Builder** %239, align 8
	call void @strings.write_byte(%strings.Builder* %240, i8 9, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-20

for.interval.done-22:
	br label %if.done-23

if.done-23:
	; SelectorExpr
	; SelectorExpr
	%241 = load %fmt.Info*, %fmt.Info** %0, align 8
	%242 = getelementptr inbounds %fmt.Info, %fmt.Info* %241, i32 0, i32 12
	%243 = load %strings.Builder*, %strings.Builder** %242, align 8
	%244 = load %..string, %..string* %9, align 8
	call void @strings.write_string(%strings.Builder* %243, %..string %244, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%245 = load %fmt.Info*, %fmt.Info** %0, align 8
	%246 = getelementptr inbounds %fmt.Info, %fmt.Info* %245, i32 0, i32 12
	%247 = load %strings.Builder*, %strings.Builder** %246, align 8
	call void @strings.write_string(%strings.Builder* %247, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$c7, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; t
	; IndexExpr
	; SelectorExpr
	%248 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i32 0, i32 0
	%249 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %248, align 8
	%250 = extractvalue {%runtime.Type_Info**, i64} %249, 0
	%251 = load i64, i64* %10, align 8
	%252 = extractvalue {%runtime.Type_Info**, i64} %249, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$c8, i32 0, i32 0), i64 57}, i64 1110, i64 21, i64 %251, i64 %252)
	%253 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %250, i64 %251
	%254 = load %runtime.Type_Info*, %runtime.Type_Info** %253, align 8
	store %runtime.Type_Info* %254, %runtime.Type_Info** %15
	; SelectorExpr
	%255 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	%256 = call i8 @reflect.is_any(%runtime.Type_Info* %255, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%257 = trunc i8 %256 to i1
	br i1 %257, label %if.then-24, label %if.else-25

if.then-24:
	; SelectorExpr
	; SelectorExpr
	%258 = load %fmt.Info*, %fmt.Info** %0, align 8
	%259 = getelementptr inbounds %fmt.Info, %fmt.Info* %258, i32 0, i32 12
	%260 = load %strings.Builder*, %strings.Builder** %259, align 8
	call void @strings.write_string(%strings.Builder* %260, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$c9, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-26

if.else-25:
	; data
	; SelectorExpr
	%261 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%262 = load %..rawptr, %..rawptr* %261, align 8
	%263 = ptrtoint %..rawptr %262 to i64
	; IndexExpr
	; SelectorExpr
	%264 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %5, i32 0, i32 2
	%265 = load {i64*, i64}, {i64*, i64}* %264, align 8
	%266 = extractvalue {i64*, i64} %265, 0
	%267 = load i64, i64* %10, align 8
	%268 = extractvalue {i64*, i64} %265, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ca, i32 0, i32 0), i64 57}, i64 1113, i64 49, i64 %267, i64 %268)
	%269 = getelementptr inbounds i64, i64* %266, i64 %267
	%270 = load i64, i64* %269, align 8
	%271 = add i64 %263, %270
	%272 = inttoptr i64 %271 to %..rawptr
	store %..rawptr %272, %..rawptr* %16
	%273 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %17, align 1
	store %..any zeroinitializer, %..any* %17
	%274 = load %..rawptr, %..rawptr* %16, align 8
	%275 = getelementptr inbounds %..any, %..any* %17, i32 0, i32 0
	store %..rawptr %274, %..rawptr* %275
	; SelectorExpr
	%276 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	%277 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %276, i32 0, i32 2
	%278 = load %..typeid, %..typeid* %277, align 8
	%279 = getelementptr inbounds %..any, %..any* %17, i32 0, i32 1
	store %..typeid %278, %..typeid* %279
	%280 = load %..any, %..any* %17, align 8
	call void @fmt.fmt_arg(%fmt.Info* %273, %..any %280, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-26

if.done-26:
	; IfStmt
	%281 = load i8, i8* %6, align 1
	%282 = trunc i8 %281 to i1
	br i1 %282, label %if.then-27, label %if.done-28

if.then-27:
	; SelectorExpr
	; SelectorExpr
	%283 = load %fmt.Info*, %fmt.Info** %0, align 8
	%284 = getelementptr inbounds %fmt.Info, %fmt.Info* %283, i32 0, i32 12
	%285 = load %strings.Builder*, %strings.Builder** %284, align 8
	call void @strings.write_string(%strings.Builder* %285, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$cb, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-28

if.done-28:
	br label %for.index.loop-14

for.index.done-29:
	; IfStmt
	%286 = load i8, i8* %6, align 1
	%287 = trunc i8 %286 to i1
	br i1 %287, label %if.then-30, label %if.done-34

if.then-30:
	; RangeStmt
	store i64 0, i64* %18
	store i64 0, i64* %19
	br label %for.interval.loop-31

for.interval.loop-31:
	%288 = load i64, i64* %7, align 8
	%289 = load i64, i64* %18, align 8
	%290 = icmp slt i64 %289, %288
	br i1 %290, label %for.interval.body-32, label %for.interval.done-33

for.interval.body-32:
	%291 = load i64, i64* %18, align 8
	%292 = add i64 %291, 1
	store i64 %292, i64* %18
	%293 = load i64, i64* %19, align 8
	%294 = add i64 %293, 1
	store i64 %294, i64* %19
	; SelectorExpr
	; SelectorExpr
	%295 = load %fmt.Info*, %fmt.Info** %0, align 8
	%296 = getelementptr inbounds %fmt.Info, %fmt.Info* %295, i32 0, i32 12
	%297 = load %strings.Builder*, %strings.Builder** %296, align 8
	call void @strings.write_byte(%strings.Builder* %297, i8 9, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-31

for.interval.done-33:
	br label %if.done-34

if.done-34:
	; SelectorExpr
	; SelectorExpr
	%298 = load %fmt.Info*, %fmt.Info** %0, align 8
	%299 = getelementptr inbounds %fmt.Info, %fmt.Info* %298, i32 0, i32 12
	%300 = load %strings.Builder*, %strings.Builder** %299, align 8
	call void @strings.write_byte(%strings.Builder* %300, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; defer
	; AssignStmt
	; SelectorExpr
	%301 = load %fmt.Info*, %fmt.Info** %0, align 8
	%302 = getelementptr inbounds %fmt.Info, %fmt.Info* %301, i32 0, i32 9
	%303 = load i64, i64* %302, align 8
	%304 = sub i64 %303, 1
	store i64 %304, i64* %302
	; defer
	; AssignStmt
	; SelectorExpr
	%305 = load %fmt.Info*, %fmt.Info** %0, align 8
	%306 = getelementptr inbounds %fmt.Info, %fmt.Info* %305, i32 0, i32 4
	%307 = load i8, i8* %6, align 1
	store i8 %307, i8* %306
	br label %typeswitch.done-41

typeswitch.next-35:
	%308 = icmp eq i64 %157, 21
	br i1 %308, label %typeswitch.body-38, label %typeswitch.next-37

typeswitch.body-36:
	%309 = bitcast %..rawptr %158 to %runtime.Type_Info_Bit_Set*
	%310 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %309, align 8
	store %runtime.Type_Info_Bit_Set %310, %runtime.Type_Info_Bit_Set* %20
	%311 = load %fmt.Info*, %fmt.Info** %0, align 8
	%312 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_set(%fmt.Info* %311, %..any %312, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-41

typeswitch.next-37:
	%313 = icmp eq i64 %157, 23
	br i1 %313, label %typeswitch.body-40, label %typeswitch.next-39

typeswitch.body-38:
	%314 = bitcast %..rawptr %158 to %runtime.Type_Info_Bit_Field*
	%315 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %314, align 8
	store %runtime.Type_Info_Bit_Field %315, %runtime.Type_Info_Bit_Field* %21
	%316 = load %fmt.Info*, %fmt.Info** %0, align 8
	%317 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_field(%fmt.Info* %316, %..any %317, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-41

typeswitch.next-39:
	store {[0 x i64], [88 x i8], i64} %155, {[0 x i64], [88 x i8], i64}* %23
	%318 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %24, align 1
	store %..any zeroinitializer, %..any* %24
	; SelectorExpr
	%319 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%320 = load %..rawptr, %..rawptr* %319, align 8
	%321 = getelementptr inbounds %..any, %..any* %24, i32 0, i32 0
	store %..rawptr %320, %..rawptr* %321
	; SelectorExpr
	; SelectorExpr
	%322 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %4, i32 0, i32 1
	%323 = load %runtime.Type_Info*, %runtime.Type_Info** %322, align 8
	%324 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %323, i32 0, i32 2
	%325 = load %..typeid, %..typeid* %324, align 8
	%326 = getelementptr inbounds %..any, %..any* %24, i32 0, i32 1
	store %..typeid %325, %..typeid* %326
	%327 = load %..any, %..any* %24, align 8
	%328 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Info* %318, %..any %327, i32 %328, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-41

typeswitch.body-40:
	%329 = bitcast %..rawptr %158 to %runtime.Type_Info_Opaque*
	%330 = load %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %329, align 8
	store %runtime.Type_Info_Opaque %330, %runtime.Type_Info_Opaque* %22
	%331 = load %fmt.Info*, %fmt.Info** %0, align 8
	%332 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_opaque(%fmt.Info* %331, %..any %332, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-41

typeswitch.done-41:
	br label %typeswitch.done-208

typeswitch.next-42:
	%333 = icmp eq i64 %146, 2
	br i1 %333, label %typeswitch.body-45, label %typeswitch.next-44

typeswitch.body-43:
	%334 = bitcast %..rawptr %147 to %runtime.Type_Info_Boolean*
	%335 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %334, align 1
	store %runtime.Type_Info_Boolean %335, %runtime.Type_Info_Boolean* %25
	%336 = load %fmt.Info*, %fmt.Info** %0, align 8
	%337 = load %..any, %..any* %1, align 8
	%338 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %336, %..any %337, i32 %338, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-44:
	%339 = icmp eq i64 %146, 3
	br i1 %339, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-45:
	%340 = bitcast %..rawptr %147 to %runtime.Type_Info_Integer*
	%341 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %340, align 1
	store %runtime.Type_Info_Integer %341, %runtime.Type_Info_Integer* %26
	%342 = load %fmt.Info*, %fmt.Info** %0, align 8
	%343 = load %..any, %..any* %1, align 8
	%344 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %342, %..any %343, i32 %344, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-46:
	%345 = icmp eq i64 %146, 4
	br i1 %345, label %typeswitch.body-49, label %typeswitch.next-48

typeswitch.body-47:
	%346 = bitcast %..rawptr %147 to %runtime.Type_Info_Rune*
	%347 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %346, align 1
	store %runtime.Type_Info_Rune %347, %runtime.Type_Info_Rune* %27
	%348 = load %fmt.Info*, %fmt.Info** %0, align 8
	%349 = load %..any, %..any* %1, align 8
	%350 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %348, %..any %349, i32 %350, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-48:
	%351 = icmp eq i64 %146, 5
	br i1 %351, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.body-49:
	%352 = bitcast %..rawptr %147 to %runtime.Type_Info_Float*
	%353 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %352, align 1
	store %runtime.Type_Info_Float %353, %runtime.Type_Info_Float* %28
	%354 = load %fmt.Info*, %fmt.Info** %0, align 8
	%355 = load %..any, %..any* %1, align 8
	%356 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %354, %..any %355, i32 %356, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-50:
	%357 = icmp eq i64 %146, 6
	br i1 %357, label %typeswitch.body-53, label %typeswitch.next-52

typeswitch.body-51:
	%358 = bitcast %..rawptr %147 to %runtime.Type_Info_Complex*
	%359 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %358, align 1
	store %runtime.Type_Info_Complex %359, %runtime.Type_Info_Complex* %29
	%360 = load %fmt.Info*, %fmt.Info** %0, align 8
	%361 = load %..any, %..any* %1, align 8
	%362 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %360, %..any %361, i32 %362, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-52:
	%363 = icmp eq i64 %146, 7
	br i1 %363, label %typeswitch.body-55, label %typeswitch.next-54

typeswitch.body-53:
	%364 = bitcast %..rawptr %147 to %runtime.Type_Info_Quaternion*
	%365 = load %runtime.Type_Info_Quaternion, %runtime.Type_Info_Quaternion* %364, align 1
	store %runtime.Type_Info_Quaternion %365, %runtime.Type_Info_Quaternion* %30
	%366 = load %fmt.Info*, %fmt.Info** %0, align 8
	%367 = load %..any, %..any* %1, align 8
	%368 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %366, %..any %367, i32 %368, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-54:
	%369 = icmp eq i64 %146, 11
	br i1 %369, label %typeswitch.body-57, label %typeswitch.next-56

typeswitch.body-55:
	%370 = bitcast %..rawptr %147 to %runtime.Type_Info_String*
	%371 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %370, align 1
	store %runtime.Type_Info_String %371, %runtime.Type_Info_String* %31
	%372 = load %fmt.Info*, %fmt.Info** %0, align 8
	%373 = load %..any, %..any* %1, align 8
	%374 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %372, %..any %373, i32 %374, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-56:
	%375 = icmp eq i64 %146, 13
	br i1 %375, label %typeswitch.body-84, label %typeswitch.next-83

typeswitch.body-57:
	%376 = bitcast %..rawptr %147 to %runtime.Type_Info_Pointer*
	%377 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %376, align 8
	store %runtime.Type_Info_Pointer %377, %runtime.Type_Info_Pointer* %32
	; IfStmt
	; SelectorExpr
	%378 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%379 = load %..typeid, %..typeid* %378, align 8
	%380 = icmp eq %..typeid %379, 720575940379279371
	%381 = zext i1 %380 to i8
	%382 = trunc i8 %381 to i1
	br i1 %382, label %if.then-58, label %if.else-59

if.then-58:
	; SelectorExpr
	; SelectorExpr
	%383 = load %fmt.Info*, %fmt.Info** %0, align 8
	%384 = getelementptr inbounds %fmt.Info, %fmt.Info* %383, i32 0, i32 12
	%385 = load %strings.Builder*, %strings.Builder** %384, align 8
	; SelectorExpr
	%386 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%387 = load %..rawptr, %..rawptr* %386, align 8
	%388 = bitcast %..rawptr %387 to %runtime.Type_Info**
	%389 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %388, i64 0
	%390 = load %runtime.Type_Info*, %runtime.Type_Info** %389, align 8
	call void @reflect.write_type(%strings.Builder* %385, %runtime.Type_Info* %390, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-82

if.else-59:
	; ptr
	; SelectorExpr
	%391 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%392 = load %..rawptr, %..rawptr* %391, align 8
	%393 = bitcast %..rawptr %392 to %..rawptr*
	%394 = getelementptr inbounds %..rawptr, %..rawptr* %393, i64 0
	%395 = load %..rawptr, %..rawptr* %394, align 8
	store %..rawptr %395, %..rawptr* %33
	; IfStmt
	%396 = load i32, i32* %2, align 4
	%397 = icmp ne i32 %396, 112
	%398 = zext i1 %397 to i8
	%399 = trunc i8 %398 to i1
	br i1 %399, label %cmp.and-60, label %if.done-81

cmp.and-60:
	; SelectorExpr
	%400 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %32, i32 0, i32 0
	%401 = load %runtime.Type_Info*, %runtime.Type_Info** %400, align 8
	%402 = icmp ne %runtime.Type_Info* %401, zeroinitializer
	%403 = zext i1 %402 to i8
	%404 = trunc i8 %403 to i1
	br i1 %404, label %if.then-61, label %if.done-81

if.then-61:
	; a
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %35, align 1
	store %..any zeroinitializer, %..any* %35
	%405 = load %..rawptr, %..rawptr* %33, align 8
	%406 = getelementptr inbounds %..any, %..any* %35, i32 0, i32 0
	store %..rawptr %405, %..rawptr* %406
	; SelectorExpr
	; SelectorExpr
	%407 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %32, i32 0, i32 0
	%408 = load %runtime.Type_Info*, %runtime.Type_Info** %407, align 8
	%409 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %408, i32 0, i32 2
	%410 = load %..typeid, %..typeid* %409, align 8
	%411 = getelementptr inbounds %..any, %..any* %35, i32 0, i32 1
	store %..typeid %410, %..typeid* %411
	%412 = load %..any, %..any* %35, align 8
	store %..any %412, %..any* %34
	; elem
	; SelectorExpr
	; SelectorExpr
	%413 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %32, i32 0, i32 0
	%414 = load %runtime.Type_Info*, %runtime.Type_Info** %413, align 8
	%415 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %414)
	store %runtime.Type_Info* %415, %runtime.Type_Info** %36
	; IfStmt
	%416 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	%417 = icmp ne %runtime.Type_Info* %416, zeroinitializer
	%418 = zext i1 %417 to i8
	%419 = trunc i8 %418 to i1
	br i1 %419, label %if.then-62, label %if.done-80

if.then-62:
	; TypeSwitchStmt
	; SelectorExpr
	%420 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	%421 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %420, i32 0, i32 3
	%422 = load {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %421, align 8
	; get union's tag
	%423 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %421, i64 0, i32 2 ; UnionTagPtr
	%424 = load i64, i64* %423, align 8
	%425 = bitcast {[0 x i64], [88 x i8], i64}* %421 to %..rawptr
	%426 = icmp eq i64 %424, 13
	br i1 %426, label %typeswitch.body-67, label %typeswitch.next-63

typeswitch.next-63:
	%427 = icmp eq i64 %424, 15
	br i1 %427, label %typeswitch.body-67, label %typeswitch.next-64

typeswitch.next-64:
	%428 = icmp eq i64 %424, 14
	br i1 %428, label %typeswitch.body-67, label %typeswitch.next-65

typeswitch.next-65:
	%429 = icmp eq i64 %424, 20
	br i1 %429, label %typeswitch.body-67, label %typeswitch.next-66

typeswitch.next-66:
	%430 = icmp eq i64 %424, 17
	br i1 %430, label %typeswitch.body-74, label %typeswitch.next-72

typeswitch.body-67:
	store {[0 x i64], [88 x i8], i64} %422, {[0 x i64], [88 x i8], i64}* %37
	; IfStmt
	%431 = load %..rawptr, %..rawptr* %33, align 8
	%432 = icmp eq %..rawptr %431, zeroinitializer
	%433 = zext i1 %432 to i8
	%434 = trunc i8 %433 to i1
	br i1 %434, label %if.then-68, label %if.done-69

if.then-68:
	; SelectorExpr
	; SelectorExpr
	%435 = load %fmt.Info*, %fmt.Info** %0, align 8
	%436 = getelementptr inbounds %fmt.Info, %fmt.Info* %435, i32 0, i32 12
	%437 = load %strings.Builder*, %strings.Builder** %436, align 8
	call void @strings.write_string(%strings.Builder* %437, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$cc, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-69:
	; IfStmt
	; SelectorExpr
	%438 = load %fmt.Info*, %fmt.Info** %0, align 8
	%439 = getelementptr inbounds %fmt.Info, %fmt.Info* %438, i32 0, i32 14
	%440 = load i64, i64* %439, align 8
	%441 = icmp slt i64 %440, 1
	%442 = zext i1 %441 to i8
	%443 = trunc i8 %442 to i1
	br i1 %443, label %if.then-70, label %if.done-71

if.then-70:
	; AssignStmt
	; SelectorExpr
	%444 = load %fmt.Info*, %fmt.Info** %0, align 8
	%445 = getelementptr inbounds %fmt.Info, %fmt.Info* %444, i32 0, i32 14
	%446 = load i64, i64* %445, align 8
	%447 = add i64 %446, 1
	store i64 %447, i64* %445
	; DeferStmt
	; SelectorExpr
	; SelectorExpr
	%448 = load %fmt.Info*, %fmt.Info** %0, align 8
	%449 = getelementptr inbounds %fmt.Info, %fmt.Info* %448, i32 0, i32 12
	%450 = load %strings.Builder*, %strings.Builder** %449, align 8
	call void @strings.write_byte(%strings.Builder* %450, i8 38, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%451 = load %fmt.Info*, %fmt.Info** %0, align 8
	%452 = load %..any, %..any* %34, align 8
	%453 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Info* %451, %..any %452, i32 %453, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	; defer
	; AssignStmt
	; SelectorExpr
	%454 = load %fmt.Info*, %fmt.Info** %0, align 8
	%455 = getelementptr inbounds %fmt.Info, %fmt.Info* %454, i32 0, i32 14
	%456 = load i64, i64* %455, align 8
	%457 = sub i64 %456, 1
	store i64 %457, i64* %455
	ret void

if.done-71:
	br label %typeswitch.done-79

typeswitch.next-72:
	%458 = icmp eq i64 %424, 18
	br i1 %458, label %typeswitch.body-74, label %typeswitch.next-73

typeswitch.next-73:
	br label %typeswitch.done-79

typeswitch.body-74:
	store {[0 x i64], [88 x i8], i64} %422, {[0 x i64], [88 x i8], i64}* %38
	; IfStmt
	%459 = load %..rawptr, %..rawptr* %33, align 8
	%460 = icmp eq %..rawptr %459, zeroinitializer
	%461 = zext i1 %460 to i8
	%462 = trunc i8 %461 to i1
	br i1 %462, label %if.then-75, label %if.done-76

if.then-75:
	; SelectorExpr
	; SelectorExpr
	%463 = load %fmt.Info*, %fmt.Info** %0, align 8
	%464 = getelementptr inbounds %fmt.Info, %fmt.Info* %463, i32 0, i32 12
	%465 = load %strings.Builder*, %strings.Builder** %464, align 8
	call void @strings.write_string(%strings.Builder* %465, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$cd, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-76:
	; IfStmt
	; SelectorExpr
	%466 = load %fmt.Info*, %fmt.Info** %0, align 8
	%467 = getelementptr inbounds %fmt.Info, %fmt.Info* %466, i32 0, i32 14
	%468 = load i64, i64* %467, align 8
	%469 = icmp slt i64 %468, 1
	%470 = zext i1 %469 to i8
	%471 = trunc i8 %470 to i1
	br i1 %471, label %if.then-77, label %if.done-78

if.then-77:
	; AssignStmt
	; SelectorExpr
	%472 = load %fmt.Info*, %fmt.Info** %0, align 8
	%473 = getelementptr inbounds %fmt.Info, %fmt.Info* %472, i32 0, i32 14
	%474 = load i64, i64* %473, align 8
	%475 = add i64 %474, 1
	store i64 %475, i64* %473
	; DeferStmt
	; SelectorExpr
	; SelectorExpr
	%476 = load %fmt.Info*, %fmt.Info** %0, align 8
	%477 = getelementptr inbounds %fmt.Info, %fmt.Info* %476, i32 0, i32 12
	%478 = load %strings.Builder*, %strings.Builder** %477, align 8
	call void @strings.write_byte(%strings.Builder* %478, i8 38, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%479 = load %fmt.Info*, %fmt.Info** %0, align 8
	%480 = load %..any, %..any* %34, align 8
	%481 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Info* %479, %..any %480, i32 %481, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	; defer
	; AssignStmt
	; SelectorExpr
	%482 = load %fmt.Info*, %fmt.Info** %0, align 8
	%483 = getelementptr inbounds %fmt.Info, %fmt.Info* %482, i32 0, i32 14
	%484 = load i64, i64* %483, align 8
	%485 = sub i64 %484, 1
	store i64 %485, i64* %483
	ret void

if.done-78:
	br label %typeswitch.done-79

typeswitch.done-79:
	br label %if.done-80

if.done-80:
	br label %if.done-81

if.done-81:
	%486 = load %fmt.Info*, %fmt.Info** %0, align 8
	%487 = load %..rawptr, %..rawptr* %33, align 8
	%488 = load i32, i32* %2, align 4
	call void @fmt.fmt_pointer(%fmt.Info* %486, %..rawptr %487, i32 %488, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-82

if.done-82:
	br label %typeswitch.done-208

typeswitch.next-83:
	%489 = icmp eq i64 %146, 14
	br i1 %489, label %typeswitch.body-91, label %typeswitch.next-90

typeswitch.body-84:
	%490 = bitcast %..rawptr %147 to %runtime.Type_Info_Array*
	%491 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %490, align 8
	store %runtime.Type_Info_Array %491, %runtime.Type_Info_Array* %39
	; SelectorExpr
	; SelectorExpr
	%492 = load %fmt.Info*, %fmt.Info** %0, align 8
	%493 = getelementptr inbounds %fmt.Info, %fmt.Info* %492, i32 0, i32 12
	%494 = load %strings.Builder*, %strings.Builder** %493, align 8
	call void @strings.write_byte(%strings.Builder* %494, i8 91, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %40, align 1
	store i64 0, i64* %41
	store i64 0, i64* %42
	br label %for.interval.loop-85

for.interval.loop-85:
	; SelectorExpr
	%495 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %39, i32 0, i32 2
	%496 = load i64, i64* %495, align 8
	%497 = load i64, i64* %41, align 8
	%498 = icmp slt i64 %497, %496
	br i1 %498, label %for.interval.body-86, label %for.interval.done-89

for.interval.body-86:
	%499 = load i64, i64* %41, align 8
	%500 = load i64, i64* %41, align 8
	%501 = add i64 %500, 1
	store i64 %501, i64* %41
	%502 = load i64, i64* %42, align 8
	%503 = add i64 %502, 1
	store i64 %503, i64* %42
	store i64 %499, i64* %40
	; IfStmt
	%504 = load i64, i64* %40, align 8
	%505 = icmp sgt i64 %504, 0
	%506 = zext i1 %505 to i8
	%507 = trunc i8 %506 to i1
	br i1 %507, label %if.then-87, label %if.done-88

if.then-87:
	; SelectorExpr
	; SelectorExpr
	%508 = load %fmt.Info*, %fmt.Info** %0, align 8
	%509 = getelementptr inbounds %fmt.Info, %fmt.Info* %508, i32 0, i32 12
	%510 = load %strings.Builder*, %strings.Builder** %509, align 8
	call void @strings.write_string(%strings.Builder* %510, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ce, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-88

if.done-88:
	; data
	; SelectorExpr
	%511 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%512 = load %..rawptr, %..rawptr* %511, align 8
	%513 = ptrtoint %..rawptr %512 to i64
	%514 = load i64, i64* %40, align 8
	; SelectorExpr
	%515 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %39, i32 0, i32 1
	%516 = load i64, i64* %515, align 8
	%517 = mul i64 %514, %516
	%518 = bitcast i64 %517 to i64
	%519 = add i64 %513, %518
	store i64 %519, i64* %43
	%520 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %44, align 1
	store %..any zeroinitializer, %..any* %44
	%521 = load i64, i64* %43, align 8
	%522 = inttoptr i64 %521 to %..rawptr
	%523 = getelementptr inbounds %..any, %..any* %44, i32 0, i32 0
	store %..rawptr %522, %..rawptr* %523
	; SelectorExpr
	; SelectorExpr
	%524 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %39, i32 0, i32 0
	%525 = load %runtime.Type_Info*, %runtime.Type_Info** %524, align 8
	%526 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %525, i32 0, i32 2
	%527 = load %..typeid, %..typeid* %526, align 8
	%528 = getelementptr inbounds %..any, %..any* %44, i32 0, i32 1
	store %..typeid %527, %..typeid* %528
	%529 = load %..any, %..any* %44, align 8
	%530 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %520, %..any %529, i32 %530, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-85

for.interval.done-89:
	; defer
	; SelectorExpr
	; SelectorExpr
	%531 = load %fmt.Info*, %fmt.Info** %0, align 8
	%532 = getelementptr inbounds %fmt.Info, %fmt.Info* %531, i32 0, i32 12
	%533 = load %strings.Builder*, %strings.Builder** %532, align 8
	call void @strings.write_byte(%strings.Builder* %533, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-90:
	%534 = icmp eq i64 %146, 24
	br i1 %534, label %typeswitch.body-101, label %typeswitch.next-100

typeswitch.body-91:
	%535 = bitcast %..rawptr %147 to %runtime.Type_Info_Dynamic_Array*
	%536 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %535, align 8
	store %runtime.Type_Info_Dynamic_Array %536, %runtime.Type_Info_Dynamic_Array* %45
	; IfStmt
	%537 = load i32, i32* %2, align 4
	%538 = icmp eq i32 %537, 112
	%539 = zext i1 %538 to i8
	%540 = trunc i8 %539 to i1
	br i1 %540, label %if.then-92, label %if.else-93

if.then-92:
	; slice
	; SelectorExpr
	%541 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%542 = load %..rawptr, %..rawptr* %541, align 8
	%543 = bitcast %..rawptr %542 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %543, %mem.Raw_Dynamic_Array** %46
	%544 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SelectorExpr
	%545 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %46, align 8
	%546 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %545, i32 0, i32 0
	%547 = load %..rawptr, %..rawptr* %546, align 8
	call void @fmt.fmt_pointer(%fmt.Info* %544, %..rawptr %547, i32 112, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-99

if.else-93:
	; SelectorExpr
	; SelectorExpr
	%548 = load %fmt.Info*, %fmt.Info** %0, align 8
	%549 = getelementptr inbounds %fmt.Info, %fmt.Info* %548, i32 0, i32 12
	%550 = load %strings.Builder*, %strings.Builder** %549, align 8
	call void @strings.write_byte(%strings.Builder* %550, i8 91, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; array
	; SelectorExpr
	%551 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%552 = load %..rawptr, %..rawptr* %551, align 8
	%553 = bitcast %..rawptr %552 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %553, %mem.Raw_Dynamic_Array** %47
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %48, align 1
	store i64 0, i64* %49
	store i64 0, i64* %50
	br label %for.interval.loop-94

for.interval.loop-94:
	; SelectorExpr
	%554 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %47, align 8
	%555 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %554, i32 0, i32 1
	%556 = load i64, i64* %555, align 8
	%557 = load i64, i64* %49, align 8
	%558 = icmp slt i64 %557, %556
	br i1 %558, label %for.interval.body-95, label %for.interval.done-98

for.interval.body-95:
	%559 = load i64, i64* %49, align 8
	%560 = load i64, i64* %49, align 8
	%561 = add i64 %560, 1
	store i64 %561, i64* %49
	%562 = load i64, i64* %50, align 8
	%563 = add i64 %562, 1
	store i64 %563, i64* %50
	store i64 %559, i64* %48
	; IfStmt
	%564 = load i64, i64* %48, align 8
	%565 = icmp sgt i64 %564, 0
	%566 = zext i1 %565 to i8
	%567 = trunc i8 %566 to i1
	br i1 %567, label %if.then-96, label %if.done-97

if.then-96:
	; SelectorExpr
	; SelectorExpr
	%568 = load %fmt.Info*, %fmt.Info** %0, align 8
	%569 = getelementptr inbounds %fmt.Info, %fmt.Info* %568, i32 0, i32 12
	%570 = load %strings.Builder*, %strings.Builder** %569, align 8
	call void @strings.write_string(%strings.Builder* %570, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$cf, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-97

if.done-97:
	; data
	; SelectorExpr
	%571 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %47, align 8
	%572 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %571, i32 0, i32 0
	%573 = load %..rawptr, %..rawptr* %572, align 8
	%574 = ptrtoint %..rawptr %573 to i64
	%575 = load i64, i64* %48, align 8
	; SelectorExpr
	%576 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %45, i32 0, i32 1
	%577 = load i64, i64* %576, align 8
	%578 = mul i64 %575, %577
	%579 = bitcast i64 %578 to i64
	%580 = add i64 %574, %579
	store i64 %580, i64* %51
	%581 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %52, align 1
	store %..any zeroinitializer, %..any* %52
	%582 = load i64, i64* %51, align 8
	%583 = inttoptr i64 %582 to %..rawptr
	%584 = getelementptr inbounds %..any, %..any* %52, i32 0, i32 0
	store %..rawptr %583, %..rawptr* %584
	; SelectorExpr
	; SelectorExpr
	%585 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %45, i32 0, i32 0
	%586 = load %runtime.Type_Info*, %runtime.Type_Info** %585, align 8
	%587 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %586, i32 0, i32 2
	%588 = load %..typeid, %..typeid* %587, align 8
	%589 = getelementptr inbounds %..any, %..any* %52, i32 0, i32 1
	store %..typeid %588, %..typeid* %589
	%590 = load %..any, %..any* %52, align 8
	%591 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %581, %..any %590, i32 %591, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-94

for.interval.done-98:
	; defer
	; SelectorExpr
	; SelectorExpr
	%592 = load %fmt.Info*, %fmt.Info** %0, align 8
	%593 = getelementptr inbounds %fmt.Info, %fmt.Info* %592, i32 0, i32 12
	%594 = load %strings.Builder*, %strings.Builder** %593, align 8
	call void @strings.write_byte(%strings.Builder* %594, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-99

if.done-99:
	br label %typeswitch.done-208

typeswitch.next-100:
	%595 = icmp eq i64 %146, 15
	br i1 %595, label %typeswitch.body-110, label %typeswitch.next-109

typeswitch.body-101:
	%596 = bitcast %..rawptr %147 to %runtime.Type_Info_Simd_Vector*
	%597 = load %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %596, align 8
	store %runtime.Type_Info_Simd_Vector %597, %runtime.Type_Info_Simd_Vector* %53
	; IfStmt
	; SelectorExpr
	%598 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %53, i32 0, i32 3
	%599 = load i8, i8* %598, align 1
	%600 = trunc i8 %599 to i1
	br i1 %600, label %if.then-102, label %if.done-103

if.then-102:
	; SelectorExpr
	; SelectorExpr
	%601 = load %fmt.Info*, %fmt.Info** %0, align 8
	%602 = getelementptr inbounds %fmt.Info, %fmt.Info* %601, i32 0, i32 12
	%603 = load %strings.Builder*, %strings.Builder** %602, align 8
	call void @strings.write_string(%strings.Builder* %603, %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$d0, i32 0, i32 0), i64 20}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-103

if.done-103:
	; SelectorExpr
	; SelectorExpr
	%604 = load %fmt.Info*, %fmt.Info** %0, align 8
	%605 = getelementptr inbounds %fmt.Info, %fmt.Info* %604, i32 0, i32 12
	%606 = load %strings.Builder*, %strings.Builder** %605, align 8
	call void @strings.write_byte(%strings.Builder* %606, i8 60, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %54, align 1
	store i64 0, i64* %55
	store i64 0, i64* %56
	br label %for.interval.loop-104

for.interval.loop-104:
	; SelectorExpr
	%607 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %53, i32 0, i32 2
	%608 = load i64, i64* %607, align 8
	%609 = load i64, i64* %55, align 8
	%610 = icmp slt i64 %609, %608
	br i1 %610, label %for.interval.body-105, label %for.interval.done-108

for.interval.body-105:
	%611 = load i64, i64* %55, align 8
	%612 = load i64, i64* %55, align 8
	%613 = add i64 %612, 1
	store i64 %613, i64* %55
	%614 = load i64, i64* %56, align 8
	%615 = add i64 %614, 1
	store i64 %615, i64* %56
	store i64 %611, i64* %54
	; IfStmt
	%616 = load i64, i64* %54, align 8
	%617 = icmp sgt i64 %616, 0
	%618 = zext i1 %617 to i8
	%619 = trunc i8 %618 to i1
	br i1 %619, label %if.then-106, label %if.done-107

if.then-106:
	; SelectorExpr
	; SelectorExpr
	%620 = load %fmt.Info*, %fmt.Info** %0, align 8
	%621 = getelementptr inbounds %fmt.Info, %fmt.Info* %620, i32 0, i32 12
	%622 = load %strings.Builder*, %strings.Builder** %621, align 8
	call void @strings.write_string(%strings.Builder* %622, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d1, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-107

if.done-107:
	; data
	; SelectorExpr
	%623 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%624 = load %..rawptr, %..rawptr* %623, align 8
	%625 = ptrtoint %..rawptr %624 to i64
	%626 = load i64, i64* %54, align 8
	; SelectorExpr
	%627 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %53, i32 0, i32 1
	%628 = load i64, i64* %627, align 8
	%629 = mul i64 %626, %628
	%630 = bitcast i64 %629 to i64
	%631 = add i64 %625, %630
	store i64 %631, i64* %57
	%632 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %58, align 1
	store %..any zeroinitializer, %..any* %58
	%633 = load i64, i64* %57, align 8
	%634 = inttoptr i64 %633 to %..rawptr
	%635 = getelementptr inbounds %..any, %..any* %58, i32 0, i32 0
	store %..rawptr %634, %..rawptr* %635
	; SelectorExpr
	; SelectorExpr
	%636 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %53, i32 0, i32 0
	%637 = load %runtime.Type_Info*, %runtime.Type_Info** %636, align 8
	%638 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %637, i32 0, i32 2
	%639 = load %..typeid, %..typeid* %638, align 8
	%640 = getelementptr inbounds %..any, %..any* %58, i32 0, i32 1
	store %..typeid %639, %..typeid* %640
	%641 = load %..any, %..any* %58, align 8
	%642 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %632, %..any %641, i32 %642, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-104

for.interval.done-108:
	; defer
	; SelectorExpr
	; SelectorExpr
	%643 = load %fmt.Info*, %fmt.Info** %0, align 8
	%644 = getelementptr inbounds %fmt.Info, %fmt.Info* %643, i32 0, i32 12
	%645 = load %strings.Builder*, %strings.Builder** %644, align 8
	call void @strings.write_byte(%strings.Builder* %645, i8 62, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-109:
	%646 = icmp eq i64 %146, 20
	br i1 %646, label %typeswitch.body-120, label %typeswitch.next-119

typeswitch.body-110:
	%647 = bitcast %..rawptr %147 to %runtime.Type_Info_Slice*
	%648 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %647, align 8
	store %runtime.Type_Info_Slice %648, %runtime.Type_Info_Slice* %59
	; IfStmt
	%649 = load i32, i32* %2, align 4
	%650 = icmp eq i32 %649, 112
	%651 = zext i1 %650 to i8
	%652 = trunc i8 %651 to i1
	br i1 %652, label %if.then-111, label %if.else-112

if.then-111:
	; slice
	; SelectorExpr
	%653 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%654 = load %..rawptr, %..rawptr* %653, align 8
	%655 = bitcast %..rawptr %654 to %mem.Raw_Slice*
	store %mem.Raw_Slice* %655, %mem.Raw_Slice** %60
	%656 = load %fmt.Info*, %fmt.Info** %0, align 8
	; SelectorExpr
	%657 = load %mem.Raw_Slice*, %mem.Raw_Slice** %60, align 8
	%658 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %657, i32 0, i32 0
	%659 = load %..rawptr, %..rawptr* %658, align 8
	call void @fmt.fmt_pointer(%fmt.Info* %656, %..rawptr %659, i32 112, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-118

if.else-112:
	; SelectorExpr
	; SelectorExpr
	%660 = load %fmt.Info*, %fmt.Info** %0, align 8
	%661 = getelementptr inbounds %fmt.Info, %fmt.Info* %660, i32 0, i32 12
	%662 = load %strings.Builder*, %strings.Builder** %661, align 8
	call void @strings.write_byte(%strings.Builder* %662, i8 91, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; slice
	; SelectorExpr
	%663 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%664 = load %..rawptr, %..rawptr* %663, align 8
	%665 = bitcast %..rawptr %664 to %mem.Raw_Slice*
	store %mem.Raw_Slice* %665, %mem.Raw_Slice** %61
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %62, align 1
	store i64 0, i64* %63
	store i64 0, i64* %64
	br label %for.interval.loop-113

for.interval.loop-113:
	; SelectorExpr
	%666 = load %mem.Raw_Slice*, %mem.Raw_Slice** %61, align 8
	%667 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %666, i32 0, i32 1
	%668 = load i64, i64* %667, align 8
	%669 = load i64, i64* %63, align 8
	%670 = icmp slt i64 %669, %668
	br i1 %670, label %for.interval.body-114, label %for.interval.done-117

for.interval.body-114:
	%671 = load i64, i64* %63, align 8
	%672 = load i64, i64* %63, align 8
	%673 = add i64 %672, 1
	store i64 %673, i64* %63
	%674 = load i64, i64* %64, align 8
	%675 = add i64 %674, 1
	store i64 %675, i64* %64
	store i64 %671, i64* %62
	; IfStmt
	%676 = load i64, i64* %62, align 8
	%677 = icmp sgt i64 %676, 0
	%678 = zext i1 %677 to i8
	%679 = trunc i8 %678 to i1
	br i1 %679, label %if.then-115, label %if.done-116

if.then-115:
	; SelectorExpr
	; SelectorExpr
	%680 = load %fmt.Info*, %fmt.Info** %0, align 8
	%681 = getelementptr inbounds %fmt.Info, %fmt.Info* %680, i32 0, i32 12
	%682 = load %strings.Builder*, %strings.Builder** %681, align 8
	call void @strings.write_string(%strings.Builder* %682, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d2, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-116

if.done-116:
	; data
	; SelectorExpr
	%683 = load %mem.Raw_Slice*, %mem.Raw_Slice** %61, align 8
	%684 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %683, i32 0, i32 0
	%685 = load %..rawptr, %..rawptr* %684, align 8
	%686 = ptrtoint %..rawptr %685 to i64
	%687 = load i64, i64* %62, align 8
	; SelectorExpr
	%688 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %59, i32 0, i32 1
	%689 = load i64, i64* %688, align 8
	%690 = mul i64 %687, %689
	%691 = bitcast i64 %690 to i64
	%692 = add i64 %686, %691
	store i64 %692, i64* %65
	%693 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %66, align 1
	store %..any zeroinitializer, %..any* %66
	%694 = load i64, i64* %65, align 8
	%695 = inttoptr i64 %694 to %..rawptr
	%696 = getelementptr inbounds %..any, %..any* %66, i32 0, i32 0
	store %..rawptr %695, %..rawptr* %696
	; SelectorExpr
	; SelectorExpr
	%697 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %59, i32 0, i32 0
	%698 = load %runtime.Type_Info*, %runtime.Type_Info** %697, align 8
	%699 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %698, i32 0, i32 2
	%700 = load %..typeid, %..typeid* %699, align 8
	%701 = getelementptr inbounds %..any, %..any* %66, i32 0, i32 1
	store %..typeid %700, %..typeid* %701
	%702 = load %..any, %..any* %66, align 8
	%703 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %693, %..any %702, i32 %703, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-113

for.interval.done-117:
	; defer
	; SelectorExpr
	; SelectorExpr
	%704 = load %fmt.Info*, %fmt.Info** %0, align 8
	%705 = getelementptr inbounds %fmt.Info, %fmt.Info* %704, i32 0, i32 12
	%706 = load %strings.Builder*, %strings.Builder** %705, align 8
	call void @strings.write_byte(%strings.Builder* %706, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-118

if.done-118:
	br label %typeswitch.done-208

typeswitch.next-119:
	%707 = icmp eq i64 %146, 17
	br i1 %707, label %typeswitch.body-142, label %typeswitch.next-141

typeswitch.body-120:
	%708 = bitcast %..rawptr %147 to %runtime.Type_Info_Map*
	%709 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %708, align 8
	store %runtime.Type_Info_Map %709, %runtime.Type_Info_Map* %67
	; IfStmt
	%710 = load i32, i32* %2, align 4
	%711 = icmp ne i32 %710, 118
	%712 = zext i1 %711 to i8
	%713 = trunc i8 %712 to i1
	br i1 %713, label %if.then-121, label %if.done-122

if.then-121:
	%714 = load %fmt.Info*, %fmt.Info** %0, align 8
	%715 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %714, i32 %715, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-122:
	; SelectorExpr
	; SelectorExpr
	%716 = load %fmt.Info*, %fmt.Info** %0, align 8
	%717 = getelementptr inbounds %fmt.Info, %fmt.Info* %716, i32 0, i32 12
	%718 = load %strings.Builder*, %strings.Builder** %717, align 8
	call void @strings.write_string(%strings.Builder* %718, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$d3, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; m
	; SelectorExpr
	%719 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%720 = load %..rawptr, %..rawptr* %719, align 8
	%721 = bitcast %..rawptr %720 to %mem.Raw_Map*
	store %mem.Raw_Map* %721, %mem.Raw_Map** %68
	; IfStmt
	%722 = load %mem.Raw_Map*, %mem.Raw_Map** %68, align 8
	%723 = icmp ne %mem.Raw_Map* %722, zeroinitializer
	%724 = zext i1 %723 to i8
	%725 = trunc i8 %724 to i1
	br i1 %725, label %if.then-123, label %if.done-140

if.then-123:
	; IfStmt
	; SelectorExpr
	%726 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %67, i32 0, i32 2
	%727 = load %runtime.Type_Info*, %runtime.Type_Info** %726, align 8
	%728 = icmp eq %runtime.Type_Info* %727, zeroinitializer
	%729 = zext i1 %728 to i8
	%730 = trunc i8 %729 to i1
	br i1 %730, label %if.then-124, label %if.done-125

if.then-124:
	; ReturnStmt
	; defer
	; SelectorExpr
	; SelectorExpr
	%731 = load %fmt.Info*, %fmt.Info** %0, align 8
	%732 = getelementptr inbounds %fmt.Info, %fmt.Info* %731, i32 0, i32 12
	%733 = load %strings.Builder*, %strings.Builder** %732, align 8
	call void @strings.write_byte(%strings.Builder* %733, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void

if.done-125:
	; entries
	; SelectorExpr
	%734 = load %mem.Raw_Map*, %mem.Raw_Map** %68, align 8
	%735 = getelementptr inbounds %mem.Raw_Map, %mem.Raw_Map* %734, i32 0, i32 1
	store %mem.Raw_Dynamic_Array* %735, %mem.Raw_Dynamic_Array** %69
	; gs
	; SelectorExpr
	; SelectorExpr
	; SelectorExpr
	%736 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %67, i32 0, i32 2
	%737 = load %runtime.Type_Info*, %runtime.Type_Info** %736, align 8
	%738 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %737)
	store %runtime.Type_Info* %738, %runtime.Type_Info** %71
	%739 = load %runtime.Type_Info*, %runtime.Type_Info** %71, align 8
	%740 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %739, i32 0, i32 3
	; cast - union_cast
	%741 = bitcast {%runtime.Type_Info_Struct, i8}* %72 to %..rawptr
	; ZeroInit
	%742 = call %..rawptr @mem.zero(%..rawptr %741, i64 96)
	%743 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %740, i64 0, i32 2 ; UnionTagPtr
	%744 = load i64, i64* %743, align 8
	%745 = icmp eq i64 %744, 17
	br i1 %745, label %union_cast.ok-126, label %union_cast.end-127

union_cast.ok-126:
	%746 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %72, i32 0, i32 0
	%747 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %72, i32 0, i32 1
	%748 = bitcast {[0 x i64], [88 x i8], i64}* %740 to %runtime.Type_Info_Struct*
	%749 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %748, align 8
	store %runtime.Type_Info_Struct %749, %runtime.Type_Info_Struct* %746
	store i8 1, i8* %747
	br label %union_cast.end-127

union_cast.end-127:
	%750 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %72, i32 0, i32 1
	%751 = load i8, i8* %750, align 1
	%752 = trunc i8 %751 to i1
	call void @runtime.type_assertion_check(i1 %752, %..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$d4, i32 0, i32 0), i64 57}, i64 1255, i64 64, %..typeid 1224979098644774922, %..typeid 3458764513820540978)
	%753 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %72, i32 0, i32 0
	%754 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %753, align 8
	store %runtime.Type_Info_Struct %754, %runtime.Type_Info_Struct* %70
	; ed
	; SelectorExpr
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%755 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %70, i32 0, i32 0
	%756 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %755, align 8
	%757 = extractvalue {%runtime.Type_Info**, i64} %756, 0
	%758 = extractvalue {%runtime.Type_Info**, i64} %756, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$d5, i32 0, i32 0), i64 57}, i64 1256, i64 50, i64 1, i64 %758)
	%759 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %757, i64 1
	%760 = load %runtime.Type_Info*, %runtime.Type_Info** %759, align 8
	%761 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %760)
	store %runtime.Type_Info* %761, %runtime.Type_Info** %74
	%762 = load %runtime.Type_Info*, %runtime.Type_Info** %74, align 8
	%763 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %762, i32 0, i32 3
	; cast - union_cast
	%764 = bitcast {%runtime.Type_Info_Dynamic_Array, i8}* %75 to %..rawptr
	; ZeroInit
	%765 = call %..rawptr @mem.zero(%..rawptr %764, i64 24)
	%766 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %763, i64 0, i32 2 ; UnionTagPtr
	%767 = load i64, i64* %766, align 8
	%768 = icmp eq i64 %767, 14
	br i1 %768, label %union_cast.ok-128, label %union_cast.end-129

union_cast.ok-128:
	%769 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %75, i32 0, i32 0
	%770 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %75, i32 0, i32 1
	%771 = bitcast {[0 x i64], [88 x i8], i64}* %763 to %runtime.Type_Info_Dynamic_Array*
	%772 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %771, align 8
	store %runtime.Type_Info_Dynamic_Array %772, %runtime.Type_Info_Dynamic_Array* %769
	store i8 1, i8* %770
	br label %union_cast.end-129

union_cast.end-129:
	%773 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %75, i32 0, i32 1
	%774 = load i8, i8* %773, align 1
	%775 = trunc i8 %774 to i1
	call void @runtime.type_assertion_check(i1 %775, %..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$d6, i32 0, i32 0), i64 57}, i64 1256, i64 54, %..typeid 1224979098644774922, %..typeid 3458764513820540969)
	%776 = getelementptr inbounds {%runtime.Type_Info_Dynamic_Array, i8}, {%runtime.Type_Info_Dynamic_Array, i8}* %75, i32 0, i32 0
	%777 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %776, align 8
	store %runtime.Type_Info_Dynamic_Array %777, %runtime.Type_Info_Dynamic_Array* %73
	; entry_type
	; SelectorExpr
	; SelectorExpr
	%778 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %73, i32 0, i32 0
	%779 = load %runtime.Type_Info*, %runtime.Type_Info** %778, align 8
	%780 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %779, i32 0, i32 3
	; cast - union_cast
	%781 = bitcast {%runtime.Type_Info_Struct, i8}* %77 to %..rawptr
	; ZeroInit
	%782 = call %..rawptr @mem.zero(%..rawptr %781, i64 96)
	%783 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %780, i64 0, i32 2 ; UnionTagPtr
	%784 = load i64, i64* %783, align 8
	%785 = icmp eq i64 %784, 17
	br i1 %785, label %union_cast.ok-130, label %union_cast.end-131

union_cast.ok-130:
	%786 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %77, i32 0, i32 0
	%787 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %77, i32 0, i32 1
	%788 = bitcast {[0 x i64], [88 x i8], i64}* %780 to %runtime.Type_Info_Struct*
	%789 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %788, align 8
	store %runtime.Type_Info_Struct %789, %runtime.Type_Info_Struct* %786
	store i8 1, i8* %787
	br label %union_cast.end-131

union_cast.end-131:
	%790 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %77, i32 0, i32 1
	%791 = load i8, i8* %790, align 1
	%792 = trunc i8 %791 to i1
	call void @runtime.type_assertion_check(i1 %792, %..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$d7, i32 0, i32 0), i64 57}, i64 1257, i64 26, %..typeid 1224979098644774922, %..typeid 3458764513820540978)
	%793 = getelementptr inbounds {%runtime.Type_Info_Struct, i8}, {%runtime.Type_Info_Struct, i8}* %77, i32 0, i32 0
	%794 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %793, align 8
	store %runtime.Type_Info_Struct %794, %runtime.Type_Info_Struct* %76
	; entry_size
	; SelectorExpr
	%795 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %73, i32 0, i32 1
	%796 = load i64, i64* %795, align 8
	store i64 %796, i64* %78
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %79, align 1
	store i64 0, i64* %80
	store i64 0, i64* %81
	br label %for.interval.loop-132

for.interval.loop-132:
	; SelectorExpr
	%797 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %69, align 8
	%798 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %797, i32 0, i32 1
	%799 = load i64, i64* %798, align 8
	%800 = load i64, i64* %80, align 8
	%801 = icmp slt i64 %800, %799
	br i1 %801, label %for.interval.body-133, label %for.interval.done-139

for.interval.body-133:
	%802 = load i64, i64* %80, align 8
	%803 = load i64, i64* %80, align 8
	%804 = add i64 %803, 1
	store i64 %804, i64* %80
	%805 = load i64, i64* %81, align 8
	%806 = add i64 %805, 1
	store i64 %806, i64* %81
	store i64 %802, i64* %79
	; IfStmt
	%807 = load i64, i64* %79, align 8
	%808 = icmp sgt i64 %807, 0
	%809 = zext i1 %808 to i8
	%810 = trunc i8 %809 to i1
	br i1 %810, label %if.then-134, label %if.done-135

if.then-134:
	; SelectorExpr
	; SelectorExpr
	%811 = load %fmt.Info*, %fmt.Info** %0, align 8
	%812 = getelementptr inbounds %fmt.Info, %fmt.Info* %811, i32 0, i32 12
	%813 = load %strings.Builder*, %strings.Builder** %812, align 8
	call void @strings.write_string(%strings.Builder* %813, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$d8, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-135

if.done-135:
	; data
	; SelectorExpr
	%814 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %69, align 8
	%815 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %814, i32 0, i32 0
	%816 = load %..rawptr, %..rawptr* %815, align 8
	%817 = ptrtoint %..rawptr %816 to i64
	%818 = load i64, i64* %79, align 8
	%819 = load i64, i64* %78, align 8
	%820 = mul i64 %818, %819
	%821 = bitcast i64 %820 to i64
	%822 = add i64 %817, %821
	store i64 %822, i64* %82
	; header
	%823 = load i64, i64* %82, align 8
	%824 = inttoptr i64 %823 to %runtime.Map_Entry_Header*
	store %runtime.Map_Entry_Header* %824, %runtime.Map_Entry_Header** %83
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%825 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %67, i32 0, i32 0
	%826 = load %runtime.Type_Info*, %runtime.Type_Info** %825, align 8
	%827 = call i8 @reflect.is_string(%runtime.Type_Info* %826, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%828 = trunc i8 %827 to i1
	br i1 %828, label %if.then-136, label %if.else-137

if.then-136:
	; SelectorExpr
	; SelectorExpr
	%829 = load %fmt.Info*, %fmt.Info** %0, align 8
	%830 = getelementptr inbounds %fmt.Info, %fmt.Info* %829, i32 0, i32 12
	%831 = load %strings.Builder*, %strings.Builder** %830, align 8
	; SelectorExpr
	; SelectorExpr
	%832 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %83, align 8
	%833 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %832, i32 0, i32 0
	%834 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %833, i32 0, i32 1
	%835 = load %..string, %..string* %834, align 8
	call void @strings.write_string(%strings.Builder* %831, %..string %835, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-138

if.else-137:
	; fi
	; CompoundLit
	%836 = bitcast %fmt.Info* %85 to %..rawptr
	; ZeroInit
	%837 = call %..rawptr @mem.zero(%..rawptr %836, i64 72)
	store %fmt.Info {i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer, i8 zeroinitializer, %strings.Builder* zeroinitializer, %..any zeroinitializer, i64 zeroinitializer}, %fmt.Info* %85
	; SelectorExpr
	%838 = load %fmt.Info*, %fmt.Info** %0, align 8
	%839 = getelementptr inbounds %fmt.Info, %fmt.Info* %838, i32 0, i32 12
	%840 = load %strings.Builder*, %strings.Builder** %839, align 8
	%841 = getelementptr inbounds %fmt.Info, %fmt.Info* %85, i32 0, i32 12
	store %strings.Builder* %840, %strings.Builder** %841
	%842 = load %fmt.Info, %fmt.Info* %85, align 8
	store %fmt.Info %842, %fmt.Info* %84
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %86, align 1
	store %..any zeroinitializer, %..any* %86
	; SelectorExpr
	; SelectorExpr
	%843 = load %runtime.Map_Entry_Header*, %runtime.Map_Entry_Header** %83, align 8
	%844 = getelementptr inbounds %runtime.Map_Entry_Header, %runtime.Map_Entry_Header* %843, i32 0, i32 0
	%845 = getelementptr inbounds %runtime.Map_Key, %runtime.Map_Key* %844, i32 0, i32 0
	%846 = bitcast i64* %845 to %..rawptr
	%847 = getelementptr inbounds %..any, %..any* %86, i32 0, i32 0
	store %..rawptr %846, %..rawptr* %847
	; SelectorExpr
	; SelectorExpr
	%848 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %67, i32 0, i32 0
	%849 = load %runtime.Type_Info*, %runtime.Type_Info** %848, align 8
	%850 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %849, i32 0, i32 2
	%851 = load %..typeid, %..typeid* %850, align 8
	%852 = getelementptr inbounds %..any, %..any* %86, i32 0, i32 1
	store %..typeid %851, %..typeid* %852
	%853 = load %..any, %..any* %86, align 8
	call void @fmt.fmt_arg(%fmt.Info* %84, %..any %853, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-138

if.done-138:
	; SelectorExpr
	; SelectorExpr
	%854 = load %fmt.Info*, %fmt.Info** %0, align 8
	%855 = getelementptr inbounds %fmt.Info, %fmt.Info* %854, i32 0, i32 12
	%856 = load %strings.Builder*, %strings.Builder** %855, align 8
	call void @strings.write_string(%strings.Builder* %856, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$d9, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; value
	%857 = load i64, i64* %82, align 8
	; IndexExpr
	; SelectorExpr
	%858 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %76, i32 0, i32 2
	%859 = load {i64*, i64}, {i64*, i64}* %858, align 8
	%860 = extractvalue {i64*, i64} %859, 0
	%861 = extractvalue {i64*, i64} %859, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$da, i32 0, i32 0), i64 57}, i64 1275, i64 40, i64 2, i64 %861)
	%862 = getelementptr inbounds i64, i64* %860, i64 2
	%863 = load i64, i64* %862, align 8
	%864 = add i64 %857, %863
	store i64 %864, i64* %87
	%865 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %88, align 1
	store %..any zeroinitializer, %..any* %88
	%866 = load i64, i64* %87, align 8
	%867 = inttoptr i64 %866 to %..rawptr
	%868 = getelementptr inbounds %..any, %..any* %88, i32 0, i32 0
	store %..rawptr %867, %..rawptr* %868
	; SelectorExpr
	; SelectorExpr
	%869 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %67, i32 0, i32 1
	%870 = load %runtime.Type_Info*, %runtime.Type_Info** %869, align 8
	%871 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %870, i32 0, i32 2
	%872 = load %..typeid, %..typeid* %871, align 8
	%873 = getelementptr inbounds %..any, %..any* %88, i32 0, i32 1
	store %..typeid %872, %..typeid* %873
	%874 = load %..any, %..any* %88, align 8
	call void @fmt.fmt_arg(%fmt.Info* %865, %..any %874, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-132

for.interval.done-139:
	br label %if.done-140

if.done-140:
	; defer
	; SelectorExpr
	; SelectorExpr
	%875 = load %fmt.Info*, %fmt.Info** %0, align 8
	%876 = getelementptr inbounds %fmt.Info, %fmt.Info* %875, i32 0, i32 12
	%877 = load %strings.Builder*, %strings.Builder** %876, align 8
	call void @strings.write_byte(%strings.Builder* %877, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-141:
	%878 = icmp eq i64 %146, 18
	br i1 %878, label %typeswitch.body-164, label %typeswitch.next-163

typeswitch.body-142:
	%879 = bitcast %..rawptr %147 to %runtime.Type_Info_Struct*
	%880 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %879, align 8
	store %runtime.Type_Info_Struct %880, %runtime.Type_Info_Struct* %89
	; IfStmt
	; SelectorExpr
	%881 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %89, i32 0, i32 6
	%882 = load i8, i8* %881, align 1
	%883 = trunc i8 %882 to i1
	br i1 %883, label %if.then-143, label %if.done-144

if.then-143:
	; SelectorExpr
	; SelectorExpr
	%884 = load %fmt.Info*, %fmt.Info** %0, align 8
	%885 = getelementptr inbounds %fmt.Info, %fmt.Info* %884, i32 0, i32 12
	%886 = load %strings.Builder*, %strings.Builder** %885, align 8
	call void @strings.write_string(%strings.Builder* %886, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$db, i32 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-144:
	; SelectorExpr
	; SelectorExpr
	%887 = load %fmt.Info*, %fmt.Info** %0, align 8
	%888 = getelementptr inbounds %fmt.Info, %fmt.Info* %887, i32 0, i32 12
	%889 = load %strings.Builder*, %strings.Builder** %888, align 8
	call void @strings.write_byte(%strings.Builder* %889, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%890 = load %fmt.Info*, %fmt.Info** %0, align 8
	%891 = getelementptr inbounds %fmt.Info, %fmt.Info* %890, i32 0, i32 9
	%892 = load i64, i64* %891, align 8
	%893 = add i64 %892, 1
	store i64 %893, i64* %891
	; DeferStmt
	; hash
	; SelectorExpr
	%894 = load %fmt.Info*, %fmt.Info** %0, align 8
	%895 = getelementptr inbounds %fmt.Info, %fmt.Info* %894, i32 0, i32 4
	%896 = load i8, i8* %895, align 1
	store i8 %896, i8* %90
	; DeferStmt
	; AssignStmt
	; SelectorExpr
	%897 = load %fmt.Info*, %fmt.Info** %0, align 8
	%898 = getelementptr inbounds %fmt.Info, %fmt.Info* %897, i32 0, i32 4
	store i8 0, i8* %898
	; IfStmt
	%899 = load i8, i8* %90, align 1
	%900 = trunc i8 %899 to i1
	br i1 %900, label %if.then-145, label %if.done-146

if.then-145:
	; SelectorExpr
	; SelectorExpr
	%901 = load %fmt.Info*, %fmt.Info** %0, align 8
	%902 = getelementptr inbounds %fmt.Info, %fmt.Info* %901, i32 0, i32 12
	%903 = load %strings.Builder*, %strings.Builder** %902, align 8
	call void @strings.write_byte(%strings.Builder* %903, i8 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-146

if.done-146:
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %91, align 1
	; SelectorExpr
	%904 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %89, i32 0, i32 1
	%905 = load {%..string*, i64}, {%..string*, i64}* %904, align 8
	%906 = extractvalue {%..string*, i64} %905, 1
	store i64 %906, i64* %92
	store i64 -1, i64* %93
	br label %for.index.loop-147

for.index.loop-147:
	%907 = load i64, i64* %93, align 8
	%908 = add i64 %907, 1
	store i64 %908, i64* %93
	%909 = load i64, i64* %92, align 8
	%910 = icmp slt i64 %908, %909
	br i1 %910, label %for.index.body-148, label %for.index.done-162

for.index.body-148:
	%911 = load i64, i64* %93, align 8
	store i64 %911, i64* %91
	; IfStmt
	%912 = load i8, i8* %90, align 1
	%913 = trunc i8 %912 to i1
	br i1 %913, label %if.done-151, label %cmp.and-149

cmp.and-149:
	%914 = load i64, i64* %91, align 8
	%915 = icmp sgt i64 %914, 0
	%916 = zext i1 %915 to i8
	%917 = trunc i8 %916 to i1
	br i1 %917, label %if.then-150, label %if.done-151

if.then-150:
	; SelectorExpr
	; SelectorExpr
	%918 = load %fmt.Info*, %fmt.Info** %0, align 8
	%919 = getelementptr inbounds %fmt.Info, %fmt.Info* %918, i32 0, i32 12
	%920 = load %strings.Builder*, %strings.Builder** %919, align 8
	call void @strings.write_string(%strings.Builder* %920, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$dc, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-151

if.done-151:
	; IfStmt
	%921 = load i8, i8* %90, align 1
	%922 = trunc i8 %921 to i1
	br i1 %922, label %if.then-152, label %if.done-156

if.then-152:
	; RangeStmt
	store i64 0, i64* %94
	store i64 0, i64* %95
	br label %for.interval.loop-153

for.interval.loop-153:
	; SelectorExpr
	%923 = load %fmt.Info*, %fmt.Info** %0, align 8
	%924 = getelementptr inbounds %fmt.Info, %fmt.Info* %923, i32 0, i32 9
	%925 = load i64, i64* %924, align 8
	%926 = load i64, i64* %94, align 8
	%927 = icmp slt i64 %926, %925
	br i1 %927, label %for.interval.body-154, label %for.interval.done-155

for.interval.body-154:
	%928 = load i64, i64* %94, align 8
	%929 = add i64 %928, 1
	store i64 %929, i64* %94
	%930 = load i64, i64* %95, align 8
	%931 = add i64 %930, 1
	store i64 %931, i64* %95
	; SelectorExpr
	; SelectorExpr
	%932 = load %fmt.Info*, %fmt.Info** %0, align 8
	%933 = getelementptr inbounds %fmt.Info, %fmt.Info* %932, i32 0, i32 12
	%934 = load %strings.Builder*, %strings.Builder** %933, align 8
	call void @strings.write_byte(%strings.Builder* %934, i8 9, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-153

for.interval.done-155:
	br label %if.done-156

if.done-156:
	; SelectorExpr
	; SelectorExpr
	%935 = load %fmt.Info*, %fmt.Info** %0, align 8
	%936 = getelementptr inbounds %fmt.Info, %fmt.Info* %935, i32 0, i32 12
	%937 = load %strings.Builder*, %strings.Builder** %936, align 8
	; IndexExpr
	; SelectorExpr
	%938 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %89, i32 0, i32 1
	%939 = load {%..string*, i64}, {%..string*, i64}* %938, align 8
	%940 = extractvalue {%..string*, i64} %939, 0
	%941 = load i64, i64* %91, align 8
	%942 = extractvalue {%..string*, i64} %939, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$dd, i32 0, i32 0), i64 57}, i64 1304, i64 44, i64 %941, i64 %942)
	%943 = getelementptr inbounds %..string, %..string* %940, i64 %941
	%944 = load %..string, %..string* %943, align 8
	call void @strings.write_string(%strings.Builder* %937, %..string %944, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%945 = load %fmt.Info*, %fmt.Info** %0, align 8
	%946 = getelementptr inbounds %fmt.Info, %fmt.Info* %945, i32 0, i32 12
	%947 = load %strings.Builder*, %strings.Builder** %946, align 8
	call void @strings.write_string(%strings.Builder* %947, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$de, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; t
	; IndexExpr
	; SelectorExpr
	%948 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %89, i32 0, i32 0
	%949 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %948, align 8
	%950 = extractvalue {%runtime.Type_Info**, i64} %949, 0
	%951 = load i64, i64* %91, align 8
	%952 = extractvalue {%runtime.Type_Info**, i64} %949, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$df, i32 0, i32 0), i64 57}, i64 1307, i64 23, i64 %951, i64 %952)
	%953 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %950, i64 %951
	%954 = load %runtime.Type_Info*, %runtime.Type_Info** %953, align 8
	store %runtime.Type_Info* %954, %runtime.Type_Info** %96
	; SelectorExpr
	%955 = load %runtime.Type_Info*, %runtime.Type_Info** %96, align 8
	%956 = call i8 @reflect.is_any(%runtime.Type_Info* %955, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%957 = trunc i8 %956 to i1
	br i1 %957, label %if.then-157, label %if.else-158

if.then-157:
	; SelectorExpr
	; SelectorExpr
	%958 = load %fmt.Info*, %fmt.Info** %0, align 8
	%959 = getelementptr inbounds %fmt.Info, %fmt.Info* %958, i32 0, i32 12
	%960 = load %strings.Builder*, %strings.Builder** %959, align 8
	call void @strings.write_string(%strings.Builder* %960, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$e0, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-159

if.else-158:
	; data
	; SelectorExpr
	%961 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%962 = load %..rawptr, %..rawptr* %961, align 8
	%963 = ptrtoint %..rawptr %962 to i64
	; IndexExpr
	; SelectorExpr
	%964 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %89, i32 0, i32 2
	%965 = load {i64*, i64}, {i64*, i64}* %964, align 8
	%966 = extractvalue {i64*, i64} %965, 0
	%967 = load i64, i64* %91, align 8
	%968 = extractvalue {i64*, i64} %965, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$e1, i32 0, i32 0), i64 57}, i64 1310, i64 44, i64 %967, i64 %968)
	%969 = getelementptr inbounds i64, i64* %966, i64 %967
	%970 = load i64, i64* %969, align 8
	%971 = add i64 %963, %970
	store i64 %971, i64* %97
	%972 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %98, align 1
	store %..any zeroinitializer, %..any* %98
	%973 = load i64, i64* %97, align 8
	%974 = inttoptr i64 %973 to %..rawptr
	%975 = getelementptr inbounds %..any, %..any* %98, i32 0, i32 0
	store %..rawptr %974, %..rawptr* %975
	; SelectorExpr
	%976 = load %runtime.Type_Info*, %runtime.Type_Info** %96, align 8
	%977 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %976, i32 0, i32 2
	%978 = load %..typeid, %..typeid* %977, align 8
	%979 = getelementptr inbounds %..any, %..any* %98, i32 0, i32 1
	store %..typeid %978, %..typeid* %979
	%980 = load %..any, %..any* %98, align 8
	call void @fmt.fmt_arg(%fmt.Info* %972, %..any %980, i32 118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-159

if.done-159:
	; IfStmt
	%981 = load i8, i8* %90, align 1
	%982 = trunc i8 %981 to i1
	br i1 %982, label %if.then-160, label %if.done-161

if.then-160:
	; SelectorExpr
	; SelectorExpr
	%983 = load %fmt.Info*, %fmt.Info** %0, align 8
	%984 = getelementptr inbounds %fmt.Info, %fmt.Info* %983, i32 0, i32 12
	%985 = load %strings.Builder*, %strings.Builder** %984, align 8
	call void @strings.write_string(%strings.Builder* %985, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$e2, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-161

if.done-161:
	br label %for.index.loop-147

for.index.done-162:
	; defer
	; AssignStmt
	; SelectorExpr
	%986 = load %fmt.Info*, %fmt.Info** %0, align 8
	%987 = getelementptr inbounds %fmt.Info, %fmt.Info* %986, i32 0, i32 4
	%988 = load i8, i8* %90, align 1
	store i8 %988, i8* %987
	; defer
	; AssignStmt
	; SelectorExpr
	%989 = load %fmt.Info*, %fmt.Info** %0, align 8
	%990 = getelementptr inbounds %fmt.Info, %fmt.Info* %989, i32 0, i32 9
	%991 = load i64, i64* %990, align 8
	%992 = sub i64 %991, 1
	store i64 %992, i64* %990
	; defer
	; SelectorExpr
	; SelectorExpr
	%993 = load %fmt.Info*, %fmt.Info** %0, align 8
	%994 = getelementptr inbounds %fmt.Info, %fmt.Info* %993, i32 0, i32 12
	%995 = load %strings.Builder*, %strings.Builder** %994, align 8
	call void @strings.write_byte(%strings.Builder* %995, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-163:
	%996 = icmp eq i64 %146, 19
	br i1 %996, label %typeswitch.body-194, label %typeswitch.next-193

typeswitch.body-164:
	%997 = bitcast %..rawptr %147 to %runtime.Type_Info_Union*
	%998 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %997, align 8
	store %runtime.Type_Info_Union %998, %runtime.Type_Info_Union* %99
	; IfStmt
	; SelectorExpr
	%999 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	%1000 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %999, i32 0, i32 0
	%1001 = load i64, i64* %1000, align 8
	%1002 = icmp eq i64 %1001, 0
	%1003 = zext i1 %1002 to i8
	%1004 = trunc i8 %1003 to i1
	br i1 %1004, label %if.then-165, label %if.done-166

if.then-165:
	; SelectorExpr
	; SelectorExpr
	%1005 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1006 = getelementptr inbounds %fmt.Info, %fmt.Info* %1005, i32 0, i32 12
	%1007 = load %strings.Builder*, %strings.Builder** %1006, align 8
	call void @strings.write_string(%strings.Builder* %1007, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$e3, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-166:
	; tag_ptr
	; SelectorExpr
	%1008 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%1009 = load %..rawptr, %..rawptr* %1008, align 8
	%1010 = ptrtoint %..rawptr %1009 to i64
	; SelectorExpr
	%1011 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %99, i32 0, i32 1
	%1012 = load i64, i64* %1011, align 8
	%1013 = add i64 %1010, %1012
	store i64 %1013, i64* %100
	; tag_any
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %102, align 1
	store %..any zeroinitializer, %..any* %102
	%1014 = load i64, i64* %100, align 8
	%1015 = inttoptr i64 %1014 to %..rawptr
	%1016 = getelementptr inbounds %..any, %..any* %102, i32 0, i32 0
	store %..rawptr %1015, %..rawptr* %1016
	; SelectorExpr
	; SelectorExpr
	%1017 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %99, i32 0, i32 2
	%1018 = load %runtime.Type_Info*, %runtime.Type_Info** %1017, align 8
	%1019 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1018, i32 0, i32 2
	%1020 = load %..typeid, %..typeid* %1019, align 8
	%1021 = getelementptr inbounds %..any, %..any* %102, i32 0, i32 1
	store %..typeid %1020, %..typeid* %1021
	%1022 = load %..any, %..any* %102, align 8
	store %..any %1022, %..any* %101
	; tag
	store i64 -1, i64* %103
	; TypeSwitchStmt
	%1023 = load %..any, %..any* %101, align 8
	%1024 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1025 = load %..typeid, %..typeid* %1024, align 8
	%1026 = icmp eq %..typeid %1025, 72057594037927939
	br i1 %1026, label %typeswitch.body-168, label %typeswitch.next-167

typeswitch.next-167:
	%1027 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1028 = load %..typeid, %..typeid* %1027, align 8
	%1029 = icmp eq %..typeid %1028, 4683743612465315905
	br i1 %1029, label %typeswitch.body-170, label %typeswitch.next-169

typeswitch.body-168:
	%1030 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1031 = load %..rawptr, %..rawptr* %1030, align 8
	%1032 = bitcast %..rawptr %1031 to i8*
	%1033 = load i8, i8* %1032, align 1
	store i8 %1033, i8* %104
	; AssignStmt
	%1034 = load i8, i8* %104, align 1
	%1035 = zext i8 %1034 to i64
	store i64 %1035, i64* %103
	br label %typeswitch.done-183

typeswitch.next-169:
	%1036 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1037 = load %..typeid, %..typeid* %1036, align 8
	%1038 = icmp eq %..typeid %1037, 72057594037928005
	br i1 %1038, label %typeswitch.body-172, label %typeswitch.next-171

typeswitch.body-170:
	%1039 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1040 = load %..rawptr, %..rawptr* %1039, align 8
	%1041 = bitcast %..rawptr %1040 to i8*
	%1042 = load i8, i8* %1041, align 1
	store i8 %1042, i8* %105
	; AssignStmt
	%1043 = load i8, i8* %105, align 1
	%1044 = sext i8 %1043 to i64
	store i64 %1044, i64* %103
	br label %typeswitch.done-183

typeswitch.next-171:
	%1045 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1046 = load %..typeid, %..typeid* %1045, align 8
	%1047 = icmp eq %..typeid %1046, 4683743612465315906
	br i1 %1047, label %typeswitch.body-174, label %typeswitch.next-173

typeswitch.body-172:
	%1048 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1049 = load %..rawptr, %..rawptr* %1048, align 8
	%1050 = bitcast %..rawptr %1049 to i16*
	%1051 = load i16, i16* %1050, align 2
	store i16 %1051, i16* %106
	; AssignStmt
	%1052 = load i16, i16* %106, align 2
	%1053 = zext i16 %1052 to i64
	store i64 %1053, i64* %103
	br label %typeswitch.done-183

typeswitch.next-173:
	%1054 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1055 = load %..typeid, %..typeid* %1054, align 8
	%1056 = icmp eq %..typeid %1055, 72057594037928006
	br i1 %1056, label %typeswitch.body-176, label %typeswitch.next-175

typeswitch.body-174:
	%1057 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1058 = load %..rawptr, %..rawptr* %1057, align 8
	%1059 = bitcast %..rawptr %1058 to i16*
	%1060 = load i16, i16* %1059, align 2
	store i16 %1060, i16* %107
	; AssignStmt
	%1061 = load i16, i16* %107, align 2
	%1062 = sext i16 %1061 to i64
	store i64 %1062, i64* %103
	br label %typeswitch.done-183

typeswitch.next-175:
	%1063 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1064 = load %..typeid, %..typeid* %1063, align 8
	%1065 = icmp eq %..typeid %1064, 4683743612465315907
	br i1 %1065, label %typeswitch.body-178, label %typeswitch.next-177

typeswitch.body-176:
	%1066 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1067 = load %..rawptr, %..rawptr* %1066, align 8
	%1068 = bitcast %..rawptr %1067 to i32*
	%1069 = load i32, i32* %1068, align 4
	store i32 %1069, i32* %108
	; AssignStmt
	%1070 = load i32, i32* %108, align 4
	%1071 = zext i32 %1070 to i64
	store i64 %1071, i64* %103
	br label %typeswitch.done-183

typeswitch.next-177:
	%1072 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1073 = load %..typeid, %..typeid* %1072, align 8
	%1074 = icmp eq %..typeid %1073, 72057594037928007
	br i1 %1074, label %typeswitch.body-180, label %typeswitch.next-179

typeswitch.body-178:
	%1075 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1076 = load %..rawptr, %..rawptr* %1075, align 8
	%1077 = bitcast %..rawptr %1076 to i32*
	%1078 = load i32, i32* %1077, align 4
	store i32 %1078, i32* %109
	; AssignStmt
	%1079 = load i32, i32* %109, align 4
	%1080 = sext i32 %1079 to i64
	store i64 %1080, i64* %103
	br label %typeswitch.done-183

typeswitch.next-179:
	%1081 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 1
	%1082 = load %..typeid, %..typeid* %1081, align 8
	%1083 = icmp eq %..typeid %1082, 4683743612465315908
	br i1 %1083, label %typeswitch.body-182, label %typeswitch.next-181

typeswitch.body-180:
	%1084 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1085 = load %..rawptr, %..rawptr* %1084, align 8
	%1086 = bitcast %..rawptr %1085 to i64*
	%1087 = load i64, i64* %1086, align 8
	store i64 %1087, i64* %110
	; AssignStmt
	%1088 = load i64, i64* %110, align 8
	%1089 = bitcast i64 %1088 to i64
	store i64 %1089, i64* %103
	br label %typeswitch.done-183

typeswitch.next-181:
	store %..any %1023, %..any* %112
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$e4, i32 0, i32 0), i64 57}, i64 1335, i64 9, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$e5, i32 0, i32 0), i64 9}, i64 9010972713583106181}, %runtime.Source_Code_Location* %113
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$e6, i32 0, i32 0), i64 22}, %runtime.Source_Code_Location* %113, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %typeswitch.done-183

typeswitch.body-182:
	%1090 = getelementptr inbounds %..any, %..any* %101, i32 0, i32 0
	%1091 = load %..rawptr, %..rawptr* %1090, align 8
	%1092 = bitcast %..rawptr %1091 to i64*
	%1093 = load i64, i64* %1092, align 8
	store i64 %1093, i64* %111
	; AssignStmt
	%1094 = load i64, i64* %111, align 8
	store i64 %1094, i64* %103
	br label %typeswitch.done-183

typeswitch.done-183:
	%1095 = load i64, i64* %103, align 8
	%1096 = icmp sge i64 %1095, 0
	%1097 = zext i1 %1096 to i8
	%1098 = trunc i8 %1097 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$e7, i32 0, i32 0), i64 57}, i64 1337, i64 3, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$e8, i32 0, i32 0), i64 9}, i64 9010968315536593273}, %runtime.Source_Code_Location* %114
	%1099 = call i8 @runtime.assert(i1 %1098, %..string zeroinitializer, %runtime.Source_Code_Location* %114, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%1100 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%1101 = load %..rawptr, %..rawptr* %1100, align 8
	%1102 = icmp eq %..rawptr %1101, zeroinitializer
	%1103 = zext i1 %1102 to i8
	%1104 = trunc i8 %1103 to i1
	br i1 %1104, label %if.then-184, label %if.else-185

if.then-184:
	; SelectorExpr
	; SelectorExpr
	%1105 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1106 = getelementptr inbounds %fmt.Info, %fmt.Info* %1105, i32 0, i32 12
	%1107 = load %strings.Builder*, %strings.Builder** %1106, align 8
	call void @strings.write_string(%strings.Builder* %1107, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$e9, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-192

if.else-185:
	; IfStmt
	; SelectorExpr
	%1108 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %99, i32 0, i32 4
	%1109 = load i8, i8* %1108, align 1
	%1110 = trunc i8 %1109 to i1
	br i1 %1110, label %if.then-186, label %if.else-187

if.then-186:
	; id
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%1111 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %99, i32 0, i32 0
	%1112 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1111, align 8
	%1113 = extractvalue {%runtime.Type_Info**, i64} %1112, 0
	%1114 = load i64, i64* %103, align 8
	%1115 = bitcast i64 %1114 to i64
	%1116 = extractvalue {%runtime.Type_Info**, i64} %1112, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ea, i32 0, i32 0), i64 57}, i64 1342, i64 24, i64 %1115, i64 %1116)
	%1117 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1113, i64 %1115
	%1118 = load %runtime.Type_Info*, %runtime.Type_Info** %1117, align 8
	%1119 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1118, i32 0, i32 2
	%1120 = load %..typeid, %..typeid* %1119, align 8
	store %..typeid %1120, %..typeid* %115
	%1121 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %116, align 1
	store %..any zeroinitializer, %..any* %116
	; SelectorExpr
	%1122 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%1123 = load %..rawptr, %..rawptr* %1122, align 8
	%1124 = getelementptr inbounds %..any, %..any* %116, i32 0, i32 0
	store %..rawptr %1123, %..rawptr* %1124
	%1125 = load %..typeid, %..typeid* %115, align 8
	%1126 = getelementptr inbounds %..any, %..any* %116, i32 0, i32 1
	store %..typeid %1125, %..typeid* %1126
	%1127 = load %..any, %..any* %116, align 8
	%1128 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %1121, %..any %1127, i32 %1128, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-191

if.else-187:
	; IfStmt
	%1129 = load i64, i64* %103, align 8
	%1130 = icmp eq i64 %1129, 0
	%1131 = zext i1 %1130 to i8
	%1132 = trunc i8 %1131 to i1
	br i1 %1132, label %if.then-188, label %if.else-189

if.then-188:
	; SelectorExpr
	; SelectorExpr
	%1133 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1134 = getelementptr inbounds %fmt.Info, %fmt.Info* %1133, i32 0, i32 12
	%1135 = load %strings.Builder*, %strings.Builder** %1134, align 8
	call void @strings.write_string(%strings.Builder* %1135, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$eb, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-190

if.else-189:
	; id
	; SelectorExpr
	; IndexExpr
	; SelectorExpr
	%1136 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %99, i32 0, i32 0
	%1137 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1136, align 8
	%1138 = extractvalue {%runtime.Type_Info**, i64} %1137, 0
	%1139 = load i64, i64* %103, align 8
	%1140 = sub i64 %1139, 1
	%1141 = bitcast i64 %1140 to i64
	%1142 = extractvalue {%runtime.Type_Info**, i64} %1137, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$ec, i32 0, i32 0), i64 57}, i64 1347, i64 24, i64 %1141, i64 %1142)
	%1143 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1138, i64 %1141
	%1144 = load %runtime.Type_Info*, %runtime.Type_Info** %1143, align 8
	%1145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1144, i32 0, i32 2
	%1146 = load %..typeid, %..typeid* %1145, align 8
	store %..typeid %1146, %..typeid* %117
	%1147 = load %fmt.Info*, %fmt.Info** %0, align 8
	; CompoundLit
	; ZeroInit
	store %..any zeroinitializer, %..any* %118, align 1
	store %..any zeroinitializer, %..any* %118
	; SelectorExpr
	%1148 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%1149 = load %..rawptr, %..rawptr* %1148, align 8
	%1150 = getelementptr inbounds %..any, %..any* %118, i32 0, i32 0
	store %..rawptr %1149, %..rawptr* %1150
	%1151 = load %..typeid, %..typeid* %117, align 8
	%1152 = getelementptr inbounds %..any, %..any* %118, i32 0, i32 1
	store %..typeid %1151, %..typeid* %1152
	%1153 = load %..any, %..any* %118, align 8
	%1154 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %1147, %..any %1153, i32 %1154, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-190

if.done-190:
	br label %if.done-191

if.done-191:
	br label %if.done-192

if.done-192:
	br label %typeswitch.done-208

typeswitch.next-193:
	%1155 = icmp eq i64 %146, 12
	br i1 %1155, label %typeswitch.body-196, label %typeswitch.next-195

typeswitch.body-194:
	%1156 = bitcast %..rawptr %147 to %runtime.Type_Info_Enum*
	%1157 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1156, align 8
	store %runtime.Type_Info_Enum %1157, %runtime.Type_Info_Enum* %119
	%1158 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1159 = load %..any, %..any* %1, align 8
	%1160 = load i32, i32* %2, align 4
	call void @fmt.fmt_enum(%fmt.Info* %1158, %..any %1159, i32 %1160, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-195:
	%1161 = icmp eq i64 %146, 10
	br i1 %1161, label %typeswitch.body-201, label %typeswitch.next-200

typeswitch.body-196:
	%1162 = bitcast %..rawptr %147 to %runtime.Type_Info_Procedure*
	%1163 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %1162, align 8
	store %runtime.Type_Info_Procedure %1163, %runtime.Type_Info_Procedure* %120
	; ptr
	; SelectorExpr
	%1164 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%1165 = load %..rawptr, %..rawptr* %1164, align 8
	%1166 = bitcast %..rawptr %1165 to %..rawptr*
	%1167 = getelementptr inbounds %..rawptr, %..rawptr* %1166, i64 0
	%1168 = load %..rawptr, %..rawptr* %1167, align 8
	store %..rawptr %1168, %..rawptr* %121
	; IfStmt
	%1169 = load %..rawptr, %..rawptr* %121, align 8
	%1170 = icmp eq %..rawptr %1169, zeroinitializer
	%1171 = zext i1 %1170 to i8
	%1172 = trunc i8 %1171 to i1
	br i1 %1172, label %if.then-197, label %if.else-198

if.then-197:
	; SelectorExpr
	; SelectorExpr
	%1173 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1174 = getelementptr inbounds %fmt.Info, %fmt.Info* %1173, i32 0, i32 12
	%1175 = load %strings.Builder*, %strings.Builder** %1174, align 8
	call void @strings.write_string(%strings.Builder* %1175, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$ed, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-199

if.else-198:
	; SelectorExpr
	; SelectorExpr
	%1176 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1177 = getelementptr inbounds %fmt.Info, %fmt.Info* %1176, i32 0, i32 12
	%1178 = load %strings.Builder*, %strings.Builder** %1177, align 8
	; SelectorExpr
	%1179 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%1180 = load %..typeid, %..typeid* %1179, align 8
	call void @reflect.write_typeid(%strings.Builder* %1178, %..typeid %1180, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%1181 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1182 = getelementptr inbounds %fmt.Info, %fmt.Info* %1181, i32 0, i32 12
	%1183 = load %strings.Builder*, %strings.Builder** %1182, align 8
	call void @strings.write_string(%strings.Builder* %1183, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$ee, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%1184 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1185 = load %..rawptr, %..rawptr* %121, align 8
	call void @fmt.fmt_pointer(%fmt.Info* %1184, %..rawptr %1185, i32 112, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-199

if.done-199:
	br label %typeswitch.done-208

typeswitch.next-200:
	%1186 = icmp eq i64 %146, 21
	br i1 %1186, label %typeswitch.body-203, label %typeswitch.next-202

typeswitch.body-201:
	%1187 = bitcast %..rawptr %147 to %runtime.Type_Info_Type_Id*
	%1188 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %1187, align 1
	store %runtime.Type_Info_Type_Id %1188, %runtime.Type_Info_Type_Id* %122
	; id
	; SelectorExpr
	%1189 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%1190 = load %..rawptr, %..rawptr* %1189, align 8
	%1191 = bitcast %..rawptr %1190 to %..typeid*
	%1192 = getelementptr inbounds %..typeid, %..typeid* %1191, i64 0
	%1193 = load %..typeid, %..typeid* %1192, align 8
	store %..typeid %1193, %..typeid* %123
	; SelectorExpr
	; SelectorExpr
	%1194 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1195 = getelementptr inbounds %fmt.Info, %fmt.Info* %1194, i32 0, i32 12
	%1196 = load %strings.Builder*, %strings.Builder** %1195, align 8
	%1197 = load %..typeid, %..typeid* %123, align 8
	call void @reflect.write_typeid(%strings.Builder* %1196, %..typeid %1197, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-202:
	%1198 = icmp eq i64 %146, 22
	br i1 %1198, label %typeswitch.body-205, label %typeswitch.next-204

typeswitch.body-203:
	%1199 = bitcast %..rawptr %147 to %runtime.Type_Info_Bit_Field*
	%1200 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %1199, align 8
	store %runtime.Type_Info_Bit_Field %1200, %runtime.Type_Info_Bit_Field* %124
	%1201 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1202 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_field(%fmt.Info* %1201, %..any %1202, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-204:
	%1203 = icmp eq i64 %146, 23
	br i1 %1203, label %typeswitch.body-207, label %typeswitch.next-206

typeswitch.body-205:
	%1204 = bitcast %..rawptr %147 to %runtime.Type_Info_Bit_Set*
	%1205 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %1204, align 8
	store %runtime.Type_Info_Bit_Set %1205, %runtime.Type_Info_Bit_Set* %125
	%1206 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1207 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_bit_set(%fmt.Info* %1206, %..any %1207, %..string zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.next-206:
	br label %typeswitch.done-208

typeswitch.body-207:
	%1208 = bitcast %..rawptr %147 to %runtime.Type_Info_Opaque*
	%1209 = load %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %1208, align 8
	store %runtime.Type_Info_Opaque %1209, %runtime.Type_Info_Opaque* %126
	%1210 = load %fmt.Info*, %fmt.Info** %0, align 8
	%1211 = load %..any, %..any* %1, align 8
	call void @fmt.fmt_opaque(%fmt.Info* %1210, %..any %1211, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-208

typeswitch.done-208:
	ret void
}

define void @fmt.fmt_complex(%fmt.Info* %_.0, %..complex128* %_.1, i64 %_.2, i32 %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i64 %_.2, i64* %1
	store i32 %_.3, i32* %2
	; SwitchStmt
	%5 = load i32, i32* %2, align 4
	%6 = icmp eq i32 %5, 102
	br i1 %6, label %switch.case.body-6, label %switch.case.next-1

switch.case.next-1:
	%7 = icmp eq i32 %5, 70
	br i1 %7, label %switch.case.body-6, label %switch.case.next-2

switch.case.next-2:
	%8 = icmp eq i32 %5, 118
	br i1 %8, label %switch.case.body-6, label %switch.case.next-3

switch.case.next-3:
	%9 = icmp eq i32 %5, 104
	br i1 %9, label %switch.case.body-6, label %switch.case.next-4

switch.case.next-4:
	%10 = icmp eq i32 %5, 72
	br i1 %10, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%11 = load %fmt.Info*, %fmt.Info** %0, align 8
	%12 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %11, i32 %12, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

switch.case.body-6:
	; r
	; i
	; real
	%13 = load %..complex128, %..complex128* %_.1, align 8
	%14 = extractvalue %..complex128 %13, 0
	; imag
	%15 = load %..complex128, %..complex128* %_.1, align 8
	%16 = extractvalue %..complex128 %15, 1
	store double %14, double* %3
	store double %16, double* %4
	%17 = load %fmt.Info*, %fmt.Info** %0, align 8
	%18 = load double, double* %3, align 8
	%19 = load i64, i64* %1, align 8
	%20 = sdiv i64 %19, 2
	%21 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %17, double %18, i64 %20, i32 %21, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%22 = load %fmt.Info*, %fmt.Info** %0, align 8
	%23 = getelementptr inbounds %fmt.Info, %fmt.Info* %22, i32 0, i32 1
	%24 = load i8, i8* %23, align 1
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.done-9, label %cmp.and-7

cmp.and-7:
	%26 = load double, double* %4, align 8
	%27 = fcmp oge double %26, 0x0000000000000000
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-8, label %if.done-9

if.then-8:
	; SelectorExpr
	; SelectorExpr
	%30 = load %fmt.Info*, %fmt.Info** %0, align 8
	%31 = getelementptr inbounds %fmt.Info, %fmt.Info* %30, i32 0, i32 12
	%32 = load %strings.Builder*, %strings.Builder** %31, align 8
	%33 = call i64 @strings.write_rune(%strings.Builder* %32, i32 43, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-9

if.done-9:
	%34 = load %fmt.Info*, %fmt.Info** %0, align 8
	%35 = load double, double* %4, align 8
	%36 = load i64, i64* %1, align 8
	%37 = sdiv i64 %36, 2
	%38 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %34, double %35, i64 %37, i32 %38, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%39 = load %fmt.Info*, %fmt.Info** %0, align 8
	%40 = getelementptr inbounds %fmt.Info, %fmt.Info* %39, i32 0, i32 12
	%41 = load %strings.Builder*, %strings.Builder** %40, align 8
	%42 = call i64 @strings.write_rune(%strings.Builder* %41, i32 105, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @fmt.fmt_quaternion(%fmt.Info* %_.0, %..quaternion256* %_.1, i64 %_.2, i32 %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i32, align 16
	%3 = alloca double, align 16
	%4 = alloca double, align 16
	%5 = alloca double, align 16
	%6 = alloca double, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store i64 %_.2, i64* %1
	store i32 %_.3, i32* %2
	; SwitchStmt
	%7 = load i32, i32* %2, align 4
	%8 = icmp eq i32 %7, 102
	br i1 %8, label %switch.case.body-6, label %switch.case.next-1

switch.case.next-1:
	%9 = icmp eq i32 %7, 70
	br i1 %9, label %switch.case.body-6, label %switch.case.next-2

switch.case.next-2:
	%10 = icmp eq i32 %7, 118
	br i1 %10, label %switch.case.body-6, label %switch.case.next-3

switch.case.next-3:
	%11 = icmp eq i32 %7, 104
	br i1 %11, label %switch.case.body-6, label %switch.case.next-4

switch.case.next-4:
	%12 = icmp eq i32 %7, 72
	br i1 %12, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%13 = load %fmt.Info*, %fmt.Info** %0, align 8
	%14 = load i32, i32* %2, align 4
	call void @fmt.fmt_bad_verb(%fmt.Info* %13, i32 %14, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

switch.case.body-6:
	; r
	; i
	; j
	; k
	; real
	%15 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%16 = extractvalue %..quaternion256 %15, 3
	; imag
	%17 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%18 = extractvalue %..quaternion256 %17, 0
	; jmag
	%19 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%20 = extractvalue %..quaternion256 %19, 1
	; kmag
	%21 = load %..quaternion256, %..quaternion256* %_.1, align 8
	%22 = extractvalue %..quaternion256 %21, 2
	store double %16, double* %3
	store double %18, double* %4
	store double %20, double* %5
	store double %22, double* %6
	%23 = load %fmt.Info*, %fmt.Info** %0, align 8
	%24 = load double, double* %3, align 8
	%25 = load i64, i64* %1, align 8
	%26 = sdiv i64 %25, 4
	%27 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %23, double %24, i64 %26, i32 %27, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%28 = load %fmt.Info*, %fmt.Info** %0, align 8
	%29 = getelementptr inbounds %fmt.Info, %fmt.Info* %28, i32 0, i32 1
	%30 = load i8, i8* %29, align 1
	%31 = trunc i8 %30 to i1
	br i1 %31, label %if.done-9, label %cmp.and-7

cmp.and-7:
	%32 = load double, double* %4, align 8
	%33 = fcmp oge double %32, 0x0000000000000000
	%34 = zext i1 %33 to i8
	%35 = trunc i8 %34 to i1
	br i1 %35, label %if.then-8, label %if.done-9

if.then-8:
	; SelectorExpr
	; SelectorExpr
	%36 = load %fmt.Info*, %fmt.Info** %0, align 8
	%37 = getelementptr inbounds %fmt.Info, %fmt.Info* %36, i32 0, i32 12
	%38 = load %strings.Builder*, %strings.Builder** %37, align 8
	%39 = call i64 @strings.write_rune(%strings.Builder* %38, i32 43, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-9

if.done-9:
	%40 = load %fmt.Info*, %fmt.Info** %0, align 8
	%41 = load double, double* %4, align 8
	%42 = load i64, i64* %1, align 8
	%43 = sdiv i64 %42, 4
	%44 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %40, double %41, i64 %43, i32 %44, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%45 = load %fmt.Info*, %fmt.Info** %0, align 8
	%46 = getelementptr inbounds %fmt.Info, %fmt.Info* %45, i32 0, i32 12
	%47 = load %strings.Builder*, %strings.Builder** %46, align 8
	%48 = call i64 @strings.write_rune(%strings.Builder* %47, i32 105, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%49 = load %fmt.Info*, %fmt.Info** %0, align 8
	%50 = getelementptr inbounds %fmt.Info, %fmt.Info* %49, i32 0, i32 1
	%51 = load i8, i8* %50, align 1
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.done-12, label %cmp.and-10

cmp.and-10:
	%53 = load double, double* %5, align 8
	%54 = fcmp oge double %53, 0x0000000000000000
	%55 = zext i1 %54 to i8
	%56 = trunc i8 %55 to i1
	br i1 %56, label %if.then-11, label %if.done-12

if.then-11:
	; SelectorExpr
	; SelectorExpr
	%57 = load %fmt.Info*, %fmt.Info** %0, align 8
	%58 = getelementptr inbounds %fmt.Info, %fmt.Info* %57, i32 0, i32 12
	%59 = load %strings.Builder*, %strings.Builder** %58, align 8
	%60 = call i64 @strings.write_rune(%strings.Builder* %59, i32 43, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-12

if.done-12:
	%61 = load %fmt.Info*, %fmt.Info** %0, align 8
	%62 = load double, double* %5, align 8
	%63 = load i64, i64* %1, align 8
	%64 = sdiv i64 %63, 4
	%65 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %61, double %62, i64 %64, i32 %65, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%66 = load %fmt.Info*, %fmt.Info** %0, align 8
	%67 = getelementptr inbounds %fmt.Info, %fmt.Info* %66, i32 0, i32 12
	%68 = load %strings.Builder*, %strings.Builder** %67, align 8
	%69 = call i64 @strings.write_rune(%strings.Builder* %68, i32 106, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%70 = load %fmt.Info*, %fmt.Info** %0, align 8
	%71 = getelementptr inbounds %fmt.Info, %fmt.Info* %70, i32 0, i32 1
	%72 = load i8, i8* %71, align 1
	%73 = trunc i8 %72 to i1
	br i1 %73, label %if.done-15, label %cmp.and-13

cmp.and-13:
	%74 = load double, double* %6, align 8
	%75 = fcmp oge double %74, 0x0000000000000000
	%76 = zext i1 %75 to i8
	%77 = trunc i8 %76 to i1
	br i1 %77, label %if.then-14, label %if.done-15

if.then-14:
	; SelectorExpr
	; SelectorExpr
	%78 = load %fmt.Info*, %fmt.Info** %0, align 8
	%79 = getelementptr inbounds %fmt.Info, %fmt.Info* %78, i32 0, i32 12
	%80 = load %strings.Builder*, %strings.Builder** %79, align 8
	%81 = call i64 @strings.write_rune(%strings.Builder* %80, i32 43, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-15

if.done-15:
	%82 = load %fmt.Info*, %fmt.Info** %0, align 8
	%83 = load double, double* %6, align 8
	%84 = load i64, i64* %1, align 8
	%85 = sdiv i64 %84, 4
	%86 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %82, double %83, i64 %85, i32 %86, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%87 = load %fmt.Info*, %fmt.Info** %0, align 8
	%88 = getelementptr inbounds %fmt.Info, %fmt.Info* %87, i32 0, i32 12
	%89 = load %strings.Builder*, %strings.Builder** %88, align 8
	%90 = call i64 @strings.write_rune(%strings.Builder* %89, i32 107, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @fmt.fmt_arg(%fmt.Info* %_.0, %..any %_.1, i32 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %fmt.Info*, align 16
	%1 = alloca %..any, align 16
	%2 = alloca i32, align 16
	%3 = alloca %runtime.Type_Info*, align 16
	%4 = alloca %runtime.Type_Info*, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	%6 = alloca %..any, align 16
	%7 = alloca i8, align 16
	%8 = alloca i8, align 16
	%9 = alloca i16, align 16
	%10 = alloca i32, align 16
	%11 = alloca i64, align 16
	%12 = alloca %..any, align 16
	%13 = alloca i32, align 16
	%14 = alloca float, align 16
	%15 = alloca double, align 16
	%16 = alloca %..complex64, align 16
	%17 = alloca %..complex128, align 16
	%18 = alloca %..complex128, align 16
	%19 = alloca %..quaternion128, align 16
	%20 = alloca %..quaternion256, align 16
	%21 = alloca %..quaternion256, align 16
	%22 = alloca i8, align 16
	%23 = alloca i8, align 16
	%24 = alloca i16, align 16
	%25 = alloca i16, align 16
	%26 = alloca i32, align 16
	%27 = alloca i32, align 16
	%28 = alloca i64, align 16
	%29 = alloca i64, align 16
	%30 = alloca i64, align 16
	%31 = alloca i64, align 16
	%32 = alloca i64, align 16
	%33 = alloca %..string, align 16
	%34 = alloca i8*, align 16
	%35 = alloca %..typeid, align 16
	%36 = alloca i16, align 16
	%37 = alloca i16, align 16
	%38 = alloca i32, align 16
	%39 = alloca i32, align 16
	%40 = alloca i64, align 16
	%41 = alloca i64, align 16
	%42 = alloca i16, align 16
	%43 = alloca i16, align 16
	%44 = alloca i32, align 16
	%45 = alloca i32, align 16
	%46 = alloca i64, align 16
	%47 = alloca i64, align 16
	%48 = alloca i128, align 16
	%49 = alloca i128, align 16
	%50 = alloca i128, align 16
	%51 = alloca i128, align 16
	%52 = alloca i128, align 16
	%53 = alloca i128, align 16
	%54 = alloca %..any, align 16
	store %fmt.Info* %_.0, %fmt.Info** %0
	store %..any %_.1, %..any* %1
	store i32 %_.2, i32* %2
	; IfStmt
	%55 = load %..any, %..any* %1, align 8
	%56 = extractvalue %..any %55, 0
	%57 = extractvalue %..any %55, 1
	%58 = icmp eq %..rawptr %56, null
	%59 = icmp eq %..typeid %57, 0
	%60 = zext i1 %58 to i8
	%61 = zext i1 %59 to i8
	%62 = or i8 %60, %61
	%63 = trunc i8 %62 to i1
	br i1 %63, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	; SelectorExpr
	%64 = load %fmt.Info*, %fmt.Info** %0, align 8
	%65 = getelementptr inbounds %fmt.Info, %fmt.Info* %64, i32 0, i32 12
	%66 = load %strings.Builder*, %strings.Builder** %65, align 8
	call void @strings.write_string(%strings.Builder* %66, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$ef, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	%67 = load %fmt.Info*, %fmt.Info** %0, align 8
	%68 = getelementptr inbounds %fmt.Info, %fmt.Info* %67, i32 0, i32 13
	%69 = load %..any, %..any* %1, align 8
	store %..any %69, %..any* %68
	; IfStmt
	%70 = load i32, i32* %2, align 4
	%71 = icmp eq i32 %70, 84
	%72 = zext i1 %71 to i8
	%73 = trunc i8 %72 to i1
	br i1 %73, label %if.then-3, label %if.done-7

if.then-3:
	; ti
	; SelectorExpr
	%74 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%75 = load %..typeid, %..typeid* %74, align 8
	%76 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %75)
	store %runtime.Type_Info* %76, %runtime.Type_Info** %3
	; TypeSwitchStmt
	%77 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%78 = load %..typeid, %..typeid* %77, align 8
	%79 = icmp eq %..typeid %78, 720575940379279371
	br i1 %79, label %typeswitch.body-5, label %typeswitch.next-4

typeswitch.next-4:
	br label %typeswitch.done-6

typeswitch.body-5:
	%80 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%81 = load %..rawptr, %..rawptr* %80, align 8
	%82 = bitcast %..rawptr %81 to %runtime.Type_Info**
	%83 = load %runtime.Type_Info*, %runtime.Type_Info** %82, align 8
	store %runtime.Type_Info* %83, %runtime.Type_Info** %4
	; AssignStmt
	%84 = load %runtime.Type_Info*, %runtime.Type_Info** %4, align 8
	store %runtime.Type_Info* %84, %runtime.Type_Info** %3
	br label %typeswitch.done-6

typeswitch.done-6:
	; SelectorExpr
	; SelectorExpr
	%85 = load %fmt.Info*, %fmt.Info** %0, align 8
	%86 = getelementptr inbounds %fmt.Info, %fmt.Info* %85, i32 0, i32 12
	%87 = load %strings.Builder*, %strings.Builder** %86, align 8
	%88 = load %runtime.Type_Info*, %runtime.Type_Info** %3, align 8
	call void @reflect.write_type(%strings.Builder* %87, %runtime.Type_Info* %88, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-7:
	; TypeSwitchStmt
	%89 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 1
	%90 = load %..typeid, %..typeid* %89, align 8
	%91 = icmp eq %..typeid %90, 3458764513820541013
	br i1 %91, label %typeswitch.body-9, label %typeswitch.next-8

typeswitch.next-8:
	br label %typeswitch.done-13

typeswitch.body-9:
	%92 = getelementptr inbounds %..any, %..any* %1, i32 0, i32 0
	%93 = load %..rawptr, %..rawptr* %92, align 8
	%94 = bitcast %..rawptr %93 to %runtime.Source_Code_Location*
	%95 = load %runtime.Source_Code_Location, %runtime.Source_Code_Location* %94, align 8
	store %runtime.Source_Code_Location %95, %runtime.Source_Code_Location* %5
	; IfStmt
	; SelectorExpr
	%96 = load %fmt.Info*, %fmt.Info** %0, align 8
	%97 = getelementptr inbounds %fmt.Info, %fmt.Info* %96, i32 0, i32 4
	%98 = load i8, i8* %97, align 1
	%99 = trunc i8 %98 to i1
	br i1 %99, label %cmp.and-10, label %if.done-12

cmp.and-10:
	%100 = load i32, i32* %2, align 4
	%101 = icmp eq i32 %100, 118
	%102 = zext i1 %101 to i8
	%103 = trunc i8 %102 to i1
	br i1 %103, label %if.then-11, label %if.done-12

if.then-11:
	; SelectorExpr
	; SelectorExpr
	%104 = load %fmt.Info*, %fmt.Info** %0, align 8
	%105 = getelementptr inbounds %fmt.Info, %fmt.Info* %104, i32 0, i32 12
	%106 = load %strings.Builder*, %strings.Builder** %105, align 8
	; SelectorExpr
	%107 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %5, i32 0, i32 0
	%108 = load %..string, %..string* %107, align 8
	call void @strings.write_string(%strings.Builder* %106, %..string %108, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%109 = load %fmt.Info*, %fmt.Info** %0, align 8
	%110 = getelementptr inbounds %fmt.Info, %fmt.Info* %109, i32 0, i32 12
	%111 = load %strings.Builder*, %strings.Builder** %110, align 8
	call void @strings.write_byte(%strings.Builder* %111, i8 40, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%112 = load %fmt.Info*, %fmt.Info** %0, align 8
	%113 = getelementptr inbounds %fmt.Info, %fmt.Info* %112, i32 0, i32 12
	%114 = load %strings.Builder*, %strings.Builder** %113, align 8
	; SelectorExpr
	%115 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %5, i32 0, i32 1
	%116 = load i64, i64* %115, align 8
	%117 = bitcast i64 %116 to i64
	call void @strings.write_i64(%strings.Builder* %114, i64 %117, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%118 = load %fmt.Info*, %fmt.Info** %0, align 8
	%119 = getelementptr inbounds %fmt.Info, %fmt.Info* %118, i32 0, i32 12
	%120 = load %strings.Builder*, %strings.Builder** %119, align 8
	call void @strings.write_byte(%strings.Builder* %120, i8 58, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%121 = load %fmt.Info*, %fmt.Info** %0, align 8
	%122 = getelementptr inbounds %fmt.Info, %fmt.Info* %121, i32 0, i32 12
	%123 = load %strings.Builder*, %strings.Builder** %122, align 8
	; SelectorExpr
	%124 = getelementptr inbounds %runtime.Source_Code_Location, %runtime.Source_Code_Location* %5, i32 0, i32 2
	%125 = load i64, i64* %124, align 8
	%126 = bitcast i64 %125 to i64
	call void @strings.write_i64(%strings.Builder* %123, i64 %126, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%127 = load %fmt.Info*, %fmt.Info** %0, align 8
	%128 = getelementptr inbounds %fmt.Info, %fmt.Info* %127, i32 0, i32 12
	%129 = load %strings.Builder*, %strings.Builder** %128, align 8
	call void @strings.write_byte(%strings.Builder* %129, i8 41, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-12:
	br label %typeswitch.done-13

typeswitch.done-13:
	; base_arg
	%130 = load %..any, %..any* %1, align 8
	store %..any %130, %..any* %6
	; AssignStmt
	; SelectorExpr
	%131 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	; SelectorExpr
	; SelectorExpr
	%132 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%133 = load %..typeid, %..typeid* %132, align 8
	%134 = call %..typeid @runtime.typeid_base(%..typeid %133)
	store %..typeid %134, %..typeid* %131
	; TypeSwitchStmt
	%135 = load %..any, %..any* %6, align 8
	%136 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%137 = load %..typeid, %..typeid* %136, align 8
	%138 = icmp eq %..typeid %137, 504403158265495572
	br i1 %138, label %typeswitch.body-15, label %typeswitch.next-14

typeswitch.next-14:
	%139 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%140 = load %..typeid, %..typeid* %139, align 8
	%141 = icmp eq %..typeid %140, 504403158265495639
	br i1 %141, label %typeswitch.body-17, label %typeswitch.next-16

typeswitch.body-15:
	%142 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%143 = load %..rawptr, %..rawptr* %142, align 8
	%144 = bitcast %..rawptr %143 to i8*
	%145 = load i8, i8* %144, align 1
	store i8 %145, i8* %7
	%146 = load %fmt.Info*, %fmt.Info** %0, align 8
	%147 = load i8, i8* %7, align 1
	%148 = load i32, i32* %2, align 4
	%149 = trunc i8 %147 to i1
	call void @fmt.fmt_bool(%fmt.Info* %146, i1 %149, i32 %148, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-16:
	%150 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%151 = load %..typeid, %..typeid* %150, align 8
	%152 = icmp eq %..typeid %151, 504403158265495640
	br i1 %152, label %typeswitch.body-19, label %typeswitch.next-18

typeswitch.body-17:
	%153 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%154 = load %..rawptr, %..rawptr* %153, align 8
	%155 = bitcast %..rawptr %154 to i8*
	%156 = load i8, i8* %155, align 1
	store i8 %156, i8* %8
	%157 = load %fmt.Info*, %fmt.Info** %0, align 8
	%158 = load i8, i8* %8, align 1
	%159 = icmp ne i8 %158, 0
	%160 = zext i1 %159 to i8
	%161 = load i32, i32* %2, align 4
	%162 = trunc i8 %160 to i1
	call void @fmt.fmt_bool(%fmt.Info* %157, i1 %162, i32 %161, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-18:
	%163 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%164 = load %..typeid, %..typeid* %163, align 8
	%165 = icmp eq %..typeid %164, 504403158265495641
	br i1 %165, label %typeswitch.body-21, label %typeswitch.next-20

typeswitch.body-19:
	%166 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%167 = load %..rawptr, %..rawptr* %166, align 8
	%168 = bitcast %..rawptr %167 to i16*
	%169 = load i16, i16* %168, align 2
	store i16 %169, i16* %9
	%170 = load %fmt.Info*, %fmt.Info** %0, align 8
	%171 = load i16, i16* %9, align 2
	%172 = icmp ne i16 %171, 0
	%173 = zext i1 %172 to i8
	%174 = load i32, i32* %2, align 4
	%175 = trunc i8 %173 to i1
	call void @fmt.fmt_bool(%fmt.Info* %170, i1 %175, i32 %174, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-20:
	%176 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%177 = load %..typeid, %..typeid* %176, align 8
	%178 = icmp eq %..typeid %177, 504403158265495642
	br i1 %178, label %typeswitch.body-23, label %typeswitch.next-22

typeswitch.body-21:
	%179 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%180 = load %..rawptr, %..rawptr* %179, align 8
	%181 = bitcast %..rawptr %180 to i32*
	%182 = load i32, i32* %181, align 4
	store i32 %182, i32* %10
	%183 = load %fmt.Info*, %fmt.Info** %0, align 8
	%184 = load i32, i32* %10, align 4
	%185 = icmp ne i32 %184, 0
	%186 = zext i1 %185 to i8
	%187 = load i32, i32* %2, align 4
	%188 = trunc i8 %186 to i1
	call void @fmt.fmt_bool(%fmt.Info* %183, i1 %188, i32 %187, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-22:
	%189 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%190 = load %..typeid, %..typeid* %189, align 8
	%191 = icmp eq %..typeid %190, 6
	br i1 %191, label %typeswitch.body-25, label %typeswitch.next-24

typeswitch.body-23:
	%192 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%193 = load %..rawptr, %..rawptr* %192, align 8
	%194 = bitcast %..rawptr %193 to i64*
	%195 = load i64, i64* %194, align 8
	store i64 %195, i64* %11
	%196 = load %fmt.Info*, %fmt.Info** %0, align 8
	%197 = load i64, i64* %11, align 8
	%198 = icmp ne i64 %197, 0
	%199 = zext i1 %198 to i8
	%200 = load i32, i32* %2, align 4
	%201 = trunc i8 %199 to i1
	call void @fmt.fmt_bool(%fmt.Info* %196, i1 %201, i32 %200, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-24:
	%202 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%203 = load %..typeid, %..typeid* %202, align 8
	%204 = icmp eq %..typeid %203, 4755801206503243840
	br i1 %204, label %typeswitch.body-27, label %typeswitch.next-26

typeswitch.body-25:
	%205 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%206 = load %..rawptr, %..rawptr* %205, align 8
	%207 = bitcast %..rawptr %206 to %..any*
	%208 = load %..any, %..any* %207, align 8
	store %..any %208, %..any* %12
	%209 = load %fmt.Info*, %fmt.Info** %0, align 8
	%210 = load %..any, %..any* %12, align 8
	%211 = load i32, i32* %2, align 4
	call void @fmt.fmt_arg(%fmt.Info* %209, %..any %210, i32 %211, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-26:
	%212 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%213 = load %..typeid, %..typeid* %212, align 8
	%214 = icmp eq %..typeid %213, 216172782113783899
	br i1 %214, label %typeswitch.body-29, label %typeswitch.next-28

typeswitch.body-27:
	%215 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%216 = load %..rawptr, %..rawptr* %215, align 8
	%217 = bitcast %..rawptr %216 to i32*
	%218 = load i32, i32* %217, align 4
	store i32 %218, i32* %13
	%219 = load %fmt.Info*, %fmt.Info** %0, align 8
	%220 = load i32, i32* %13, align 4
	%221 = load i32, i32* %2, align 4
	call void @fmt.fmt_rune(%fmt.Info* %219, i32 %220, i32 %221, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-28:
	%222 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%223 = load %..typeid, %..typeid* %222, align 8
	%224 = icmp eq %..typeid %223, 216172782113783900
	br i1 %224, label %typeswitch.body-31, label %typeswitch.next-30

typeswitch.body-29:
	%225 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%226 = load %..rawptr, %..rawptr* %225, align 8
	%227 = bitcast %..rawptr %226 to float*
	%228 = load float, float* %227, align 4
	store float %228, float* %14
	%229 = load %fmt.Info*, %fmt.Info** %0, align 8
	%230 = load float, float* %14, align 4
	%231 = fpext float %230 to double
	%232 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %229, double %231, i64 32, i32 %232, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-30:
	%233 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%234 = load %..typeid, %..typeid* %233, align 8
	%235 = icmp eq %..typeid %234, 288230376151711837
	br i1 %235, label %typeswitch.body-33, label %typeswitch.next-32

typeswitch.body-31:
	%236 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%237 = load %..rawptr, %..rawptr* %236, align 8
	%238 = bitcast %..rawptr %237 to double*
	%239 = load double, double* %238, align 8
	store double %239, double* %15
	%240 = load %fmt.Info*, %fmt.Info** %0, align 8
	%241 = load double, double* %15, align 8
	%242 = load i32, i32* %2, align 4
	call void @fmt.fmt_float(%fmt.Info* %240, double %241, i64 64, i32 %242, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-32:
	%243 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%244 = load %..typeid, %..typeid* %243, align 8
	%245 = icmp eq %..typeid %244, 288230376151711838
	br i1 %245, label %typeswitch.body-35, label %typeswitch.next-34

typeswitch.body-33:
	%246 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%247 = load %..rawptr, %..rawptr* %246, align 8
	%248 = bitcast %..rawptr %247 to %..complex64*
	%249 = load %..complex64, %..complex64* %248, align 4
	store %..complex64 %249, %..complex64* %16
	%250 = load %fmt.Info*, %fmt.Info** %0, align 8
	%251 = load %..complex64, %..complex64* %16, align 4
	%252 = extractvalue %..complex64 %251, 0
	%253 = fpext float %252 to double
	%254 = extractvalue %..complex64 %251, 1
	%255 = fpext float %254 to double
	%256 = getelementptr inbounds %..complex128, %..complex128* %17, i32 0, i32 0
	store double %253, double* %256
	%257 = getelementptr inbounds %..complex128, %..complex128* %17, i32 0, i32 1
	store double %255, double* %257
	%258 = load i32, i32* %2, align 4
	call void @fmt.fmt_complex(%fmt.Info* %250, %..complex128* %17, i64 64, i32 %258, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-34:
	%259 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%260 = load %..typeid, %..typeid* %259, align 8
	%261 = icmp eq %..typeid %260, 95
	br i1 %261, label %typeswitch.body-37, label %typeswitch.next-36

typeswitch.body-35:
	%262 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%263 = load %..rawptr, %..rawptr* %262, align 8
	%264 = bitcast %..rawptr %263 to %..complex128*
	%265 = load %..complex128, %..complex128* %264, align 8
	store %..complex128 %265, %..complex128* %18
	%266 = load %fmt.Info*, %fmt.Info** %0, align 8
	%267 = load i32, i32* %2, align 4
	call void @fmt.fmt_complex(%fmt.Info* %266, %..complex128* %18, i64 128, i32 %267, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-36:
	%268 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%269 = load %..typeid, %..typeid* %268, align 8
	%270 = icmp eq %..typeid %269, 96
	br i1 %270, label %typeswitch.body-39, label %typeswitch.next-38

typeswitch.body-37:
	%271 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%272 = load %..rawptr, %..rawptr* %271, align 8
	%273 = bitcast %..rawptr %272 to %..quaternion128*
	%274 = load %..quaternion128, %..quaternion128* %273, align 4
	store %..quaternion128 %274, %..quaternion128* %19
	%275 = load %fmt.Info*, %fmt.Info** %0, align 8
	%276 = load %..quaternion128, %..quaternion128* %19, align 4
	%277 = extractvalue %..quaternion128 %276, 0
	%278 = fpext float %277 to double
	%279 = extractvalue %..quaternion128 %276, 1
	%280 = fpext float %279 to double
	%281 = extractvalue %..quaternion128 %276, 2
	%282 = fpext float %281 to double
	%283 = extractvalue %..quaternion128 %276, 3
	%284 = fpext float %283 to double
	%285 = getelementptr inbounds %..quaternion256, %..quaternion256* %20, i32 0, i32 0
	store double %278, double* %285
	%286 = getelementptr inbounds %..quaternion256, %..quaternion256* %20, i32 0, i32 1
	store double %280, double* %286
	%287 = getelementptr inbounds %..quaternion256, %..quaternion256* %20, i32 0, i32 2
	store double %282, double* %287
	%288 = getelementptr inbounds %..quaternion256, %..quaternion256* %20, i32 0, i32 3
	store double %284, double* %288
	%289 = load i32, i32* %2, align 4
	call void @fmt.fmt_quaternion(%fmt.Info* %275, %..quaternion256* %20, i64 128, i32 %289, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-38:
	%290 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%291 = load %..typeid, %..typeid* %290, align 8
	%292 = icmp eq %..typeid %291, 4683743612465315905
	br i1 %292, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-39:
	%293 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%294 = load %..rawptr, %..rawptr* %293, align 8
	%295 = bitcast %..rawptr %294 to %..quaternion256*
	%296 = load %..quaternion256, %..quaternion256* %295, align 8
	store %..quaternion256 %296, %..quaternion256* %21
	%297 = load %fmt.Info*, %fmt.Info** %0, align 8
	%298 = load i32, i32* %2, align 4
	call void @fmt.fmt_quaternion(%fmt.Info* %297, %..quaternion256* %21, i64 256, i32 %298, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-40:
	%299 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%300 = load %..typeid, %..typeid* %299, align 8
	%301 = icmp eq %..typeid %300, 72057594037927939
	br i1 %301, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-41:
	%302 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%303 = load %..rawptr, %..rawptr* %302, align 8
	%304 = bitcast %..rawptr %303 to i8*
	%305 = load i8, i8* %304, align 1
	store i8 %305, i8* %22
	%306 = load %fmt.Info*, %fmt.Info** %0, align 8
	%307 = load i8, i8* %22, align 1
	%308 = sext i8 %307 to i64
	%309 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %306, i64 %308, i1 true, i64 8, i32 %309, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-42:
	%310 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%311 = load %..typeid, %..typeid* %310, align 8
	%312 = icmp eq %..typeid %311, 4683743612465315906
	br i1 %312, label %typeswitch.body-45, label %typeswitch.next-44

typeswitch.body-43:
	%313 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%314 = load %..rawptr, %..rawptr* %313, align 8
	%315 = bitcast %..rawptr %314 to i8*
	%316 = load i8, i8* %315, align 1
	store i8 %316, i8* %23
	%317 = load %fmt.Info*, %fmt.Info** %0, align 8
	%318 = load i8, i8* %23, align 1
	%319 = zext i8 %318 to i64
	%320 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %317, i64 %319, i1 false, i64 8, i32 %320, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-44:
	%321 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%322 = load %..typeid, %..typeid* %321, align 8
	%323 = icmp eq %..typeid %322, 72057594037928005
	br i1 %323, label %typeswitch.body-47, label %typeswitch.next-46

typeswitch.body-45:
	%324 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%325 = load %..rawptr, %..rawptr* %324, align 8
	%326 = bitcast %..rawptr %325 to i16*
	%327 = load i16, i16* %326, align 2
	store i16 %327, i16* %24
	%328 = load %fmt.Info*, %fmt.Info** %0, align 8
	%329 = load i16, i16* %24, align 2
	%330 = sext i16 %329 to i64
	%331 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %328, i64 %330, i1 true, i64 16, i32 %331, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-46:
	%332 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%333 = load %..typeid, %..typeid* %332, align 8
	%334 = icmp eq %..typeid %333, 4683743612465315907
	br i1 %334, label %typeswitch.body-49, label %typeswitch.next-48

typeswitch.body-47:
	%335 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%336 = load %..rawptr, %..rawptr* %335, align 8
	%337 = bitcast %..rawptr %336 to i16*
	%338 = load i16, i16* %337, align 2
	store i16 %338, i16* %25
	%339 = load %fmt.Info*, %fmt.Info** %0, align 8
	%340 = load i16, i16* %25, align 2
	%341 = zext i16 %340 to i64
	%342 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %339, i64 %341, i1 false, i64 16, i32 %342, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-48:
	%343 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%344 = load %..typeid, %..typeid* %343, align 8
	%345 = icmp eq %..typeid %344, 72057594037928006
	br i1 %345, label %typeswitch.body-51, label %typeswitch.next-50

typeswitch.body-49:
	%346 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%347 = load %..rawptr, %..rawptr* %346, align 8
	%348 = bitcast %..rawptr %347 to i32*
	%349 = load i32, i32* %348, align 4
	store i32 %349, i32* %26
	%350 = load %fmt.Info*, %fmt.Info** %0, align 8
	%351 = load i32, i32* %26, align 4
	%352 = sext i32 %351 to i64
	%353 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %350, i64 %352, i1 true, i64 32, i32 %353, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-50:
	%354 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%355 = load %..typeid, %..typeid* %354, align 8
	%356 = icmp eq %..typeid %355, 4683743612465315908
	br i1 %356, label %typeswitch.body-53, label %typeswitch.next-52

typeswitch.body-51:
	%357 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%358 = load %..rawptr, %..rawptr* %357, align 8
	%359 = bitcast %..rawptr %358 to i32*
	%360 = load i32, i32* %359, align 4
	store i32 %360, i32* %27
	%361 = load %fmt.Info*, %fmt.Info** %0, align 8
	%362 = load i32, i32* %27, align 4
	%363 = zext i32 %362 to i64
	%364 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %361, i64 %363, i1 false, i64 32, i32 %364, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-52:
	%365 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%366 = load %..typeid, %..typeid* %365, align 8
	%367 = icmp eq %..typeid %366, 72057594037928007
	br i1 %367, label %typeswitch.body-55, label %typeswitch.next-54

typeswitch.body-53:
	%368 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%369 = load %..rawptr, %..rawptr* %368, align 8
	%370 = bitcast %..rawptr %369 to i64*
	%371 = load i64, i64* %370, align 8
	store i64 %371, i64* %28
	%372 = load %fmt.Info*, %fmt.Info** %0, align 8
	%373 = load i64, i64* %28, align 8
	%374 = bitcast i64 %373 to i64
	%375 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %372, i64 %374, i1 true, i64 64, i32 %375, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-54:
	%376 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%377 = load %..typeid, %..typeid* %376, align 8
	%378 = icmp eq %..typeid %377, 4683743612465315844
	br i1 %378, label %typeswitch.body-57, label %typeswitch.next-56

typeswitch.body-55:
	%379 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%380 = load %..rawptr, %..rawptr* %379, align 8
	%381 = bitcast %..rawptr %380 to i64*
	%382 = load i64, i64* %381, align 8
	store i64 %382, i64* %29
	%383 = load %fmt.Info*, %fmt.Info** %0, align 8
	%384 = load i64, i64* %29, align 8
	%385 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %383, i64 %384, i1 false, i64 64, i32 %385, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-56:
	%386 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%387 = load %..typeid, %..typeid* %386, align 8
	%388 = icmp eq %..typeid %387, 72057594037928008
	br i1 %388, label %typeswitch.body-59, label %typeswitch.next-58

typeswitch.body-57:
	%389 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%390 = load %..rawptr, %..rawptr* %389, align 8
	%391 = bitcast %..rawptr %390 to i64*
	%392 = load i64, i64* %391, align 8
	store i64 %392, i64* %30
	%393 = load %fmt.Info*, %fmt.Info** %0, align 8
	%394 = load i64, i64* %30, align 8
	%395 = bitcast i64 %394 to i64
	%396 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %393, i64 %395, i1 true, i64 64, i32 %396, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-58:
	%397 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%398 = load %..typeid, %..typeid* %397, align 8
	%399 = icmp eq %..typeid %398, 72057594037927989
	br i1 %399, label %typeswitch.body-61, label %typeswitch.next-60

typeswitch.body-59:
	%400 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%401 = load %..rawptr, %..rawptr* %400, align 8
	%402 = bitcast %..rawptr %401 to i64*
	%403 = load i64, i64* %402, align 8
	store i64 %403, i64* %31
	%404 = load %fmt.Info*, %fmt.Info** %0, align 8
	%405 = load i64, i64* %31, align 8
	%406 = bitcast i64 %405 to i64
	%407 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %404, i64 %406, i1 false, i64 64, i32 %407, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-60:
	%408 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%409 = load %..typeid, %..typeid* %408, align 8
	%410 = icmp eq %..typeid %409, 432345564227567632
	br i1 %410, label %typeswitch.body-63, label %typeswitch.next-62

typeswitch.body-61:
	%411 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%412 = load %..rawptr, %..rawptr* %411, align 8
	%413 = bitcast %..rawptr %412 to i64*
	%414 = load i64, i64* %413, align 8
	store i64 %414, i64* %32
	%415 = load %fmt.Info*, %fmt.Info** %0, align 8
	%416 = load i64, i64* %32, align 8
	%417 = bitcast i64 %416 to i64
	%418 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %415, i64 %417, i1 false, i64 64, i32 %418, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-62:
	%419 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%420 = load %..typeid, %..typeid* %419, align 8
	%421 = icmp eq %..typeid %420, 5044031582654955617
	br i1 %421, label %typeswitch.body-65, label %typeswitch.next-64

typeswitch.body-63:
	%422 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%423 = load %..rawptr, %..rawptr* %422, align 8
	%424 = bitcast %..rawptr %423 to %..string*
	%425 = load %..string, %..string* %424, align 8
	store %..string %425, %..string* %33
	%426 = load %fmt.Info*, %fmt.Info** %0, align 8
	%427 = load %..string, %..string* %33, align 8
	%428 = load i32, i32* %2, align 4
	call void @fmt.fmt_string(%fmt.Info* %426, %..string %427, i32 %428, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-64:
	%429 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%430 = load %..typeid, %..typeid* %429, align 8
	%431 = icmp eq %..typeid %430, 8
	br i1 %431, label %typeswitch.body-67, label %typeswitch.next-66

typeswitch.body-65:
	%432 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%433 = load %..rawptr, %..rawptr* %432, align 8
	%434 = bitcast %..rawptr %433 to i8**
	%435 = load i8*, i8** %434, align 8
	store i8* %435, i8** %34
	%436 = load %fmt.Info*, %fmt.Info** %0, align 8
	%437 = load i8*, i8** %34, align 8
	%438 = load i32, i32* %2, align 4
	call void @fmt.fmt_cstring(%fmt.Info* %436, i8* %437, i32 %438, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-66:
	%439 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%440 = load %..typeid, %..typeid* %439, align 8
	%441 = icmp eq %..typeid %440, 4683743612465315938
	br i1 %441, label %typeswitch.body-69, label %typeswitch.next-68

typeswitch.body-67:
	%442 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%443 = load %..rawptr, %..rawptr* %442, align 8
	%444 = bitcast %..rawptr %443 to %..typeid*
	%445 = load %..typeid, %..typeid* %444, align 8
	store %..typeid %445, %..typeid* %35
	; SelectorExpr
	; SelectorExpr
	%446 = load %fmt.Info*, %fmt.Info** %0, align 8
	%447 = getelementptr inbounds %fmt.Info, %fmt.Info* %446, i32 0, i32 12
	%448 = load %strings.Builder*, %strings.Builder** %447, align 8
	%449 = load %..typeid, %..typeid* %35, align 8
	call void @reflect.write_typeid(%strings.Builder* %448, %..typeid %449, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-68:
	%450 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%451 = load %..typeid, %..typeid* %450, align 8
	%452 = icmp eq %..typeid %451, 72057594037928035
	br i1 %452, label %typeswitch.body-71, label %typeswitch.next-70

typeswitch.body-69:
	%453 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%454 = load %..rawptr, %..rawptr* %453, align 8
	%455 = bitcast %..rawptr %454 to i16*
	%456 = load i16, i16* %455, align 2
	store i16 %456, i16* %36
	%457 = load %fmt.Info*, %fmt.Info** %0, align 8
	%458 = load i16, i16* %36, align 2
	%459 = sext i16 %458 to i64
	%460 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %457, i64 %459, i1 true, i64 16, i32 %460, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-70:
	%461 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%462 = load %..typeid, %..typeid* %461, align 8
	%463 = icmp eq %..typeid %462, 4683743612465315940
	br i1 %463, label %typeswitch.body-73, label %typeswitch.next-72

typeswitch.body-71:
	%464 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%465 = load %..rawptr, %..rawptr* %464, align 8
	%466 = bitcast %..rawptr %465 to i16*
	%467 = load i16, i16* %466, align 2
	store i16 %467, i16* %37
	%468 = load %fmt.Info*, %fmt.Info** %0, align 8
	%469 = load i16, i16* %37, align 2
	%470 = zext i16 %469 to i64
	%471 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %468, i64 %470, i1 false, i64 16, i32 %471, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-72:
	%472 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%473 = load %..typeid, %..typeid* %472, align 8
	%474 = icmp eq %..typeid %473, 72057594037928037
	br i1 %474, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-73:
	%475 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%476 = load %..rawptr, %..rawptr* %475, align 8
	%477 = bitcast %..rawptr %476 to i32*
	%478 = load i32, i32* %477, align 4
	store i32 %478, i32* %38
	%479 = load %fmt.Info*, %fmt.Info** %0, align 8
	%480 = load i32, i32* %38, align 4
	%481 = sext i32 %480 to i64
	%482 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %479, i64 %481, i1 true, i64 32, i32 %482, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-74:
	%483 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%484 = load %..typeid, %..typeid* %483, align 8
	%485 = icmp eq %..typeid %484, 4683743612465315942
	br i1 %485, label %typeswitch.body-77, label %typeswitch.next-76

typeswitch.body-75:
	%486 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%487 = load %..rawptr, %..rawptr* %486, align 8
	%488 = bitcast %..rawptr %487 to i32*
	%489 = load i32, i32* %488, align 4
	store i32 %489, i32* %39
	%490 = load %fmt.Info*, %fmt.Info** %0, align 8
	%491 = load i32, i32* %39, align 4
	%492 = zext i32 %491 to i64
	%493 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %490, i64 %492, i1 false, i64 32, i32 %493, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-76:
	%494 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%495 = load %..typeid, %..typeid* %494, align 8
	%496 = icmp eq %..typeid %495, 72057594037928039
	br i1 %496, label %typeswitch.body-79, label %typeswitch.next-78

typeswitch.body-77:
	%497 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%498 = load %..rawptr, %..rawptr* %497, align 8
	%499 = bitcast %..rawptr %498 to i64*
	%500 = load i64, i64* %499, align 8
	store i64 %500, i64* %40
	%501 = load %fmt.Info*, %fmt.Info** %0, align 8
	%502 = load i64, i64* %40, align 8
	%503 = bitcast i64 %502 to i64
	%504 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %501, i64 %503, i1 true, i64 64, i32 %504, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-78:
	%505 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%506 = load %..typeid, %..typeid* %505, align 8
	%507 = icmp eq %..typeid %506, 4683743612465315944
	br i1 %507, label %typeswitch.body-81, label %typeswitch.next-80

typeswitch.body-79:
	%508 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%509 = load %..rawptr, %..rawptr* %508, align 8
	%510 = bitcast %..rawptr %509 to i64*
	%511 = load i64, i64* %510, align 8
	store i64 %511, i64* %41
	%512 = load %fmt.Info*, %fmt.Info** %0, align 8
	%513 = load i64, i64* %41, align 8
	%514 = bitcast i64 %513 to i64
	%515 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %512, i64 %514, i1 false, i64 64, i32 %515, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-80:
	%516 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%517 = load %..typeid, %..typeid* %516, align 8
	%518 = icmp eq %..typeid %517, 72057594037928041
	br i1 %518, label %typeswitch.body-83, label %typeswitch.next-82

typeswitch.body-81:
	%519 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%520 = load %..rawptr, %..rawptr* %519, align 8
	%521 = bitcast %..rawptr %520 to i16*
	%522 = load i16, i16* %521, align 2
	store i16 %522, i16* %42
	%523 = load %fmt.Info*, %fmt.Info** %0, align 8
	%524 = load i16, i16* %42, align 2
	%525 = call i16 @llvm.bswap.i16(i16 %524)
	%526 = sext i16 %525 to i64
	%527 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %523, i64 %526, i1 true, i64 16, i32 %527, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-82:
	%528 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%529 = load %..typeid, %..typeid* %528, align 8
	%530 = icmp eq %..typeid %529, 4683743612465315946
	br i1 %530, label %typeswitch.body-85, label %typeswitch.next-84

typeswitch.body-83:
	%531 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%532 = load %..rawptr, %..rawptr* %531, align 8
	%533 = bitcast %..rawptr %532 to i16*
	%534 = load i16, i16* %533, align 2
	store i16 %534, i16* %43
	%535 = load %fmt.Info*, %fmt.Info** %0, align 8
	%536 = load i16, i16* %43, align 2
	%537 = call i16 @llvm.bswap.i16(i16 %536)
	%538 = zext i16 %537 to i64
	%539 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %535, i64 %538, i1 false, i64 16, i32 %539, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-84:
	%540 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%541 = load %..typeid, %..typeid* %540, align 8
	%542 = icmp eq %..typeid %541, 72057594037928043
	br i1 %542, label %typeswitch.body-87, label %typeswitch.next-86

typeswitch.body-85:
	%543 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%544 = load %..rawptr, %..rawptr* %543, align 8
	%545 = bitcast %..rawptr %544 to i32*
	%546 = load i32, i32* %545, align 4
	store i32 %546, i32* %44
	%547 = load %fmt.Info*, %fmt.Info** %0, align 8
	%548 = load i32, i32* %44, align 4
	%549 = call i32 @llvm.bswap.i32(i32 %548)
	%550 = sext i32 %549 to i64
	%551 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %547, i64 %550, i1 true, i64 32, i32 %551, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-86:
	%552 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%553 = load %..typeid, %..typeid* %552, align 8
	%554 = icmp eq %..typeid %553, 4683743612465315948
	br i1 %554, label %typeswitch.body-89, label %typeswitch.next-88

typeswitch.body-87:
	%555 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%556 = load %..rawptr, %..rawptr* %555, align 8
	%557 = bitcast %..rawptr %556 to i32*
	%558 = load i32, i32* %557, align 4
	store i32 %558, i32* %45
	%559 = load %fmt.Info*, %fmt.Info** %0, align 8
	%560 = load i32, i32* %45, align 4
	%561 = call i32 @llvm.bswap.i32(i32 %560)
	%562 = zext i32 %561 to i64
	%563 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %559, i64 %562, i1 false, i64 32, i32 %563, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-88:
	%564 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%565 = load %..typeid, %..typeid* %564, align 8
	%566 = icmp eq %..typeid %565, 72057594037928045
	br i1 %566, label %typeswitch.body-91, label %typeswitch.next-90

typeswitch.body-89:
	%567 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%568 = load %..rawptr, %..rawptr* %567, align 8
	%569 = bitcast %..rawptr %568 to i64*
	%570 = load i64, i64* %569, align 8
	store i64 %570, i64* %46
	%571 = load %fmt.Info*, %fmt.Info** %0, align 8
	%572 = load i64, i64* %46, align 8
	%573 = call i64 @llvm.bswap.i64(i64 %572)
	%574 = bitcast i64 %573 to i64
	%575 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %571, i64 %574, i1 true, i64 64, i32 %575, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-90:
	%576 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%577 = load %..typeid, %..typeid* %576, align 8
	%578 = icmp eq %..typeid %577, 4683743612465315950
	br i1 %578, label %typeswitch.body-93, label %typeswitch.next-92

typeswitch.body-91:
	%579 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%580 = load %..rawptr, %..rawptr* %579, align 8
	%581 = bitcast %..rawptr %580 to i64*
	%582 = load i64, i64* %581, align 8
	store i64 %582, i64* %47
	%583 = load %fmt.Info*, %fmt.Info** %0, align 8
	%584 = load i64, i64* %47, align 8
	%585 = call i64 @llvm.bswap.i64(i64 %584)
	%586 = bitcast i64 %585 to i64
	%587 = load i32, i32* %2, align 4
	call void @fmt.fmt_int(%fmt.Info* %583, i64 %586, i1 false, i64 64, i32 %587, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-92:
	%588 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%589 = load %..typeid, %..typeid* %588, align 8
	%590 = icmp eq %..typeid %589, 72057594037928047
	br i1 %590, label %typeswitch.body-95, label %typeswitch.next-94

typeswitch.body-93:
	%591 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%592 = load %..rawptr, %..rawptr* %591, align 8
	%593 = bitcast %..rawptr %592 to i128*
	%594 = load i128, i128* %593, align 8
	store i128 %594, i128* %48
	%595 = load %fmt.Info*, %fmt.Info** %0, align 8
	%596 = load i128, i128* %48, align 8
	%597 = bitcast i128 %596 to i128
	%598 = load i32, i32* %2, align 4
	%599 = bitcast i128 %597 to <2 x i64>
	call void @fmt.fmt_int_128(%fmt.Info* %595, <2 x i64> %599, i1 true, i64 128, i32 %598, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-94:
	%600 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%601 = load %..typeid, %..typeid* %600, align 8
	%602 = icmp eq %..typeid %601, 4683743612465315952
	br i1 %602, label %typeswitch.body-97, label %typeswitch.next-96

typeswitch.body-95:
	%603 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%604 = load %..rawptr, %..rawptr* %603, align 8
	%605 = bitcast %..rawptr %604 to i128*
	%606 = load i128, i128* %605, align 8
	store i128 %606, i128* %49
	%607 = load %fmt.Info*, %fmt.Info** %0, align 8
	%608 = load i128, i128* %49, align 8
	%609 = load i32, i32* %2, align 4
	%610 = bitcast i128 %608 to <2 x i64>
	call void @fmt.fmt_int_128(%fmt.Info* %607, <2 x i64> %610, i1 false, i64 128, i32 %609, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-96:
	%611 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%612 = load %..typeid, %..typeid* %611, align 8
	%613 = icmp eq %..typeid %612, 72057594037928049
	br i1 %613, label %typeswitch.body-99, label %typeswitch.next-98

typeswitch.body-97:
	%614 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%615 = load %..rawptr, %..rawptr* %614, align 8
	%616 = bitcast %..rawptr %615 to i128*
	%617 = load i128, i128* %616, align 8
	store i128 %617, i128* %50
	%618 = load %fmt.Info*, %fmt.Info** %0, align 8
	%619 = load i128, i128* %50, align 8
	%620 = bitcast i128 %619 to i128
	%621 = load i32, i32* %2, align 4
	%622 = bitcast i128 %620 to <2 x i64>
	call void @fmt.fmt_int_128(%fmt.Info* %618, <2 x i64> %622, i1 true, i64 128, i32 %621, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-98:
	%623 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%624 = load %..typeid, %..typeid* %623, align 8
	%625 = icmp eq %..typeid %624, 4683743612465315954
	br i1 %625, label %typeswitch.body-101, label %typeswitch.next-100

typeswitch.body-99:
	%626 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%627 = load %..rawptr, %..rawptr* %626, align 8
	%628 = bitcast %..rawptr %627 to i128*
	%629 = load i128, i128* %628, align 8
	store i128 %629, i128* %51
	%630 = load %fmt.Info*, %fmt.Info** %0, align 8
	%631 = load i128, i128* %51, align 8
	%632 = bitcast i128 %631 to i128
	%633 = load i32, i32* %2, align 4
	%634 = bitcast i128 %632 to <2 x i64>
	call void @fmt.fmt_int_128(%fmt.Info* %630, <2 x i64> %634, i1 false, i64 128, i32 %633, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-100:
	%635 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 1
	%636 = load %..typeid, %..typeid* %635, align 8
	%637 = icmp eq %..typeid %636, 72057594037928051
	br i1 %637, label %typeswitch.body-103, label %typeswitch.next-102

typeswitch.body-101:
	%638 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%639 = load %..rawptr, %..rawptr* %638, align 8
	%640 = bitcast %..rawptr %639 to i128*
	%641 = load i128, i128* %640, align 8
	store i128 %641, i128* %52
	%642 = load %fmt.Info*, %fmt.Info** %0, align 8
	%643 = load i128, i128* %52, align 8
	%644 = call i128 @llvm.bswap.i128(i128 %643)
	%645 = bitcast i128 %644 to i128
	%646 = load i32, i32* %2, align 4
	%647 = bitcast i128 %645 to <2 x i64>
	call void @fmt.fmt_int_128(%fmt.Info* %642, <2 x i64> %647, i1 true, i64 128, i32 %646, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.next-102:
	store %..any %135, %..any* %54
	%648 = load %fmt.Info*, %fmt.Info** %0, align 8
	%649 = load %..any, %..any* %1, align 8
	%650 = load i32, i32* %2, align 4
	call void @fmt.fmt_value(%fmt.Info* %648, %..any %649, i32 %650, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.body-103:
	%651 = getelementptr inbounds %..any, %..any* %6, i32 0, i32 0
	%652 = load %..rawptr, %..rawptr* %651, align 8
	%653 = bitcast %..rawptr %652 to i128*
	%654 = load i128, i128* %653, align 8
	store i128 %654, i128* %53
	%655 = load %fmt.Info*, %fmt.Info** %0, align 8
	%656 = load i128, i128* %53, align 8
	%657 = call i128 @llvm.bswap.i128(i128 %656)
	%658 = bitcast i128 %657 to i128
	%659 = load i32, i32* %2, align 4
	%660 = bitcast i128 %658 to <2 x i64>
	call void @fmt.fmt_int_128(%fmt.Info* %655, <2 x i64> %660, i1 false, i64 128, i32 %659, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-104

typeswitch.done-104:
	ret void
}

define %..rawptr @mem.alloc(i64 %_.0, i64 %_.1, %mem.Allocator* %_.2, %runtime.Source_Code_Location* %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	store i64 %_.0, i64* %0
	store i64 %_.1, i64* %1
	; IfStmt
	%2 = load i64, i64* %0, align 8
	%3 = icmp eq i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	; SelectorExpr
	%6 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %_.2, i32 0, i32 0
	%7 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %6, align 8
	%8 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %7, zeroinitializer
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-4:
	; ReturnStmt
	; SelectorExpr
	%11 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %_.2, i32 0, i32 0
	%12 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %11, align 8
	; SelectorExpr
	%13 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %_.2, i32 0, i32 1
	%14 = load %..rawptr, %..rawptr* %13, align 8
	%15 = load i64, i64* %0, align 8
	%16 = load i64, i64* %1, align 8
	%17 = call %..rawptr %12(%..rawptr %14, i8 0, i64 %15, i64 %16, %..rawptr zeroinitializer, i64 0, i64 0, %runtime.Source_Code_Location* %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	ret %..rawptr %17
}

define void @mem.free(%..rawptr %_.0, %mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	store %..rawptr %_.0, %..rawptr* %0
	; IfStmt
	%1 = load %..rawptr, %..rawptr* %0, align 8
	%2 = icmp eq %..rawptr %1, zeroinitializer
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; IfStmt
	; SelectorExpr
	%5 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %_.1, i32 0, i32 0
	%6 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %5, align 8
	%7 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %6, zeroinitializer
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; SelectorExpr
	%10 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %_.1, i32 0, i32 0
	%11 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %10, align 8
	; SelectorExpr
	%12 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %_.1, i32 0, i32 1
	%13 = load %..rawptr, %..rawptr* %12, align 8
	%14 = load %..rawptr, %..rawptr* %0, align 8
	%15 = call %..rawptr %11(%..rawptr %13, i8 1, i64 0, i64 0, %..rawptr %14, i64 0, i64 0, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	ret void
}

define %..rawptr @mem.set(%..rawptr %_.0, i8 %_.1, i64 %_.2) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i8 %_.1, i8* %1
	store i64 %_.2, i64* %2
	; IfStmt
	%3 = load %..rawptr, %..rawptr* %0, align 8
	%4 = icmp eq %..rawptr %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	%7 = load i64, i64* %2, align 8
	%8 = icmp slt i64 %7, 0
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%11 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %11

if.done-4:
	%12 = load %..rawptr, %..rawptr* %0, align 8
	%13 = load i8, i8* %1, align 1
	%14 = load i64, i64* %2, align 8
	call void @llvm.memset.p0i8.i64(%..rawptr %12, i8 %13, i64 %14, i32 1, i1 false)
	; ReturnStmt
	%15 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %15
}
declare void @llvm.memset.p0i8.i64(%..rawptr, i8, i64, i32, i1) #0 

define %..rawptr @mem.zero(%..rawptr %_.0, i64 %_.1) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i64 %_.1, i64* %1
	; ReturnStmt
	%2 = load %..rawptr, %..rawptr* %0, align 8
	%3 = load i64, i64* %1, align 8
	%4 = call %..rawptr @mem.set(%..rawptr %2, i8 0, i64 %3) alwaysinline
	ret %..rawptr %4
}

define %..rawptr @mem.copy(%..rawptr %_.0, %..rawptr %_.1, i64 %_.2) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store %..rawptr %_.1, %..rawptr* %1
	store i64 %_.2, i64* %2
	; IfStmt
	%3 = load %..rawptr, %..rawptr* %1, align 8
	%4 = icmp eq %..rawptr %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%7 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %7

if.done-2:
	%8 = load %..rawptr, %..rawptr* %0, align 8
	%9 = load %..rawptr, %..rawptr* %1, align 8
	%10 = load i64, i64* %2, align 8
	call void @llvm.memmove.p0i8.p0i8.i64(%..rawptr %8, %..rawptr %9, i64 %10, i32 1, i1 false)
	; ReturnStmt
	%11 = load %..rawptr, %..rawptr* %0, align 8
	ret %..rawptr %11
}
declare void @llvm.memmove.p0i8.p0i8.i64(%..rawptr, %..rawptr, i64, i32, i1) #0 

define i8 @mem.is_power_of_two(i64 %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	%1 = load i64, i64* %0, align 8
	%2 = icmp ule i64 %1, 0
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ReturnStmt
	%5 = load i64, i64* %0, align 8
	%6 = load i64, i64* %0, align 8
	%7 = sub i64 %6, 1
	%8 = and i64 %5, %7
	%9 = icmp eq i64 %8, 0
	%10 = zext i1 %9 to i8
	ret i8 %10
}

define i64 @mem.align_forward_uintptr(i64 %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store i64 %_.0, i64* %0
	store i64 %_.1, i64* %1
	%6 = load i64, i64* %1, align 8
	%7 = call i8 @mem.is_power_of_two(i64 %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%8 = trunc i8 %7 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([58 x i8], [58 x i8]* @str$f0, i32 0, i32 0), i64 57}, i64 187, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$f1, i32 0, i32 0), i64 21}, i64 13766745459154569500}, %runtime.Source_Code_Location* %2
	%9 = call i8 @runtime.assert(i1 %8, %..string zeroinitializer, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; a
	%10 = load i64, i64* %1, align 8
	store i64 %10, i64* %3
	; p
	%11 = load i64, i64* %0, align 8
	store i64 %11, i64* %4
	; modulo
	%12 = load i64, i64* %4, align 8
	%13 = load i64, i64* %3, align 8
	%14 = sub i64 %13, 1
	%15 = and i64 %12, %14
	store i64 %15, i64* %5
	; IfStmt
	%16 = load i64, i64* %5, align 8
	%17 = icmp ne i64 %16, 0
	%18 = zext i1 %17 to i8
	%19 = trunc i8 %18 to i1
	br i1 %19, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%20 = load i64, i64* %3, align 8
	%21 = load i64, i64* %5, align 8
	%22 = sub i64 %20, %21
	%23 = load i64, i64* %4, align 8
	%24 = add i64 %23, %22
	store i64 %24, i64* %4
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%25 = load i64, i64* %4, align 8
	ret i64 %25
}

define %..rawptr @mem.nil_allocator_proc(%..rawptr %_.0, i8 %_.1, i64 %_.2, i64 %_.3, %..rawptr %_.4, i64 %_.5, i64 %_.6, %runtime.Source_Code_Location* %_.7, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i8 %_.1, i8* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store %..rawptr %_.4, %..rawptr* %4
	store i64 %_.5, i64* %5
	store i64 %_.6, i64* %6
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define void @mem.nil_allocator(%mem.Allocator* sret noalias %agg.result, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	; ReturnStmt
	; CompoundLit
	; ZeroInit
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0, align 1
	store %mem.Allocator {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* zeroinitializer, %..rawptr zeroinitializer}, %mem.Allocator* %0
	%1 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @mem.nil_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	%2 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i32 0, i32 0
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %1, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %2
	%3 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i32 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %3
	%4 = load %mem.Allocator, %mem.Allocator* %0, align 8
	store %mem.Allocator %4, %mem.Allocator* %agg.result
	ret void
}

define void @mem.scratch_allocator_init(%mem.Scratch_Allocator* %_.0, {i8*, i64}* %_.1, %mem.Allocator* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Scratch_Allocator*, align 16
	store %mem.Scratch_Allocator* %_.0, %mem.Scratch_Allocator** %0
	; AssignStmt
	; SelectorExpr
	%1 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%2 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %1, i32 0, i32 0
	%3 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	store {i8*, i64} %3, {i8*, i64}* %2
	; AssignStmt
	; SelectorExpr
	%4 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%5 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %4, i32 0, i32 1
	store i64 0, i64* %5
	; AssignStmt
	; SelectorExpr
	%6 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%7 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %6, i32 0, i32 2
	store i64 0, i64* %7
	; AssignStmt
	; SelectorExpr
	%8 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %0, align 8
	%9 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %8, i32 0, i32 3
	%10 = load %mem.Allocator, %mem.Allocator* %_.2, align 8
	store %mem.Allocator %10, %mem.Allocator* %9
	ret void
}

define %..rawptr @mem.scratch_allocator_proc(%..rawptr %_.0, i8 %_.1, i64 %_.2, i64 %_.3, %..rawptr %_.4, i64 %_.5, i64 %_.6, %runtime.Source_Code_Location* %_.7, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %mem.Scratch_Allocator*, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	%9 = alloca {i8*, i64}, align 16
	%10 = alloca i64, align 16
	%11 = alloca i8*, align 16
	%12 = alloca i64, align 16
	%13 = alloca i8*, align 16
	%14 = alloca %mem.Allocator, align 16
	%15 = alloca %..rawptr, align 16
	%16 = alloca %runtime.Source_Code_Location, align 16
	%17 = alloca {%..rawptr*, i64, i64, %mem.Allocator}, align 16
	%18 = alloca %runtime.Source_Code_Location, align 16
	%19 = alloca %..rawptr, align 16
	%20 = alloca i64, align 16
	%21 = alloca %..rawptr, align 16
	%22 = alloca i64, align 16
	%23 = alloca %runtime.Source_Code_Location, align 16
	%24 = alloca %..rawptr, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i8 %_.1, i8* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store %..rawptr %_.4, %..rawptr* %4
	store i64 %_.5, i64* %5
	store i64 %_.6, i64* %6
	; scratch
	%25 = load %..rawptr, %..rawptr* %0, align 8
	%26 = bitcast %..rawptr %25 to %mem.Scratch_Allocator*
	store %mem.Scratch_Allocator* %26, %mem.Scratch_Allocator** %7
	; IfStmt
	; SelectorExpr
	%27 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%28 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %27, i32 0, i32 0
	%29 = load {i8*, i64}, {i8*, i64}* %28, align 8
	%30 = extractvalue {i8*, i64} %29, 0
	%31 = extractvalue {i8*, i64} %29, 1
	%32 = bitcast %..rawptr null to i8*
	%33 = icmp eq i8* %30, %32
	%34 = icmp eq i64 %31, 0
	%35 = zext i1 %33 to i8
	%36 = zext i1 %34 to i8
	%37 = or i8 %35, %36
	%38 = trunc i8 %37 to i1
	br i1 %38, label %if.then-1, label %if.done-2

if.then-1:
	%39 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	; SelectorExpr
	%40 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$f2, i32 0, i32 0), i64 64}, i64 119, i64 35, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$f3, i32 0, i32 0), i64 22}, i64 15949023725646693122}, %runtime.Source_Code_Location* %8
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %9, align 1
	call void @mem.make_slice-6890({i8*, i64}* %9, i64 4194304, %mem.Allocator* %40, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	%41 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 0
	call void @mem.scratch_allocator_init(%mem.Scratch_Allocator* %39, {i8*, i64}* %9, %mem.Allocator* %41, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SwitchStmt
	%42 = load i8, i8* %1, align 1
	%43 = icmp eq i8 %42, 0
	br i1 %43, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%44 = icmp eq i8 %42, 1
	br i1 %44, label %switch.fall.body-14, label %switch.case.next-13

switch.case.body-4:
	; SwitchStmt
	; SelectorExpr
	%45 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%46 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %45, i32 0, i32 1
	%47 = load i64, i64* %46, align 8
	%48 = load i64, i64* %2, align 8
	%49 = add i64 %47, %48
	; SelectorExpr
	%50 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%51 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %50, i32 0, i32 0
	%52 = load {i8*, i64}, {i8*, i64}* %51, align 8
	%53 = extractvalue {i8*, i64} %52, 1
	%54 = icmp sle i64 %49, %53
	%55 = zext i1 %54 to i8
	%56 = icmp eq i8 1, %55
	br i1 %56, label %switch.case.body-6, label %switch.case.next-5

switch.case.next-5:
	%57 = load i64, i64* %2, align 8
	; SelectorExpr
	%58 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%59 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %58, i32 0, i32 0
	%60 = load {i8*, i64}, {i8*, i64}* %59, align 8
	%61 = extractvalue {i8*, i64} %60, 1
	%62 = icmp sle i64 %57, %61
	%63 = zext i1 %62 to i8
	%64 = icmp eq i8 1, %63
	br i1 %64, label %switch.fall.body-8, label %switch.case.next-7

switch.case.body-6:
	; offset
	; SelectorExpr
	%65 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%66 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %65, i32 0, i32 1
	%67 = load i64, i64* %66, align 8
	%68 = bitcast i64 %67 to i64
	%69 = load i64, i64* %3, align 8
	%70 = bitcast i64 %69 to i64
	%71 = call i64 @mem.align_forward_uintptr(i64 %68, i64 %70, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store i64 %71, i64* %10
	; ptr
	; IndexExpr
	; SelectorExpr
	%72 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%73 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %72, i32 0, i32 0
	%74 = load {i8*, i64}, {i8*, i64}* %73, align 8
	%75 = extractvalue {i8*, i64} %74, 0
	%76 = load i64, i64* %10, align 8
	%77 = bitcast i64 %76 to i64
	%78 = extractvalue {i8*, i64} %74, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$f4, i32 0, i32 0), i64 64}, i64 127, i64 25, i64 %77, i64 %78)
	%79 = getelementptr inbounds i8, i8* %75, i64 %77
	store i8* %79, i8** %11
	%80 = load i8*, i8** %11, align 8
	%81 = load i64, i64* %2, align 8
	%82 = bitcast i8* %80 to %..rawptr
	%83 = call %..rawptr @mem.zero(%..rawptr %82, i64 %81)
	; AssignStmt
	; SelectorExpr
	%84 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%85 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %84, i32 0, i32 2
	%86 = load i64, i64* %10, align 8
	%87 = bitcast i64 %86 to i64
	store i64 %87, i64* %85
	; AssignStmt
	; SelectorExpr
	%88 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%89 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %88, i32 0, i32 1
	%90 = load i64, i64* %10, align 8
	%91 = bitcast i64 %90 to i64
	%92 = load i64, i64* %2, align 8
	%93 = add i64 %91, %92
	store i64 %93, i64* %89
	; ReturnStmt
	%94 = load i8*, i8** %11, align 8
	%95 = bitcast i8* %94 to %..rawptr
	ret %..rawptr %95

switch.case.next-7:
	; a
	; SelectorExpr
	%96 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%97 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %96, i32 0, i32 3
	%98 = load %mem.Allocator, %mem.Allocator* %97, align 8
	store %mem.Allocator %98, %mem.Allocator* %14
	; IfStmt
	; SelectorExpr
	%99 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %14, i32 0, i32 0
	%100 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %99, align 8
	%101 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %100, zeroinitializer
	%102 = zext i1 %101 to i8
	%103 = trunc i8 %102 to i1
	br i1 %103, label %if.then-9, label %if.done-10

switch.fall.body-8:
	; offset
	%104 = load i64, i64* %3, align 8
	%105 = bitcast i64 %104 to i64
	%106 = call i64 @mem.align_forward_uintptr(i64 0, i64 %105, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store i64 %106, i64* %12
	; ptr
	; IndexExpr
	; SelectorExpr
	%107 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%108 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %107, i32 0, i32 0
	%109 = load {i8*, i64}, {i8*, i64}* %108, align 8
	%110 = extractvalue {i8*, i64} %109, 0
	%111 = load i64, i64* %12, align 8
	%112 = bitcast i64 %111 to i64
	%113 = extractvalue {i8*, i64} %109, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$f5, i32 0, i32 0), i64 64}, i64 134, i64 25, i64 %112, i64 %113)
	%114 = getelementptr inbounds i8, i8* %110, i64 %112
	store i8* %114, i8** %13
	%115 = load i8*, i8** %13, align 8
	%116 = load i64, i64* %2, align 8
	%117 = bitcast i8* %115 to %..rawptr
	%118 = call %..rawptr @mem.zero(%..rawptr %117, i64 %116)
	; AssignStmt
	; SelectorExpr
	%119 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%120 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %119, i32 0, i32 2
	%121 = load i64, i64* %12, align 8
	%122 = bitcast i64 %121 to i64
	store i64 %122, i64* %120
	; AssignStmt
	; SelectorExpr
	%123 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%124 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %123, i32 0, i32 1
	%125 = load i64, i64* %12, align 8
	%126 = bitcast i64 %125 to i64
	%127 = load i64, i64* %2, align 8
	%128 = add i64 %126, %127
	store i64 %128, i64* %124
	; ReturnStmt
	%129 = load i8*, i8** %13, align 8
	%130 = bitcast i8* %129 to %..rawptr
	ret %..rawptr %130

if.then-9:
	; AssignStmt
	; SelectorExpr
	%131 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 0
	%132 = load %mem.Allocator, %mem.Allocator* %131, align 8
	store %mem.Allocator %132, %mem.Allocator* %14
	; AssignStmt
	; SelectorExpr
	%133 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%134 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %133, i32 0, i32 3
	%135 = load %mem.Allocator, %mem.Allocator* %14, align 8
	store %mem.Allocator %135, %mem.Allocator* %134
	br label %if.done-10

if.done-10:
	; ptr
	%136 = load i64, i64* %2, align 8
	%137 = load i64, i64* %3, align 8
	%138 = call %..rawptr @mem.alloc(i64 %136, i64 %137, %mem.Allocator* %14, %runtime.Source_Code_Location* %_.7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %..rawptr %138, %..rawptr* %15
	; IfStmt
	; SelectorExpr
	%139 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%140 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %139, i32 0, i32 4
	%141 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %140, align 8
	%142 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %141, 0
	%143 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %141, 2
	%144 = bitcast %..rawptr null to %..rawptr*
	%145 = icmp eq %..rawptr* %142, %144
	%146 = icmp eq i64 %143, 0
	%147 = zext i1 %145 to i8
	%148 = zext i1 %146 to i8
	%149 = or i8 %147, %148
	%150 = trunc i8 %149 to i1
	br i1 %150, label %if.then-11, label %if.done-12

if.then-11:
	; AssignStmt
	; SelectorExpr
	%151 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%152 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %151, i32 0, i32 4
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$f6, i32 0, i32 0), i64 64}, i64 149, i64 33, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$f7, i32 0, i32 0), i64 22}, i64 15949129278762973042}, %runtime.Source_Code_Location* %16
	%153 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %17 to %..rawptr
	; ZeroInit
	store {%..rawptr*, i64, i64, %mem.Allocator} zeroinitializer, {%..rawptr*, i64, i64, %mem.Allocator}* %17, align 1
	call void @mem.make_dynamic_array-6944({%..rawptr*, i64, i64, %mem.Allocator}* %17, %mem.Allocator* %14, %runtime.Source_Code_Location* %16, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%154 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %17, align 8
	store {%..rawptr*, i64, i64, %mem.Allocator} %154, {%..rawptr*, i64, i64, %mem.Allocator}* %152
	br label %if.done-12

if.done-12:
	; SelectorExpr
	%155 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%156 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %155, i32 0, i32 4
	%157 = load %..rawptr, %..rawptr* %15, align 8
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$f8, i32 0, i32 0), i64 64}, i64 151, i64 3, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$f9, i32 0, i32 0), i64 22}, i64 15949094094390900674}, %runtime.Source_Code_Location* %18
	call void @runtime.append_elem-6987({%..rawptr*, i64, i64, %mem.Allocator}* %156, %..rawptr %157, %runtime.Source_Code_Location* %18, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	%158 = load %..rawptr, %..rawptr* %15, align 8
	ret %..rawptr %158

switch.case.next-13:
	%159 = icmp eq i8 %42, 2
	br i1 %159, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-14:
	; last_ptr
	; IndexExpr
	; SelectorExpr
	%160 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%161 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %160, i32 0, i32 0
	%162 = load {i8*, i64}, {i8*, i64}* %161, align 8
	%163 = extractvalue {i8*, i64} %162, 0
	; SelectorExpr
	%164 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%165 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %164, i32 0, i32 2
	%166 = load i64, i64* %165, align 8
	%167 = extractvalue {i8*, i64} %162, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$fa, i32 0, i32 0), i64 64}, i64 156, i64 44, i64 %166, i64 %167)
	%168 = getelementptr inbounds i8, i8* %163, i64 %166
	%169 = bitcast i8* %168 to %..rawptr
	store %..rawptr %169, %..rawptr* %19
	; IfStmt
	%170 = load %..rawptr, %..rawptr* %4, align 8
	%171 = load %..rawptr, %..rawptr* %19, align 8
	%172 = icmp eq %..rawptr %170, %171
	%173 = zext i1 %172 to i8
	%174 = trunc i8 %173 to i1
	br i1 %174, label %if.then-15, label %if.done-16

if.then-15:
	; full_size
	; SelectorExpr
	%175 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%176 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %175, i32 0, i32 1
	%177 = load i64, i64* %176, align 8
	; SelectorExpr
	%178 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%179 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %178, i32 0, i32 2
	%180 = load i64, i64* %179, align 8
	%181 = sub i64 %177, %180
	store i64 %181, i64* %20
	; AssignStmt
	; SelectorExpr
	%182 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%183 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %182, i32 0, i32 1
	; SelectorExpr
	%184 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%185 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %184, i32 0, i32 2
	%186 = load i64, i64* %185, align 8
	store i64 %186, i64* %183
	%187 = load %..rawptr, %..rawptr* %19, align 8
	%188 = load i64, i64* %20, align 8
	%189 = call %..rawptr @mem.zero(%..rawptr %187, i64 %188)
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-16:
	br label %switch.done-27

switch.case.next-17:
	%190 = icmp eq i8 %42, 3
	br i1 %190, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-18:
	; AssignStmt
	; SelectorExpr
	%191 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%192 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %191, i32 0, i32 1
	store i64 0, i64* %192
	; AssignStmt
	; SelectorExpr
	%193 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%194 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %193, i32 0, i32 2
	store i64 0, i64* %194
	; RangeStmt
	; ptr
	; ZeroInit
	store %..rawptr zeroinitializer, %..rawptr* %21, align 1
	; SelectorExpr
	%195 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%196 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %195, i32 0, i32 4
	%197 = getelementptr inbounds {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %196, i32 0, i32 1
	store i64 -1, i64* %22
	br label %for.index.loop-19

for.index.loop-19:
	%198 = load i64, i64* %22, align 8
	%199 = add i64 %198, 1
	store i64 %199, i64* %22
	%200 = load i64, i64* %197, align 8
	%201 = icmp slt i64 %199, %200
	br i1 %201, label %for.index.body-20, label %for.index.done-21

for.index.body-20:
	%202 = load i64, i64* %22, align 8
	%203 = getelementptr inbounds {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %196, i32 0, i32 0
	%204 = load %..rawptr*, %..rawptr** %203, align 8
	%205 = getelementptr inbounds %..rawptr, %..rawptr* %204, i64 %202
	%206 = load %..rawptr, %..rawptr* %205, align 8
	store %..rawptr %206, %..rawptr* %21
	%207 = load %..rawptr, %..rawptr* %21, align 8
	; SelectorExpr
	%208 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%209 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %208, i32 0, i32 3
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$fb, i32 0, i32 0), i64 64}, i64 169, i64 4, %..string {i8* getelementptr inbounds ([23 x i8], [23 x i8]* @str$fc, i32 0, i32 0), i64 22}, i64 15949121582181591977}, %runtime.Source_Code_Location* %23
	call void @mem.free(%..rawptr %207, %mem.Allocator* %209, %runtime.Source_Code_Location* %23, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-19

for.index.done-21:
	; SelectorExpr
	%210 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%211 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %210, i32 0, i32 4
	call void @runtime.clear_dynamic_array-7013({%..rawptr*, i64, i64, %mem.Allocator}* %211)
	br label %switch.done-27

switch.case.next-22:
	br label %switch.done-27

switch.fall.body-23:
	; last_ptr
	; IndexExpr
	; SelectorExpr
	%212 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%213 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %212, i32 0, i32 0
	%214 = load {i8*, i64}, {i8*, i64}* %213, align 8
	%215 = extractvalue {i8*, i64} %214, 0
	; SelectorExpr
	%216 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%217 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %216, i32 0, i32 2
	%218 = load i64, i64* %217, align 8
	%219 = extractvalue {i8*, i64} %214, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([65 x i8], [65 x i8]* @str$fd, i32 0, i32 0), i64 64}, i64 174, i64 44, i64 %218, i64 %219)
	%220 = getelementptr inbounds i8, i8* %215, i64 %218
	%221 = bitcast i8* %220 to %..rawptr
	store %..rawptr %221, %..rawptr* %24
	; IfStmt
	%222 = load %..rawptr, %..rawptr* %4, align 8
	%223 = load %..rawptr, %..rawptr* %24, align 8
	%224 = icmp eq %..rawptr %222, %223
	%225 = zext i1 %224 to i8
	%226 = trunc i8 %225 to i1
	br i1 %226, label %cmp.and-24, label %if.done-26

cmp.and-24:
	; SelectorExpr
	%227 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%228 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %227, i32 0, i32 0
	%229 = load {i8*, i64}, {i8*, i64}* %228, align 8
	%230 = extractvalue {i8*, i64} %229, 1
	; SelectorExpr
	%231 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%232 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %231, i32 0, i32 2
	%233 = load i64, i64* %232, align 8
	%234 = sub i64 %230, %233
	%235 = load i64, i64* %2, align 8
	%236 = icmp sge i64 %234, %235
	%237 = zext i1 %236 to i8
	%238 = trunc i8 %237 to i1
	br i1 %238, label %if.then-25, label %if.done-26

if.then-25:
	; AssignStmt
	; SelectorExpr
	%239 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%240 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %239, i32 0, i32 1
	; SelectorExpr
	%241 = load %mem.Scratch_Allocator*, %mem.Scratch_Allocator** %7, align 8
	%242 = getelementptr inbounds %mem.Scratch_Allocator, %mem.Scratch_Allocator* %241, i32 0, i32 2
	%243 = load i64, i64* %242, align 8
	%244 = load i64, i64* %2, align 8
	%245 = add i64 %243, %244
	store i64 %245, i64* %240
	; ReturnStmt
	%246 = load %..rawptr, %..rawptr* %4, align 8
	ret %..rawptr %246

if.done-26:
	; ReturnStmt
	%247 = load %..rawptr, %..rawptr* %0, align 8
	%248 = load i64, i64* %2, align 8
	%249 = load i64, i64* %3, align 8
	%250 = load %..rawptr, %..rawptr* %4, align 8
	%251 = load i64, i64* %5, align 8
	%252 = load i64, i64* %6, align 8
	%253 = call %..rawptr @mem.scratch_allocator_proc(%..rawptr %247, i8 0, i64 %248, i64 %249, %..rawptr %250, i64 %251, i64 %252, %runtime.Source_Code_Location* %_.7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret %..rawptr %253

switch.done-27:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define void @os.write_string({i64, i64}* sret noalias %agg.result, i64 %_.0, %..string %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i8*, align 16
	%3 = alloca {i8*, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	%5 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store %..string %_.1, %..string* %1
	; ReturnStmt
	%6 = load i64, i64* %0, align 8
	%7 = load %..string, %..string* %1, align 8
	%8 = extractvalue %..string %7, 0
	store i8* %8, i8** %2
	%9 = extractvalue %..string %7, 1
	%10 = sub i64 %9, 0
	%11 = load i8*, i8** %2, align 8
	%12 = getelementptr inbounds i8, i8* %11, i64 0
	%13 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i32 0, i32 0
	store i8* %12, i8** %13
	%14 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i32 0, i32 1
	store i64 %10, i64* %14
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %4, align 1
	call void @os.write({i64, i64}* %4, i64 %6, {i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%15 = load {i64, i64}, {i64, i64}* %4, align 8
	%16 = extractvalue {i64, i64} %15, 0
	%17 = extractvalue {i64, i64} %15, 1
	%18 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i32 0, i32 0
	store i64 %16, i64* %18
	%19 = getelementptr inbounds {i64, i64}, {i64, i64}* %5, i32 0, i32 1
	store i64 %17, i64* %19
	%20 = load {i64, i64}, {i64, i64}* %5, align 8
	store {i64, i64} %20, {i64, i64}* %agg.result
	ret void
}

define void @os.write_byte({i64, i64}* sret noalias %agg.result, i64 %_.0, i8 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i8, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store i8 %_.1, i8* %1
	; ReturnStmt
	%5 = load i64, i64* %0, align 8
	; CompoundLit
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %2, align 1
	%6 = getelementptr inbounds [1 x i8], [1 x i8]* @csba$0, i32 0, i32 0
	%7 = load i8, i8* %1, align 1
	%8 = getelementptr inbounds i8, i8* %6, i64 0
	store i8 %7, i8* %8
	%9 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i32 0, i32 0
	store i8* %6, i8** %9
	%10 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i32 0, i32 1
	store i64 1, i64* %10
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %3, align 1
	call void @os.write({i64, i64}* %3, i64 %5, {i8*, i64}* %2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%11 = load {i64, i64}, {i64, i64}* %3, align 8
	%12 = extractvalue {i64, i64} %11, 0
	%13 = extractvalue {i64, i64} %11, 1
	%14 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i32 0, i32 0
	store i64 %12, i64* %14
	%15 = getelementptr inbounds {i64, i64}, {i64, i64}* %4, i32 0, i32 1
	store i64 %13, i64* %15
	%16 = load {i64, i64}, {i64, i64}* %4, align 8
	store {i64, i64} %16, {i64, i64}* %agg.result
	ret void
}

define void @os.write_rune({i64, i64}* sret noalias %agg.result, i64 %_.0, i32 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i32, align 16
	%2 = alloca {i64, i64}, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca [4 x i8], align 16
	%5 = alloca i64, align 16
	%6 = alloca {[4 x i8], i64}, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca {i64, i64}, align 16
	%9 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store i32 %_.1, i32* %1
	; IfStmt
	%10 = load i32, i32* %1, align 4
	%11 = icmp slt i32 %10, 128
	%12 = zext i1 %11 to i8
	%13 = trunc i8 %12 to i1
	br i1 %13, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%14 = load i64, i64* %0, align 8
	%15 = load i32, i32* %1, align 4
	%16 = trunc i32 %15 to i8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %2, align 1
	call void @os.write_byte({i64, i64}* %2, i64 %14, i8 %16, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%17 = load {i64, i64}, {i64, i64}* %2, align 8
	%18 = extractvalue {i64, i64} %17, 0
	%19 = extractvalue {i64, i64} %17, 1
	%20 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i32 0, i32 0
	store i64 %18, i64* %20
	%21 = getelementptr inbounds {i64, i64}, {i64, i64}* %3, i32 0, i32 1
	store i64 %19, i64* %21
	%22 = load {i64, i64}, {i64, i64}* %3, align 8
	store {i64, i64} %22, {i64, i64}* %agg.result
	ret void

if.done-2:
	; b
	; n
	; SelectorExpr
	%23 = load i32, i32* %1, align 4
	; ZeroInit
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %6, align 1
	call void @utf8.encode_rune({[4 x i8], i64}* %6, i32 %23, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%24 = load {[4 x i8], i64}, {[4 x i8], i64}* %6, align 8
	%25 = extractvalue {[4 x i8], i64} %24, 0
	%26 = extractvalue {[4 x i8], i64} %24, 1
	store [4 x i8] %25, [4 x i8]* %4
	store i64 %26, i64* %5
	; ReturnStmt
	%27 = load i64, i64* %0, align 8
	; SliceExpr
	%28 = load i64, i64* %5, align 8
	call void @runtime.slice_expr_error_hi(%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$fe, i32 0, i32 0), i64 55}, i64 21, i64 20, i64 %28, i64 4)
	%29 = getelementptr inbounds [4 x i8], [4 x i8]* %4, i32 0, i32 0
	%30 = getelementptr inbounds i8, i8* %29, i64 0
	%31 = sub i64 %28, 0
	%32 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 0
	store i8* %30, i8** %32
	%33 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 1
	store i64 %31, i64* %33
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %8, align 1
	call void @os.write({i64, i64}* %8, i64 %27, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%34 = load {i64, i64}, {i64, i64}* %8, align 8
	%35 = extractvalue {i64, i64} %34, 0
	%36 = extractvalue {i64, i64} %34, 1
	%37 = getelementptr inbounds {i64, i64}, {i64, i64}* %9, i32 0, i32 0
	store i64 %35, i64* %37
	%38 = getelementptr inbounds {i64, i64}, {i64, i64}* %9, i32 0, i32 1
	store i64 %36, i64* %38
	%39 = load {i64, i64}, {i64, i64}* %9, align 8
	store {i64, i64} %39, {i64, i64}* %agg.result
	ret void
}

define void @os.write_encoded_rune(i64 %_.0, i32 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i32, align 16
	%2 = alloca {i64, i64}, align 16
	%3 = alloca {i64, i64}, align 16
	%4 = alloca {i64, i64}, align 16
	%5 = alloca {i64, i64}, align 16
	%6 = alloca {i64, i64}, align 16
	%7 = alloca {i64, i64}, align 16
	%8 = alloca {i64, i64}, align 16
	%9 = alloca {i64, i64}, align 16
	%10 = alloca {i64, i64}, align 16
	%11 = alloca {i64, i64}, align 16
	%12 = alloca [2 x i8], align 16
	%13 = alloca %..string, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca %..string, align 16
	%16 = alloca {i64, i64}, align 16
	%17 = alloca {i64, i64}, align 16
	%18 = alloca {i64, i64}, align 16
	%19 = alloca {i64, i64}, align 16
	%20 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	store i32 %_.1, i32* %1
	%21 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %2, align 1
	call void @os.write_byte({i64, i64}* %2, i64 %21, i8 39, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SwitchStmt
	%22 = load i32, i32* %1, align 4
	%23 = icmp eq i32 %22, 7
	br i1 %23, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%24 = icmp eq i32 %22, 8
	br i1 %24, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	%25 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %3, align 1
	call void @os.write_string({i64, i64}* %3, i64 %25, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$ff, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-3:
	%26 = icmp eq i32 %22, 27
	br i1 %26, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%27 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %4, align 1
	call void @os.write_string({i64, i64}* %4, i64 %27, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$100, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-5:
	%28 = icmp eq i32 %22, 12
	br i1 %28, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%29 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %5, align 1
	call void @os.write_string({i64, i64}* %5, i64 %29, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$101, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-7:
	%30 = icmp eq i32 %22, 10
	br i1 %30, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%31 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %6, align 1
	call void @os.write_string({i64, i64}* %6, i64 %31, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$102, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-9:
	%32 = icmp eq i32 %22, 13
	br i1 %32, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%33 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %7, align 1
	call void @os.write_string({i64, i64}* %7, i64 %33, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$103, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-11:
	%34 = icmp eq i32 %22, 9
	br i1 %34, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%35 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %8, align 1
	call void @os.write_string({i64, i64}* %8, i64 %35, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$104, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-13:
	%36 = icmp eq i32 %22, 11
	br i1 %36, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%37 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %9, align 1
	call void @os.write_string({i64, i64}* %9, i64 %37, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$105, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

switch.case.next-15:
	; IfStmt
	%38 = load i32, i32* %1, align 4
	%39 = icmp slt i32 %38, 32
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %if.then-17, label %if.else-25

switch.fall.body-16:
	%42 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %10, align 1
	call void @os.write_string({i64, i64}* %10, i64 %42, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$106, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-27

if.then-17:
	%43 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %11, align 1
	call void @os.write_string({i64, i64}* %11, i64 %43, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$107, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; b
	; ZeroInit
	store [2 x i8] zeroinitializer, [2 x i8]* %12, align 1
	; s
	; SelectorExpr
	; SliceExpr
	%44 = getelementptr inbounds [2 x i8], [2 x i8]* %12, i32 0, i32 0
	%45 = getelementptr inbounds i8, i8* %44, i64 0
	%46 = sub i64 2, 0
	%47 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %14, i32 0, i32 0
	store i8* %45, i8** %47
	%48 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %14, i32 0, i32 1
	store i64 %46, i64* %48
	%49 = load i32, i32* %1, align 4
	%50 = sext i32 %49 to i64
	; SelectorExpr
	%51 = load %..string, %..string* @strconv.digits, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %15, align 1
	call void @strconv.append_bits(%..string* %15, {i8*, i64}* %14, i64 %50, i64 16, i1 true, i64 64, %..string %51, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%52 = load %..string, %..string* %15, align 8
	store %..string %52, %..string* %13
	; SwitchStmt
	%53 = load %..string, %..string* %13, align 8
	%54 = extractvalue %..string %53, 1
	%55 = icmp eq i64 %54, 0
	br i1 %55, label %switch.case.body-19, label %switch.case.next-18

switch.case.next-18:
	%56 = icmp eq i64 %54, 1
	br i1 %56, label %switch.fall.body-21, label %switch.case.next-20

switch.case.body-19:
	%57 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %16, align 1
	call void @os.write_string({i64, i64}* %16, i64 %57, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$108, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-20:
	%58 = icmp eq i64 %54, 2
	br i1 %58, label %switch.fall.body-23, label %switch.case.next-22

switch.fall.body-21:
	%59 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %17, align 1
	call void @os.write_rune({i64, i64}* %17, i64 %59, i32 48, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.case.next-22:
	br label %switch.done-24

switch.fall.body-23:
	%60 = load i64, i64* %0, align 8
	%61 = load %..string, %..string* %13, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %18, align 1
	call void @os.write_string({i64, i64}* %18, i64 %60, %..string %61, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-24

switch.done-24:
	br label %if.done-26

if.else-25:
	%62 = load i64, i64* %0, align 8
	%63 = load i32, i32* %1, align 4
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %19, align 1
	call void @os.write_rune({i64, i64}* %19, i64 %62, i32 %63, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-26

if.done-26:
	br label %switch.done-27

switch.done-27:
	%64 = load i64, i64* %0, align 8
	; ZeroInit
	store {i64, i64} zeroinitializer, {i64, i64}* %20, align 1
	call void @os.write_byte({i64, i64}* %20, i64 %64, i8 39, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define %..rawptr @os.heap_allocator_proc(%..rawptr %_.0, i8 %_.1, i64 %_.2, i64 %_.3, %..rawptr %_.4, i64 %_.5, i64 %_.6, %runtime.Source_Code_Location* %_.7, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..rawptr, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca %..rawptr, align 16
	%8 = alloca %runtime.Source_Code_Location, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i8 %_.1, i8* %1
	store i64 %_.2, i64* %2
	store i64 %_.3, i64* %3
	store %..rawptr %_.4, %..rawptr* %4
	store i64 %_.5, i64* %5
	store i64 %_.6, i64* %6
	; SwitchStmt
	%9 = load i8, i8* %1, align 1
	%10 = icmp eq i8 %9, 0
	br i1 %10, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%11 = icmp eq i8 %9, 1
	br i1 %11, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; ReturnStmt
	%12 = load i64, i64* %2, align 8
	%13 = call %..rawptr @os.heap_alloc(i64 %12, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret %..rawptr %13

switch.case.next-3:
	%14 = icmp eq i8 %9, 2
	br i1 %14, label %switch.fall.body-6, label %switch.case.next-5

switch.fall.body-4:
	%15 = load %..rawptr, %..rawptr* %4, align 8
	call void @os.heap_free(%..rawptr %15, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret %..rawptr zeroinitializer

switch.case.next-5:
	%16 = icmp eq i8 %9, 3
	br i1 %16, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	br label %switch.done-11

switch.case.next-7:
	br label %switch.done-11

switch.fall.body-8:
	; IfStmt
	%17 = load %..rawptr, %..rawptr* %4, align 8
	%18 = icmp eq %..rawptr %17, zeroinitializer
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-9, label %if.done-10

if.then-9:
	; ReturnStmt
	%21 = load i64, i64* %2, align 8
	%22 = call %..rawptr @os.heap_alloc(i64 %21, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret %..rawptr %22

if.done-10:
	; ptr
	%23 = load %..rawptr, %..rawptr* %4, align 8
	%24 = load i64, i64* %2, align 8
	%25 = call %..rawptr @os.heap_resize(%..rawptr %23, i64 %24, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %..rawptr %25, %..rawptr* %7
	%26 = load %..rawptr, %..rawptr* %7, align 8
	%27 = icmp ne %..rawptr %26, zeroinitializer
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([56 x i8], [56 x i8]* @str$109, i32 0, i32 0), i64 55}, i64 142, i64 3, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$10a, i32 0, i32 0), i64 19}, i64 17546836050105915574}, %runtime.Source_Code_Location* %8
	%30 = call i8 @runtime.assert(i1 %29, %..string zeroinitializer, %runtime.Source_Code_Location* %8, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	%31 = load %..rawptr, %..rawptr* %7, align 8
	ret %..rawptr %31

switch.done-11:
	; ReturnStmt
	ret %..rawptr zeroinitializer
}

define void @os.heap_allocator(%mem.Allocator* sret noalias %agg.result, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Allocator, align 16
	; ReturnStmt
	; CompoundLit
	; ZeroInit
	store %mem.Allocator zeroinitializer, %mem.Allocator* %0, align 1
	store %mem.Allocator {%..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* zeroinitializer, %..rawptr zeroinitializer}, %mem.Allocator* %0
	%1 = bitcast %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* @os.heap_allocator_proc to %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*
	%2 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i32 0, i32 0
	store %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %1, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %2
	%3 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %0, i32 0, i32 1
	store %..rawptr zeroinitializer, %..rawptr* %3
	%4 = load %mem.Allocator, %mem.Allocator* %0, align 8
	store %mem.Allocator %4, %mem.Allocator* %agg.result
	ret void
}

define void @os.write({i64, i64}* sret noalias %agg.result, i64 %_.0, {i8*, i64}* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca {i64, i64}, align 16
	%2 = alloca i32, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i32, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca {i64, i64}, align 16
	%10 = alloca {i64, i64}, align 16
	store i64 %_.0, i64* %0
	; IfStmt
	%11 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%12 = extractvalue {i8*, i64} %11, 1
	%13 = icmp eq i64 %12, 0
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%16 = getelementptr inbounds {i64, i64}, {i64, i64}* %1, i32 0, i32 0
	store i64 0, i64* %16
	%17 = getelementptr inbounds {i64, i64}, {i64, i64}* %1, i32 0, i32 1
	store i64 0, i64* %17
	%18 = load {i64, i64}, {i64, i64}* %1, align 8
	store {i64, i64} %18, {i64, i64}* %agg.result
	ret void

if.done-2:
	; single_write_length
	; ZeroInit
	store i32 zeroinitializer, i32* %2, align 1
	; total_write
	; ZeroInit
	store i64 zeroinitializer, i64* %3, align 1
	; length
	%19 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%20 = extractvalue {i8*, i64} %19, 1
	%21 = bitcast i64 %20 to i64
	store i64 %21, i64* %4
	; ForStmt
	br label %for.loop-3

for.loop-3:
	%22 = load i64, i64* %3, align 8
	%23 = load i64, i64* %4, align 8
	%24 = icmp slt i64 %22, %23
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %for.body-4, label %for.done-8

for.body-4:
	; remaining
	%27 = load i64, i64* %4, align 8
	%28 = load i64, i64* %3, align 8
	%29 = sub i64 %27, %28
	store i64 %29, i64* %5
	; to_write
	; min
	%30 = load i64, i64* %5, align 8
	%31 = trunc i64 %30 to i32
	%32 = icmp slt i32 %31, 2147483647
	%33 = select i1 %32, i32 %31, i32 2147483647
	store i32 %33, i32* %6
	; e
	; SelectorExpr
	%34 = load i64, i64* %0, align 8
	%35 = inttoptr i64 %34 to %..rawptr
	; IndexExpr
	%36 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%37 = extractvalue {i8*, i64} %36, 0
	%38 = load i64, i64* %3, align 8
	%39 = bitcast i64 %38 to i64
	%40 = extractvalue {i8*, i64} %36, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$10b, i32 0, i32 0), i64 63}, i64 134, i64 49, i64 %39, i64 %40)
	%41 = getelementptr inbounds i8, i8* %37, i64 %39
	%42 = load i32, i32* %6, align 4
	%43 = bitcast i8* %41 to %..rawptr
	%44 = call cc 64 i32 @WriteFile(%..rawptr %35, %..rawptr %43, i32 %42, i32* %2, %..rawptr zeroinitializer)
	store i32 %44, i32* %7
	; IfStmt
	%45 = load i32, i32* %2, align 4
	%46 = icmp sle i32 %45, 0
	%47 = zext i1 %46 to i32
	%48 = icmp ne i32 %47, 0
	%49 = zext i1 %48 to i8
	%50 = trunc i8 %49 to i1
	br i1 %50, label %if.then-6, label %cmp.or-5

cmp.or-5:
	%51 = load i32, i32* %7, align 4
	%52 = icmp ne i32 %51, 0
	%53 = zext i1 %52 to i8
	%54 = trunc i8 %53 to i1
	br i1 %54, label %if.done-7, label %if.then-6

if.then-6:
	; err
	; SelectorExpr
	%55 = call i32 @GetLastError()
	%56 = sext i32 %55 to i64
	store i64 %56, i64* %8
	; ReturnStmt
	%57 = load i64, i64* %3, align 8
	%58 = bitcast i64 %57 to i64
	%59 = load i64, i64* %8, align 8
	%60 = getelementptr inbounds {i64, i64}, {i64, i64}* %9, i32 0, i32 0
	store i64 %58, i64* %60
	%61 = getelementptr inbounds {i64, i64}, {i64, i64}* %9, i32 0, i32 1
	store i64 %59, i64* %61
	%62 = load {i64, i64}, {i64, i64}* %9, align 8
	store {i64, i64} %62, {i64, i64}* %agg.result
	ret void

if.done-7:
	; AssignStmt
	%63 = load i32, i32* %2, align 4
	%64 = sext i32 %63 to i64
	%65 = load i64, i64* %3, align 8
	%66 = add i64 %65, %64
	store i64 %66, i64* %3
	br label %for.loop-3

for.done-8:
	; ReturnStmt
	%67 = load i64, i64* %3, align 8
	%68 = bitcast i64 %67 to i64
	%69 = getelementptr inbounds {i64, i64}, {i64, i64}* %10, i32 0, i32 0
	store i64 %68, i64* %69
	%70 = getelementptr inbounds {i64, i64}, {i64, i64}* %10, i32 0, i32 1
	store i64 0, i64* %70
	%71 = load {i64, i64}, {i64, i64}* %10, align 8
	store {i64, i64} %71, {i64, i64}* %agg.result
	ret void
}

define i64 @os.get_std_handle(i64 %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %..rawptr, align 16
	store i64 %_.0, i64* %0
	; fd
	; SelectorExpr
	%2 = load i64, i64* %0, align 8
	%3 = trunc i64 %2 to i32
	%4 = call cc 64 %..rawptr @GetStdHandle(i32 %3)
	store %..rawptr %4, %..rawptr* %1
	; SelectorExpr
	%5 = load %..rawptr, %..rawptr* %1, align 8
	%6 = call cc 64 i32 @SetHandleInformation(%..rawptr %5, i32 1, i32 0)
	; ReturnStmt
	%7 = load %..rawptr, %..rawptr* %1, align 8
	%8 = ptrtoint %..rawptr %7 to i64
	ret i64 %8
}

define %..rawptr @os.heap_alloc(i64 %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	store i64 %_.0, i64* %0
	; ReturnStmt
	; SelectorExpr
	; SelectorExpr
	%1 = call cc 64 %..rawptr @GetProcessHeap()
	%2 = load i64, i64* %0, align 8
	%3 = call cc 64 %..rawptr @HeapAlloc(%..rawptr %1, i32 8, i64 %2)
	ret %..rawptr %3
}

define %..rawptr @os.heap_resize(%..rawptr %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i64 %_.1, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp eq i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	%6 = load %..rawptr, %..rawptr* %0, align 8
	call void @os.heap_free(%..rawptr %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret %..rawptr zeroinitializer

if.done-2:
	; IfStmt
	%7 = load %..rawptr, %..rawptr* %0, align 8
	%8 = icmp eq %..rawptr %7, zeroinitializer
	%9 = zext i1 %8 to i8
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	%11 = load i64, i64* %1, align 8
	%12 = call %..rawptr @os.heap_alloc(i64 %11, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret %..rawptr %12

if.done-4:
	; ReturnStmt
	; SelectorExpr
	; SelectorExpr
	%13 = call cc 64 %..rawptr @GetProcessHeap()
	%14 = load %..rawptr, %..rawptr* %0, align 8
	%15 = load i64, i64* %1, align 8
	%16 = call cc 64 %..rawptr @HeapReAlloc(%..rawptr %13, i32 8, %..rawptr %14, i64 %15)
	ret %..rawptr %16
}

define void @os.heap_free(%..rawptr %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	store %..rawptr %_.0, %..rawptr* %0
	; IfStmt
	%1 = load %..rawptr, %..rawptr* %0, align 8
	%2 = icmp eq %..rawptr %1, zeroinitializer
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; SelectorExpr
	; SelectorExpr
	%5 = call cc 64 %..rawptr @GetProcessHeap()
	%6 = load %..rawptr, %..rawptr* %0, align 8
	%7 = call cc 64 i32 @HeapFree(%..rawptr %5, i32 0, %..rawptr %6)
	ret void
}

define i64 @os.current_thread_id() #0 {
decls-0:
	; ReturnStmt
	; SelectorExpr
	%0 = call cc 64 i32 @GetCurrentThreadId()
	%1 = zext i32 %0 to i64
	ret i64 %1
}

define void @utf8.encode_rune({[4 x i8], i64}* sret noalias %agg.result, i32 %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i32, align 16
	%2 = alloca [4 x i8], align 16
	%3 = alloca i32, align 16
	%4 = alloca {[4 x i8], i64}, align 16
	%5 = alloca {[4 x i8], i64}, align 16
	%6 = alloca {[4 x i8], i64}, align 16
	%7 = alloca {[4 x i8], i64}, align 16
	store i32 %_.0, i32* %0
	; r
	%8 = load i32, i32* %0, align 4
	store i32 %8, i32* %1
	; buf
	; ZeroInit
	store [4 x i8] zeroinitializer, [4 x i8]* %2, align 1
	; i
	%9 = load i32, i32* %1, align 4
	%10 = bitcast i32 %9 to i32
	store i32 %10, i32* %3
	; IfStmt
	%11 = load i32, i32* %3, align 4
	%12 = icmp ule i32 %11, 127
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; IndexExpr
	%15 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
	%16 = load i32, i32* %1, align 4
	%17 = trunc i32 %16 to i8
	store i8 %17, i8* %15
	; ReturnStmt
	%18 = load [4 x i8], [4 x i8]* %2, align 1
	%19 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %4, i32 0, i32 0
	store [4 x i8] %18, [4 x i8]* %19
	%20 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %4, i32 0, i32 1
	store i64 1, i64* %20
	%21 = load {[4 x i8], i64}, {[4 x i8], i64}* %4, align 8
	store {[4 x i8], i64} %21, {[4 x i8], i64}* %agg.result
	ret void

if.done-2:
	; IfStmt
	%22 = load i32, i32* %3, align 4
	%23 = icmp ule i32 %22, 2047
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	; IndexExpr
	%26 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
	%27 = load i32, i32* %1, align 4
	%28 = ashr i32 %27, 6
	%29 = trunc i32 %28 to i8
	%30 = or i8 192, %29
	store i8 %30, i8* %26
	; AssignStmt
	; IndexExpr
	%31 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 1
	%32 = load i32, i32* %1, align 4
	%33 = trunc i32 %32 to i8
	%34 = and i8 %33, 63
	%35 = or i8 128, %34
	store i8 %35, i8* %31
	; ReturnStmt
	%36 = load [4 x i8], [4 x i8]* %2, align 1
	%37 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %5, i32 0, i32 0
	store [4 x i8] %36, [4 x i8]* %37
	%38 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %5, i32 0, i32 1
	store i64 2, i64* %38
	%39 = load {[4 x i8], i64}, {[4 x i8], i64}* %5, align 8
	store {[4 x i8], i64} %39, {[4 x i8], i64}* %agg.result
	ret void

if.done-4:
	; IfStmt
	%40 = load i32, i32* %3, align 4
	%41 = icmp ugt i32 %40, 1114111
	%42 = zext i1 %41 to i8
	%43 = trunc i8 %42 to i1
	br i1 %43, label %if.then-7, label %cmp.or-5

cmp.or-5:
	%44 = load i32, i32* %3, align 4
	%45 = icmp ule i32 55296, %44
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %cmp.and-6, label %if.done-8

cmp.and-6:
	%48 = load i32, i32* %3, align 4
	%49 = icmp ule i32 %48, 57343
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	store i32 65533, i32* %1
	br label %if.done-8

if.done-8:
	; IfStmt
	%52 = load i32, i32* %3, align 4
	%53 = icmp ule i32 %52, 65535
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-9, label %if.done-10

if.then-9:
	; AssignStmt
	; IndexExpr
	%56 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
	%57 = load i32, i32* %1, align 4
	%58 = ashr i32 %57, 12
	%59 = trunc i32 %58 to i8
	%60 = or i8 224, %59
	store i8 %60, i8* %56
	; AssignStmt
	; IndexExpr
	%61 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 1
	%62 = load i32, i32* %1, align 4
	%63 = ashr i32 %62, 6
	%64 = trunc i32 %63 to i8
	%65 = and i8 %64, 63
	%66 = or i8 128, %65
	store i8 %66, i8* %61
	; AssignStmt
	; IndexExpr
	%67 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 2
	%68 = load i32, i32* %1, align 4
	%69 = trunc i32 %68 to i8
	%70 = and i8 %69, 63
	%71 = or i8 128, %70
	store i8 %71, i8* %67
	; ReturnStmt
	%72 = load [4 x i8], [4 x i8]* %2, align 1
	%73 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %6, i32 0, i32 0
	store [4 x i8] %72, [4 x i8]* %73
	%74 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %6, i32 0, i32 1
	store i64 3, i64* %74
	%75 = load {[4 x i8], i64}, {[4 x i8], i64}* %6, align 8
	store {[4 x i8], i64} %75, {[4 x i8], i64}* %agg.result
	ret void

if.done-10:
	; AssignStmt
	; IndexExpr
	%76 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
	%77 = load i32, i32* %1, align 4
	%78 = ashr i32 %77, 18
	%79 = trunc i32 %78 to i8
	%80 = or i8 240, %79
	store i8 %80, i8* %76
	; AssignStmt
	; IndexExpr
	%81 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 1
	%82 = load i32, i32* %1, align 4
	%83 = ashr i32 %82, 12
	%84 = trunc i32 %83 to i8
	%85 = and i8 %84, 63
	%86 = or i8 128, %85
	store i8 %86, i8* %81
	; AssignStmt
	; IndexExpr
	%87 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 2
	%88 = load i32, i32* %1, align 4
	%89 = ashr i32 %88, 6
	%90 = trunc i32 %89 to i8
	%91 = and i8 %90, 63
	%92 = or i8 128, %91
	store i8 %92, i8* %87
	; AssignStmt
	; IndexExpr
	%93 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 3
	%94 = load i32, i32* %1, align 4
	%95 = trunc i32 %94 to i8
	%96 = and i8 %95, 63
	%97 = or i8 128, %96
	store i8 %97, i8* %93
	; ReturnStmt
	%98 = load [4 x i8], [4 x i8]* %2, align 1
	%99 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %7, i32 0, i32 0
	store [4 x i8] %98, [4 x i8]* %99
	%100 = getelementptr inbounds {[4 x i8], i64}, {[4 x i8], i64}* %7, i32 0, i32 1
	store i64 4, i64* %100
	%101 = load {[4 x i8], i64}, {[4 x i8], i64}* %7, align 8
	store {[4 x i8], i64} %101, {[4 x i8], i64}* %agg.result
	ret void
}

define void @utf8.decode_rune_in_string({i32, i64}* sret noalias %agg.result, %..string %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	%3 = alloca {i32, i64}, align 16
	%4 = alloca {i32, i64}, align 16
	store %..string %_.0, %..string* %0
	; ReturnStmt
	%5 = load %..string, %..string* %0, align 8
	%6 = extractvalue %..string %5, 0
	store i8* %6, i8** %1
	%7 = extractvalue %..string %5, 1
	%8 = sub i64 %7, 0
	%9 = load i8*, i8** %1, align 8
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i32 0, i32 0
	store i8* %10, i8** %11
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i32 0, i32 1
	store i64 %8, i64* %12
	; ZeroInit
	store {i32, i64} zeroinitializer, {i32, i64}* %3, align 1
	call void @utf8.decode_rune({i32, i64}* %3, {i8*, i64}* %2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	%13 = load {i32, i64}, {i32, i64}* %3, align 8
	%14 = extractvalue {i32, i64} %13, 0
	%15 = extractvalue {i32, i64} %13, 1
	%16 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i32 0, i32 0
	store i32 %14, i32* %16
	%17 = getelementptr inbounds {i32, i64}, {i32, i64}* %4, i32 0, i32 1
	store i64 %15, i64* %17
	%18 = load {i32, i64}, {i32, i64}* %4, align 8
	store {i32, i64} %18, {i32, i64}* %agg.result
	ret void
}

define void @utf8.decode_rune({i32, i64}* sret noalias %agg.result, {i8*, i64}* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca {i32, i64}, align 16
	%2 = alloca i8, align 16
	%3 = alloca i8, align 16
	%4 = alloca i32, align 16
	%5 = alloca {i32, i64}, align 16
	%6 = alloca i8, align 16
	%7 = alloca %utf8.Accept_Range, align 16
	%8 = alloca {i32, i64}, align 16
	%9 = alloca i8, align 16
	%10 = alloca {i32, i64}, align 16
	%11 = alloca {i32, i64}, align 16
	%12 = alloca i8, align 16
	%13 = alloca {i32, i64}, align 16
	%14 = alloca {i32, i64}, align 16
	%15 = alloca i8, align 16
	%16 = alloca {i32, i64}, align 16
	%17 = alloca {i32, i64}, align 16
	; n
	%18 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%19 = extractvalue {i8*, i64} %18, 1
	store i64 %19, i64* %0
	; IfStmt
	%20 = load i64, i64* %0, align 8
	%21 = icmp slt i64 %20, 1
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	%24 = getelementptr inbounds {i32, i64}, {i32, i64}* %1, i32 0, i32 0
	store i32 65533, i32* %24
	%25 = getelementptr inbounds {i32, i64}, {i32, i64}* %1, i32 0, i32 1
	store i64 0, i64* %25
	%26 = load {i32, i64}, {i32, i64}* %1, align 8
	store {i32, i64} %26, {i32, i64}* %agg.result
	ret void

if.done-2:
	; s0
	; IndexExpr
	%27 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%28 = extractvalue {i8*, i64} %27, 0
	%29 = extractvalue {i8*, i64} %27, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$10c, i32 0, i32 0), i64 67}, i64 105, i64 10, i64 0, i64 %29)
	%30 = getelementptr inbounds i8, i8* %28, i64 0
	%31 = load i8, i8* %30, align 1
	store i8 %31, i8* %2
	; x
	; IndexExpr
	%32 = load i8, i8* %2, align 1
	%33 = zext i8 %32 to i64
	%34 = trunc i64 %33 to i32
	%35 = getelementptr inbounds [256 x i8], [256 x i8]* @utf8.accept_sizes, i32 0, i32 %34
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$10d, i32 0, i32 0), i64 67}, i64 106, i64 20, i64 %33, i64 256)
	%36 = load i8, i8* %35, align 1
	store i8 %36, i8* %3
	; IfStmt
	%37 = load i8, i8* %3, align 1
	%38 = icmp uge i8 %37, 240
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %if.then-3, label %if.done-4

if.then-3:
	; mask
	%41 = load i8, i8* %3, align 1
	%42 = zext i8 %41 to i32
	%43 = shl i32 %42, 31
	%44 = ashr i32 %43, 31
	store i32 %44, i32* %4
	; ReturnStmt
	; IndexExpr
	%45 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%46 = extractvalue {i8*, i64} %45, 0
	%47 = extractvalue {i8*, i64} %45, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$10e, i32 0, i32 0), i64 67}, i64 109, i64 17, i64 0, i64 %47)
	%48 = getelementptr inbounds i8, i8* %46, i64 0
	%49 = load i8, i8* %48, align 1
	%50 = zext i8 %49 to i32
	%51 = load i32, i32* %4, align 4
	%52 = xor i32 %51, -1
	%53 = and i32 %50, %52
	%54 = load i32, i32* %4, align 4
	%55 = and i32 65533, %54
	%56 = or i32 %53, %55
	%57 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i32 0, i32 0
	store i32 %56, i32* %57
	%58 = getelementptr inbounds {i32, i64}, {i32, i64}* %5, i32 0, i32 1
	store i64 1, i64* %58
	%59 = load {i32, i64}, {i32, i64}* %5, align 8
	store {i32, i64} %59, {i32, i64}* %agg.result
	ret void

if.done-4:
	; sz
	%60 = load i8, i8* %3, align 1
	%61 = and i8 %60, 7
	store i8 %61, i8* %6
	; accept
	; IndexExpr
	%62 = load i8, i8* %3, align 1
	%63 = lshr i8 %62, 4
	%64 = zext i8 %63 to i64
	%65 = trunc i64 %64 to i32
	%66 = getelementptr inbounds [5 x %utf8.Accept_Range], [5 x %utf8.Accept_Range]* @utf8.accept_ranges, i32 0, i32 %65
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$10f, i32 0, i32 0), i64 67}, i64 112, i64 26, i64 %64, i64 5)
	%67 = load %utf8.Accept_Range, %utf8.Accept_Range* %66, align 1
	store %utf8.Accept_Range %67, %utf8.Accept_Range* %7
	; IfStmt
	%68 = load i64, i64* %0, align 8
	%69 = load i8, i8* %6, align 1
	%70 = zext i8 %69 to i64
	%71 = icmp slt i64 %68, %70
	%72 = zext i1 %71 to i8
	%73 = trunc i8 %72 to i1
	br i1 %73, label %if.then-5, label %if.done-6

if.then-5:
	; ReturnStmt
	%74 = getelementptr inbounds {i32, i64}, {i32, i64}* %8, i32 0, i32 0
	store i32 65533, i32* %74
	%75 = getelementptr inbounds {i32, i64}, {i32, i64}* %8, i32 0, i32 1
	store i64 1, i64* %75
	%76 = load {i32, i64}, {i32, i64}* %8, align 8
	store {i32, i64} %76, {i32, i64}* %agg.result
	ret void

if.done-6:
	; b1
	; IndexExpr
	%77 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%78 = extractvalue {i8*, i64} %77, 0
	%79 = extractvalue {i8*, i64} %77, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$110, i32 0, i32 0), i64 67}, i64 116, i64 10, i64 1, i64 %79)
	%80 = getelementptr inbounds i8, i8* %78, i64 1
	%81 = load i8, i8* %80, align 1
	store i8 %81, i8* %9
	; IfStmt
	%82 = load i8, i8* %9, align 1
	; SelectorExpr
	%83 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %7, i32 0, i32 0
	%84 = load i8, i8* %83, align 1
	%85 = icmp ult i8 %82, %84
	%86 = zext i1 %85 to i8
	%87 = trunc i8 %86 to i1
	br i1 %87, label %if.then-8, label %cmp.or-7

cmp.or-7:
	; SelectorExpr
	%88 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %7, i32 0, i32 1
	%89 = load i8, i8* %88, align 1
	%90 = load i8, i8* %9, align 1
	%91 = icmp ult i8 %89, %90
	%92 = zext i1 %91 to i8
	%93 = trunc i8 %92 to i1
	br i1 %93, label %if.then-8, label %if.done-9

if.then-8:
	; ReturnStmt
	%94 = getelementptr inbounds {i32, i64}, {i32, i64}* %10, i32 0, i32 0
	store i32 65533, i32* %94
	%95 = getelementptr inbounds {i32, i64}, {i32, i64}* %10, i32 0, i32 1
	store i64 1, i64* %95
	%96 = load {i32, i64}, {i32, i64}* %10, align 8
	store {i32, i64} %96, {i32, i64}* %agg.result
	ret void

if.done-9:
	; IfStmt
	%97 = load i8, i8* %6, align 1
	%98 = icmp eq i8 %97, 2
	%99 = zext i1 %98 to i8
	%100 = trunc i8 %99 to i1
	br i1 %100, label %if.then-10, label %if.done-11

if.then-10:
	; ReturnStmt
	%101 = load i8, i8* %2, align 1
	%102 = and i8 %101, 31
	%103 = zext i8 %102 to i32
	%104 = shl i32 %103, 6
	%105 = load i8, i8* %9, align 1
	%106 = and i8 %105, 63
	%107 = zext i8 %106 to i32
	%108 = or i32 %104, %107
	%109 = getelementptr inbounds {i32, i64}, {i32, i64}* %11, i32 0, i32 0
	store i32 %108, i32* %109
	%110 = getelementptr inbounds {i32, i64}, {i32, i64}* %11, i32 0, i32 1
	store i64 2, i64* %110
	%111 = load {i32, i64}, {i32, i64}* %11, align 8
	store {i32, i64} %111, {i32, i64}* %agg.result
	ret void

if.done-11:
	; b2
	; IndexExpr
	%112 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%113 = extractvalue {i8*, i64} %112, 0
	%114 = extractvalue {i8*, i64} %112, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$111, i32 0, i32 0), i64 67}, i64 123, i64 10, i64 2, i64 %114)
	%115 = getelementptr inbounds i8, i8* %113, i64 2
	%116 = load i8, i8* %115, align 1
	store i8 %116, i8* %12
	; IfStmt
	%117 = load i8, i8* %12, align 1
	%118 = icmp ult i8 %117, 128
	%119 = zext i1 %118 to i8
	%120 = trunc i8 %119 to i1
	br i1 %120, label %if.then-13, label %cmp.or-12

cmp.or-12:
	%121 = load i8, i8* %12, align 1
	%122 = icmp ult i8 191, %121
	%123 = zext i1 %122 to i8
	%124 = trunc i8 %123 to i1
	br i1 %124, label %if.then-13, label %if.done-14

if.then-13:
	; ReturnStmt
	%125 = getelementptr inbounds {i32, i64}, {i32, i64}* %13, i32 0, i32 0
	store i32 65533, i32* %125
	%126 = getelementptr inbounds {i32, i64}, {i32, i64}* %13, i32 0, i32 1
	store i64 1, i64* %126
	%127 = load {i32, i64}, {i32, i64}* %13, align 8
	store {i32, i64} %127, {i32, i64}* %agg.result
	ret void

if.done-14:
	; IfStmt
	%128 = load i8, i8* %6, align 1
	%129 = icmp eq i8 %128, 3
	%130 = zext i1 %129 to i8
	%131 = trunc i8 %130 to i1
	br i1 %131, label %if.then-15, label %if.done-16

if.then-15:
	; ReturnStmt
	%132 = load i8, i8* %2, align 1
	%133 = and i8 %132, 15
	%134 = zext i8 %133 to i32
	%135 = shl i32 %134, 12
	%136 = load i8, i8* %9, align 1
	%137 = and i8 %136, 63
	%138 = zext i8 %137 to i32
	%139 = shl i32 %138, 6
	%140 = or i32 %135, %139
	%141 = load i8, i8* %12, align 1
	%142 = and i8 %141, 63
	%143 = zext i8 %142 to i32
	%144 = or i32 %140, %143
	%145 = getelementptr inbounds {i32, i64}, {i32, i64}* %14, i32 0, i32 0
	store i32 %144, i32* %145
	%146 = getelementptr inbounds {i32, i64}, {i32, i64}* %14, i32 0, i32 1
	store i64 3, i64* %146
	%147 = load {i32, i64}, {i32, i64}* %14, align 8
	store {i32, i64} %147, {i32, i64}* %agg.result
	ret void

if.done-16:
	; b3
	; IndexExpr
	%148 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%149 = extractvalue {i8*, i64} %148, 0
	%150 = extractvalue {i8*, i64} %148, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$112, i32 0, i32 0), i64 67}, i64 130, i64 10, i64 3, i64 %150)
	%151 = getelementptr inbounds i8, i8* %149, i64 3
	%152 = load i8, i8* %151, align 1
	store i8 %152, i8* %15
	; IfStmt
	%153 = load i8, i8* %15, align 1
	%154 = icmp ult i8 %153, 128
	%155 = zext i1 %154 to i8
	%156 = trunc i8 %155 to i1
	br i1 %156, label %if.then-18, label %cmp.or-17

cmp.or-17:
	%157 = load i8, i8* %15, align 1
	%158 = icmp ult i8 191, %157
	%159 = zext i1 %158 to i8
	%160 = trunc i8 %159 to i1
	br i1 %160, label %if.then-18, label %if.done-19

if.then-18:
	; ReturnStmt
	%161 = getelementptr inbounds {i32, i64}, {i32, i64}* %16, i32 0, i32 0
	store i32 65533, i32* %161
	%162 = getelementptr inbounds {i32, i64}, {i32, i64}* %16, i32 0, i32 1
	store i64 1, i64* %162
	%163 = load {i32, i64}, {i32, i64}* %16, align 8
	store {i32, i64} %163, {i32, i64}* %agg.result
	ret void

if.done-19:
	; ReturnStmt
	%164 = load i8, i8* %2, align 1
	%165 = and i8 %164, 7
	%166 = zext i8 %165 to i32
	%167 = shl i32 %166, 18
	%168 = load i8, i8* %9, align 1
	%169 = and i8 %168, 63
	%170 = zext i8 %169 to i32
	%171 = shl i32 %170, 12
	%172 = or i32 %167, %171
	%173 = load i8, i8* %12, align 1
	%174 = and i8 %173, 63
	%175 = zext i8 %174 to i32
	%176 = shl i32 %175, 6
	%177 = or i32 %172, %176
	%178 = load i8, i8* %15, align 1
	%179 = and i8 %178, 63
	%180 = zext i8 %179 to i32
	%181 = or i32 %177, %180
	%182 = getelementptr inbounds {i32, i64}, {i32, i64}* %17, i32 0, i32 0
	store i32 %181, i32* %182
	%183 = getelementptr inbounds {i32, i64}, {i32, i64}* %17, i32 0, i32 1
	store i64 4, i64* %183
	%184 = load {i32, i64}, {i32, i64}* %17, align 8
	store {i32, i64} %184, {i32, i64}* %agg.result
	ret void
}

define i64 @utf8.rune_count_in_string(%..string %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %..string, align 16
	%1 = alloca i8*, align 16
	%2 = alloca {i8*, i64}, align 16
	store %..string %_.0, %..string* %0
	; ReturnStmt
	%3 = load %..string, %..string* %0, align 8
	%4 = extractvalue %..string %3, 0
	store i8* %4, i8** %1
	%5 = extractvalue %..string %3, 1
	%6 = sub i64 %5, 0
	%7 = load i8*, i8** %1, align 8
	%8 = getelementptr inbounds i8, i8* %7, i64 0
	%9 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i32 0, i32 0
	store i8* %8, i8** %9
	%10 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %2, i32 0, i32 1
	store i64 %6, i64* %10
	%11 = call i64 @utf8.rune_count({i8*, i64}* %2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	ret i64 %11
}

define i64 @utf8.rune_count({i8*, i64}* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca i8, align 16
	%5 = alloca i64, align 16
	%6 = alloca %utf8.Accept_Range, align 16
	%7 = alloca i8, align 16
	%8 = alloca i8, align 16
	%9 = alloca i8, align 16
	; count
	store i64 0, i64* %0
	; n
	%10 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%11 = extractvalue {i8*, i64} %10, 1
	store i64 %11, i64* %1
	; ForStmt
	; i
	store i64 0, i64* %2
	br label %for.loop-1

for.loop-1:
	%12 = load i64, i64* %2, align 8
	%13 = load i64, i64* %1, align 8
	%14 = icmp slt i64 %12, %13
	%15 = zext i1 %14 to i8
	%16 = trunc i8 %15 to i1
	br i1 %16, label %for.body-2, label %for.done-26

for.body-2:
	; DeferStmt
	; si
	; IndexExpr
	%17 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%18 = extractvalue {i8*, i64} %17, 0
	%19 = load i64, i64* %2, align 8
	%20 = extractvalue {i8*, i64} %17, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$113, i32 0, i32 0), i64 67}, i64 227, i64 11, i64 %19, i64 %20)
	%21 = getelementptr inbounds i8, i8* %18, i64 %19
	%22 = load i8, i8* %21, align 1
	store i8 %22, i8* %3
	; IfStmt
	%23 = load i8, i8* %3, align 1
	%24 = icmp ult i8 %23, 128
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	%27 = load i64, i64* %2, align 8
	%28 = add i64 %27, 1
	store i64 %28, i64* %2
	; defer
	; AssignStmt
	%29 = load i64, i64* %0, align 8
	%30 = add i64 %29, 1
	store i64 %30, i64* %0
	; continue
	br label %for.loop-1

if.done-4:
	; x
	; IndexExpr
	%31 = load i8, i8* %3, align 1
	%32 = zext i8 %31 to i64
	%33 = trunc i64 %32 to i32
	%34 = getelementptr inbounds [256 x i8], [256 x i8]* @utf8.accept_sizes, i32 0, i32 %33
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$114, i32 0, i32 0), i64 67}, i64 232, i64 21, i64 %32, i64 256)
	%35 = load i8, i8* %34, align 1
	store i8 %35, i8* %4
	; IfStmt
	%36 = load i8, i8* %4, align 1
	%37 = icmp eq i8 %36, 241
	%38 = zext i1 %37 to i8
	%39 = trunc i8 %38 to i1
	br i1 %39, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	%40 = load i64, i64* %2, align 8
	%41 = add i64 %40, 1
	store i64 %41, i64* %2
	; defer
	; AssignStmt
	%42 = load i64, i64* %0, align 8
	%43 = add i64 %42, 1
	store i64 %43, i64* %0
	; continue
	br label %for.loop-1

if.done-6:
	; size
	%44 = load i8, i8* %4, align 1
	%45 = and i8 %44, 7
	%46 = zext i8 %45 to i64
	store i64 %46, i64* %5
	; IfStmt
	%47 = load i64, i64* %2, align 8
	%48 = load i64, i64* %5, align 8
	%49 = add i64 %47, %48
	%50 = load i64, i64* %1, align 8
	%51 = icmp sgt i64 %49, %50
	%52 = zext i1 %51 to i8
	%53 = trunc i8 %52 to i1
	br i1 %53, label %if.then-7, label %if.done-8

if.then-7:
	; AssignStmt
	%54 = load i64, i64* %2, align 8
	%55 = add i64 %54, 1
	store i64 %55, i64* %2
	; defer
	; AssignStmt
	%56 = load i64, i64* %0, align 8
	%57 = add i64 %56, 1
	store i64 %57, i64* %0
	; continue
	br label %for.loop-1

if.done-8:
	; ar
	; IndexExpr
	%58 = load i8, i8* %4, align 1
	%59 = lshr i8 %58, 4
	%60 = zext i8 %59 to i64
	%61 = trunc i64 %60 to i32
	%62 = getelementptr inbounds [5 x %utf8.Accept_Range], [5 x %utf8.Accept_Range]* @utf8.accept_ranges, i32 0, i32 %61
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$115, i32 0, i32 0), i64 67}, i64 242, i64 23, i64 %60, i64 5)
	%63 = load %utf8.Accept_Range, %utf8.Accept_Range* %62, align 1
	store %utf8.Accept_Range %63, %utf8.Accept_Range* %6
	; IfStmt
	; b
	; IndexExpr
	%64 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%65 = extractvalue {i8*, i64} %64, 0
	%66 = load i64, i64* %2, align 8
	%67 = add i64 %66, 1
	%68 = extractvalue {i8*, i64} %64, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$116, i32 0, i32 0), i64 67}, i64 243, i64 13, i64 %67, i64 %68)
	%69 = getelementptr inbounds i8, i8* %65, i64 %67
	%70 = load i8, i8* %69, align 1
	store i8 %70, i8* %7
	%71 = load i8, i8* %7, align 1
	; SelectorExpr
	%72 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %6, i32 0, i32 0
	%73 = load i8, i8* %72, align 1
	%74 = icmp ult i8 %71, %73
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %if.then-10, label %cmp.or-9

cmp.or-9:
	; SelectorExpr
	%77 = getelementptr inbounds %utf8.Accept_Range, %utf8.Accept_Range* %6, i32 0, i32 1
	%78 = load i8, i8* %77, align 1
	%79 = load i8, i8* %7, align 1
	%80 = icmp ult i8 %78, %79
	%81 = zext i1 %80 to i8
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-25

if.else-11:
	; IfStmt
	%83 = load i64, i64* %5, align 8
	%84 = icmp eq i64 %83, 2
	%85 = zext i1 %84 to i8
	%86 = trunc i8 %85 to i1
	br i1 %86, label %if.then-12, label %if.else-13

if.then-12:
	br label %if.done-24

if.else-13:
	; IfStmt
	; c
	; IndexExpr
	%87 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%88 = extractvalue {i8*, i64} %87, 0
	%89 = load i64, i64* %2, align 8
	%90 = add i64 %89, 2
	%91 = extractvalue {i8*, i64} %87, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$117, i32 0, i32 0), i64 67}, i64 247, i64 20, i64 %90, i64 %91)
	%92 = getelementptr inbounds i8, i8* %88, i64 %90
	%93 = load i8, i8* %92, align 1
	store i8 %93, i8* %8
	%94 = load i8, i8* %8, align 1
	%95 = icmp ult i8 %94, 128
	%96 = zext i1 %95 to i8
	%97 = trunc i8 %96 to i1
	br i1 %97, label %if.then-15, label %cmp.or-14

cmp.or-14:
	%98 = load i8, i8* %8, align 1
	%99 = icmp ult i8 191, %98
	%100 = zext i1 %99 to i8
	%101 = trunc i8 %100 to i1
	br i1 %101, label %if.then-15, label %if.else-16

if.then-15:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-23

if.else-16:
	; IfStmt
	%102 = load i64, i64* %5, align 8
	%103 = icmp eq i64 %102, 3
	%104 = zext i1 %103 to i8
	%105 = trunc i8 %104 to i1
	br i1 %105, label %if.then-17, label %if.else-18

if.then-17:
	br label %if.done-22

if.else-18:
	; IfStmt
	; d
	; IndexExpr
	%106 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%107 = extractvalue {i8*, i64} %106, 0
	%108 = load i64, i64* %2, align 8
	%109 = add i64 %108, 3
	%110 = extractvalue {i8*, i64} %106, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([68 x i8], [68 x i8]* @str$118, i32 0, i32 0), i64 67}, i64 251, i64 20, i64 %109, i64 %110)
	%111 = getelementptr inbounds i8, i8* %107, i64 %109
	%112 = load i8, i8* %111, align 1
	store i8 %112, i8* %9
	%113 = load i8, i8* %9, align 1
	%114 = icmp ult i8 %113, 128
	%115 = zext i1 %114 to i8
	%116 = trunc i8 %115 to i1
	br i1 %116, label %if.then-20, label %cmp.or-19

cmp.or-19:
	%117 = load i8, i8* %9, align 1
	%118 = icmp ult i8 191, %117
	%119 = zext i1 %118 to i8
	%120 = trunc i8 %119 to i1
	br i1 %120, label %if.then-20, label %if.done-21

if.then-20:
	; AssignStmt
	store i64 1, i64* %5
	br label %if.done-21

if.done-21:
	br label %if.done-22

if.done-22:
	br label %if.done-23

if.done-23:
	br label %if.done-24

if.done-24:
	br label %if.done-25

if.done-25:
	; AssignStmt
	%121 = load i64, i64* %5, align 8
	%122 = load i64, i64* %2, align 8
	%123 = add i64 %122, %121
	store i64 %123, i64* %2
	; defer
	; AssignStmt
	%124 = load i64, i64* %0, align 8
	%125 = add i64 %124, 1
	store i64 %125, i64* %0
	br label %for.loop-1

for.done-26:
	; ReturnStmt
	%126 = load i64, i64* %0, align 8
	ret i64 %126
}

define void @log.nil_logger_proc(%..rawptr %_.0, i64 %_.1, %..string %_.2, i8 %_.3, %runtime.Source_Code_Location* %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %..rawptr, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..string, align 16
	%3 = alloca i8, align 16
	store %..rawptr %_.0, %..rawptr* %0
	store i64 %_.1, i64* %1
	store %..string %_.2, %..string* %2
	store i8 %_.3, i8* %3
	ret void
}

define void @strconv.append_float(%..string* sret noalias %agg.result, {i8*, i64}* %_.0, double %_.1, i8 %_.2, i64 %_.3, i64 %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca {i8*, i64}, align 16
	%5 = alloca %..string, align 16
	store double %_.1, double* %0
	store i8 %_.2, i8* %1
	store i64 %_.3, i64* %2
	store i64 %_.4, i64* %3
	; ReturnStmt
	%6 = load double, double* %0, align 8
	%7 = load i8, i8* %1, align 1
	%8 = load i64, i64* %2, align 8
	%9 = load i64, i64* %3, align 8
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %4, align 1
	call void @strconv.generic_ftoa({i8*, i64}* %4, {i8*, i64}* %_.0, double %6, i8 %7, i64 %8, i64 %9, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%10 = load {i8*, i64}, {i8*, i64}* %4, align 8
	%11 = extractvalue {i8*, i64} %10, 0
	%12 = extractvalue {i8*, i64} %10, 1
	%13 = getelementptr inbounds %..string, %..string* %5, i32 0, i32 0
	store i8* %11, i8** %13
	%14 = getelementptr inbounds %..string, %..string* %5, i32 0, i32 1
	store i64 %12, i64* %14
	%15 = load %..string, %..string* %5, align 8
	store %..string %15, %..string* %agg.result
	ret void
}

define void @strconv.generic_ftoa({i8*, i64}* sret noalias %agg.result, {i8*, i64}* %_.0, double %_.1, i8 %_.2, i64 %_.3, i64 %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca double, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca %strconv.Float_Info*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca i8, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca %..string, align 16
	%11 = alloca i64, align 16
	%12 = alloca i8*, align 16
	%13 = alloca {i8*, i64}, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca %decimal.Decimal, align 16
	%16 = alloca %decimal.Decimal*, align 16
	%17 = alloca %strconv.Decimal_Slice, align 16
	%18 = alloca i64, align 16
	%19 = alloca i8, align 16
	%20 = alloca %strconv.Decimal_Slice, align 16
	%21 = alloca {i8*, i64}, align 16
	%22 = alloca %strconv.Decimal_Slice, align 16
	%23 = alloca {i8*, i64}, align 16
	%24 = alloca {i8*, i64}, align 16
	store double %_.1, double* %0
	store i8 %_.2, i8* %1
	store i64 %_.3, i64* %2
	store i64 %_.4, i64* %3
	; bits
	; ZeroInit
	store i64 zeroinitializer, i64* %4, align 1
	; flt
	; ZeroInit
	store %strconv.Float_Info* zeroinitializer, %strconv.Float_Info** %5, align 1
	; SwitchStmt
	%25 = load i64, i64* %3, align 8
	%26 = icmp eq i64 %25, 32
	br i1 %26, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%27 = icmp eq i64 %25, 64
	br i1 %27, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	; AssignStmt
	%28 = load double, double* %0, align 8
	%29 = fptrunc double %28 to float
	%30 = bitcast float %29 to i32
	%31 = zext i32 %30 to i64
	store i64 %31, i64* %4
	; AssignStmt
	store %strconv.Float_Info* @strconv._f32_info, %strconv.Float_Info** %5
	br label %switch.done-5

switch.case.next-3:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$119, i32 0, i32 0), i64 71}, i64 42, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$11a, i32 0, i32 0), i64 12}, i64 13027285395208183515}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([26 x i8], [26 x i8]* @str$11b, i32 0, i32 0), i64 25}, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-5

switch.fall.body-4:
	; AssignStmt
	%32 = load double, double* %0, align 8
	%33 = bitcast double %32 to i64
	store i64 %33, i64* %4
	; AssignStmt
	store %strconv.Float_Info* @strconv._f64_info, %strconv.Float_Info** %5
	br label %switch.done-5

switch.done-5:
	; neg
	%34 = load i64, i64* %4, align 8
	; SelectorExpr
	%35 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%36 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %35, i32 0, i32 1
	%37 = load i64, i64* %36, align 8
	; SelectorExpr
	%38 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%39 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %38, i32 0, i32 0
	%40 = load i64, i64* %39, align 8
	%41 = add i64 %37, %40
	%42 = bitcast i64 %41 to i64
	%43 = lshr i64 %34, %42
	%44 = icmp ne i64 %43, 0
	%45 = zext i1 %44 to i8
	store i8 %45, i8* %7
	; exp
	%46 = load i64, i64* %4, align 8
	; SelectorExpr
	%47 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%48 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %47, i32 0, i32 0
	%49 = load i64, i64* %48, align 8
	%50 = bitcast i64 %49 to i64
	%51 = lshr i64 %46, %50
	%52 = bitcast i64 %51 to i64
	; SelectorExpr
	%53 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%54 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %53, i32 0, i32 1
	%55 = load i64, i64* %54, align 8
	%56 = bitcast i64 %55 to i64
	%57 = shl i64 1, %56
	%58 = sub i64 %57, 1
	%59 = and i64 %52, %58
	store i64 %59, i64* %8
	; mant
	%60 = load i64, i64* %4, align 8
	; SelectorExpr
	%61 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%62 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %61, i32 0, i32 0
	%63 = load i64, i64* %62, align 8
	%64 = bitcast i64 %63 to i64
	%65 = shl i64 1, %64
	%66 = sub i64 %65, 1
	%67 = and i64 %60, %66
	store i64 %67, i64* %9
	; SwitchStmt
	%68 = load i64, i64* %8, align 8
	; SelectorExpr
	%69 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%70 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %69, i32 0, i32 1
	%71 = load i64, i64* %70, align 8
	%72 = bitcast i64 %71 to i64
	%73 = shl i64 1, %72
	%74 = sub i64 %73, 1
	%75 = icmp eq i64 %68, %74
	br i1 %75, label %switch.case.body-7, label %switch.case.next-6

switch.case.next-6:
	%76 = icmp eq i64 %68, 0
	br i1 %76, label %switch.fall.body-15, label %switch.case.next-14

switch.case.body-7:
	; s
	; ZeroInit
	store %..string zeroinitializer, %..string* %10, align 1
	; IfStmt
	%77 = load i64, i64* %9, align 8
	%78 = icmp ne i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-8, label %if.else-9

if.then-8:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$11c, i32 0, i32 0), i64 3}, %..string* %10
	br label %if.done-13

if.else-9:
	; IfStmt
	%81 = load i8, i8* %7, align 1
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-10, label %if.else-11

if.then-10:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$11d, i32 0, i32 0), i64 4}, %..string* %10
	br label %if.done-12

if.else-11:
	; AssignStmt
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$11e, i32 0, i32 0), i64 4}, %..string* %10
	br label %if.done-12

if.done-12:
	br label %if.done-13

if.done-13:
	; n
	%83 = load %..string, %..string* %10, align 8
	%84 = extractvalue %..string %83, 0
	store i8* %84, i8** %12
	%85 = extractvalue %..string %83, 1
	%86 = sub i64 %85, 0
	%87 = load i8*, i8** %12, align 8
	%88 = getelementptr inbounds i8, i8* %87, i64 0
	%89 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i32 0, i32 0
	store i8* %88, i8** %89
	%90 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i32 0, i32 1
	store i64 %86, i64* %90
	%91 = call i64 @runtime.copy-7722({i8*, i64}* %_.0, {i8*, i64}* %13)
	store i64 %91, i64* %11
	; ReturnStmt
	; SliceExpr
	%92 = load i64, i64* %11, align 8
	%93 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%94 = extractvalue {i8*, i64} %93, 1
	call void @runtime.slice_expr_error_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$11f, i32 0, i32 0), i64 71}, i64 60, i64 13, i64 %92, i64 %94)
	%95 = extractvalue {i8*, i64} %93, 0
	%96 = getelementptr inbounds i8, i8* %95, i64 0
	%97 = sub i64 %92, 0
	%98 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %14, i32 0, i32 0
	store i8* %96, i8** %98
	%99 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %14, i32 0, i32 1
	store i64 %97, i64* %99
	%100 = load {i8*, i64}, {i8*, i64}* %14, align 8
	store {i8*, i64} %100, {i8*, i64}* %agg.result
	ret void

switch.case.next-14:
	; AssignStmt
	; SelectorExpr
	%101 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%102 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %101, i32 0, i32 0
	%103 = load i64, i64* %102, align 8
	%104 = bitcast i64 %103 to i64
	%105 = shl i64 1, %104
	%106 = load i64, i64* %9, align 8
	%107 = or i64 %106, %105
	store i64 %107, i64* %9
	br label %switch.done-16

switch.fall.body-15:
	; AssignStmt
	%108 = load i64, i64* %8, align 8
	%109 = add i64 %108, 1
	store i64 %109, i64* %8
	br label %switch.done-16

switch.done-16:
	; AssignStmt
	; SelectorExpr
	%110 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%111 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %110, i32 0, i32 2
	%112 = load i64, i64* %111, align 8
	%113 = load i64, i64* %8, align 8
	%114 = add i64 %113, %112
	store i64 %114, i64* %8
	; d_
	%115 = bitcast %decimal.Decimal* %15 to %..rawptr
	; ZeroInit
	%116 = call %..rawptr @mem.zero(%..rawptr %115, i64 408)
	; d
	store %decimal.Decimal* %15, %decimal.Decimal** %16
	%117 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%118 = load i64, i64* %9, align 8
	call void @decimal.assign(%decimal.Decimal* %117, i64 %118, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%119 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%120 = load i64, i64* %8, align 8
	; SelectorExpr
	%121 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	%122 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %121, i32 0, i32 0
	%123 = load i64, i64* %122, align 8
	%124 = bitcast i64 %123 to i64
	%125 = sub i64 %120, %124
	call void @decimal.shift(%decimal.Decimal* %119, i64 %125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; digs
	%126 = bitcast %strconv.Decimal_Slice* %17 to %..rawptr
	; ZeroInit
	%127 = call %..rawptr @mem.zero(%..rawptr %126, i64 40)
	; prec
	%128 = load i64, i64* %2, align 8
	store i64 %128, i64* %18
	; shortest
	%129 = load i64, i64* %18, align 8
	%130 = icmp slt i64 %129, 0
	%131 = zext i1 %130 to i8
	store i8 %131, i8* %19
	; IfStmt
	%132 = load i8, i8* %19, align 1
	%133 = trunc i8 %132 to i1
	br i1 %133, label %if.then-17, label %if.else-28

if.then-17:
	%134 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%135 = load i64, i64* %9, align 8
	%136 = load i64, i64* %8, align 8
	%137 = load %strconv.Float_Info*, %strconv.Float_Info** %5, align 8
	call void @strconv.round_shortest(%decimal.Decimal* %134, i64 %135, i64 %136, %strconv.Float_Info* %137, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	; CompoundLit
	%138 = bitcast %strconv.Decimal_Slice* %20 to %..rawptr
	; ZeroInit
	%139 = call %..rawptr @mem.zero(%..rawptr %138, i64 40)
	store %strconv.Decimal_Slice {{i8*, i64} zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer}, %strconv.Decimal_Slice* %20
	; SliceExpr
	; SelectorExpr
	%140 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%141 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %140, i32 0, i32 0
	%142 = getelementptr inbounds [384 x i8], [384 x i8]* %141, i32 0, i32 0
	%143 = getelementptr inbounds i8, i8* %142, i64 0
	%144 = sub i64 384, 0
	%145 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %21, i32 0, i32 0
	store i8* %143, i8** %145
	%146 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %21, i32 0, i32 1
	store i64 %144, i64* %146
	%147 = load {i8*, i64}, {i8*, i64}* %21, align 8
	%148 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %20, i32 0, i32 0
	store {i8*, i64} %147, {i8*, i64}* %148
	; SelectorExpr
	%149 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%150 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %149, i32 0, i32 1
	%151 = load i64, i64* %150, align 8
	%152 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %20, i32 0, i32 1
	store i64 %151, i64* %152
	; SelectorExpr
	%153 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%154 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %153, i32 0, i32 2
	%155 = load i64, i64* %154, align 8
	%156 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %20, i32 0, i32 2
	store i64 %155, i64* %156
	%157 = load %strconv.Decimal_Slice, %strconv.Decimal_Slice* %20, align 8
	store %strconv.Decimal_Slice %157, %strconv.Decimal_Slice* %17
	; SwitchStmt
	%158 = load i8, i8* %1, align 1
	%159 = icmp eq i8 %158, 101
	br i1 %159, label %switch.case.body-20, label %switch.case.next-18

switch.case.next-18:
	%160 = icmp eq i8 %158, 69
	br i1 %160, label %switch.case.body-20, label %switch.case.next-19

switch.case.next-19:
	%161 = icmp eq i8 %158, 102
	br i1 %161, label %switch.fall.body-23, label %switch.case.next-21

switch.case.body-20:
	; AssignStmt
	; SelectorExpr
	%162 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %17, i32 0, i32 1
	%163 = load i64, i64* %162, align 8
	%164 = sub i64 %163, 1
	store i64 %164, i64* %18
	br label %switch.done-27

switch.case.next-21:
	%165 = icmp eq i8 %158, 70
	br i1 %165, label %switch.fall.body-23, label %switch.case.next-22

switch.case.next-22:
	%166 = icmp eq i8 %158, 103
	br i1 %166, label %switch.fall.body-26, label %switch.case.next-24

switch.fall.body-23:
	; AssignStmt
	; max
	; SelectorExpr
	%167 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %17, i32 0, i32 1
	%168 = load i64, i64* %167, align 8
	; SelectorExpr
	%169 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %17, i32 0, i32 2
	%170 = load i64, i64* %169, align 8
	%171 = sub i64 %168, %170
	%172 = icmp sgt i64 %171, 0
	%173 = select i1 %172, i64 %171, i64 0
	store i64 %173, i64* %18
	br label %switch.done-27

switch.case.next-24:
	%174 = icmp eq i8 %158, 71
	br i1 %174, label %switch.fall.body-26, label %switch.case.next-25

switch.case.next-25:
	br label %switch.done-27

switch.fall.body-26:
	; AssignStmt
	; SelectorExpr
	%175 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %17, i32 0, i32 1
	%176 = load i64, i64* %175, align 8
	store i64 %176, i64* %18
	br label %switch.done-27

switch.done-27:
	br label %if.done-41

if.else-28:
	; SwitchStmt
	%177 = load i8, i8* %1, align 1
	%178 = icmp eq i8 %177, 101
	br i1 %178, label %switch.case.body-31, label %switch.case.next-29

switch.case.next-29:
	%179 = icmp eq i8 %177, 69
	br i1 %179, label %switch.case.body-31, label %switch.case.next-30

switch.case.next-30:
	%180 = icmp eq i8 %177, 102
	br i1 %180, label %switch.fall.body-34, label %switch.case.next-32

switch.case.body-31:
	%181 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%182 = load i64, i64* %18, align 8
	%183 = add i64 %182, 1
	call void @decimal.round(%decimal.Decimal* %181, i64 %183, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-40

switch.case.next-32:
	%184 = icmp eq i8 %177, 70
	br i1 %184, label %switch.fall.body-34, label %switch.case.next-33

switch.case.next-33:
	%185 = icmp eq i8 %177, 103
	br i1 %185, label %switch.fall.body-37, label %switch.case.next-35

switch.fall.body-34:
	%186 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	; SelectorExpr
	%187 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%188 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %187, i32 0, i32 2
	%189 = load i64, i64* %188, align 8
	%190 = load i64, i64* %18, align 8
	%191 = add i64 %189, %190
	call void @decimal.round(%decimal.Decimal* %186, i64 %191, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-40

switch.case.next-35:
	%192 = icmp eq i8 %177, 71
	br i1 %192, label %switch.fall.body-37, label %switch.case.next-36

switch.case.next-36:
	br label %switch.done-40

switch.fall.body-37:
	; IfStmt
	%193 = load i64, i64* %18, align 8
	%194 = icmp eq i64 %193, 0
	%195 = zext i1 %194 to i8
	%196 = trunc i8 %195 to i1
	br i1 %196, label %if.then-38, label %if.done-39

if.then-38:
	; AssignStmt
	store i64 1, i64* %18
	br label %if.done-39

if.done-39:
	%197 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%198 = load i64, i64* %18, align 8
	call void @decimal.round(%decimal.Decimal* %197, i64 %198, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-40

switch.done-40:
	; AssignStmt
	; CompoundLit
	%199 = bitcast %strconv.Decimal_Slice* %22 to %..rawptr
	; ZeroInit
	%200 = call %..rawptr @mem.zero(%..rawptr %199, i64 40)
	store %strconv.Decimal_Slice {{i8*, i64} zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, i8 zeroinitializer}, %strconv.Decimal_Slice* %22
	; SliceExpr
	; SelectorExpr
	%201 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%202 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %201, i32 0, i32 0
	%203 = getelementptr inbounds [384 x i8], [384 x i8]* %202, i32 0, i32 0
	%204 = getelementptr inbounds i8, i8* %203, i64 0
	%205 = sub i64 384, 0
	%206 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %23, i32 0, i32 0
	store i8* %204, i8** %206
	%207 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %23, i32 0, i32 1
	store i64 %205, i64* %207
	%208 = load {i8*, i64}, {i8*, i64}* %23, align 8
	%209 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %22, i32 0, i32 0
	store {i8*, i64} %208, {i8*, i64}* %209
	; SelectorExpr
	%210 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%211 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %210, i32 0, i32 1
	%212 = load i64, i64* %211, align 8
	%213 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %22, i32 0, i32 1
	store i64 %212, i64* %213
	; SelectorExpr
	%214 = load %decimal.Decimal*, %decimal.Decimal** %16, align 8
	%215 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %214, i32 0, i32 2
	%216 = load i64, i64* %215, align 8
	%217 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %22, i32 0, i32 2
	store i64 %216, i64* %217
	%218 = load %strconv.Decimal_Slice, %strconv.Decimal_Slice* %22, align 8
	store %strconv.Decimal_Slice %218, %strconv.Decimal_Slice* %17
	br label %if.done-41

if.done-41:
	; ReturnStmt
	%219 = load i8, i8* %19, align 1
	%220 = load i8, i8* %7, align 1
	%221 = load i64, i64* %18, align 8
	%222 = load i8, i8* %1, align 1
	%223 = trunc i8 %219 to i1
	%224 = trunc i8 %220 to i1
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %24, align 1
	call void @strconv.format_digits({i8*, i64}* %24, {i8*, i64}* %_.0, i1 %223, i1 %224, %strconv.Decimal_Slice* %17, i64 %221, i8 %222, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%225 = load {i8*, i64}, {i8*, i64}* %24, align 8
	store {i8*, i64} %225, {i8*, i64}* %agg.result
	ret void
}

define void @strconv.format_digits({i8*, i64}* sret noalias %agg.result, {i8*, i64}* %_.0, i1 %_.1, i1 %_.2, %strconv.Decimal_Slice* %_.3, i64 %_.4, i8 %_.5, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i8, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	%4 = alloca %strconv.format_digits.Buffer-246, align 16
	%5 = alloca %strconv.format_digits.Buffer-246, align 16
	%6 = alloca i64, align 16
	%7 = alloca {i8*, i64}, align 16
	%8 = alloca [1 x i8], align 16
	%9 = alloca i64, align 16
	%10 = alloca {i8*, i64}, align 16
	%11 = alloca {i8*, i64}, align 16
	%12 = alloca [1 x i8], align 16
	%13 = alloca {i8*, i64}, align 16
	%14 = alloca [1 x i8], align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca [1 x i8], align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca i64, align 16
	%20 = alloca i8, align 16
	%21 = alloca i64, align 16
	%22 = alloca {i8*, i64}, align 16
	%23 = alloca [1 x i8], align 16
	%24 = alloca {i8*, i64}, align 16
	%25 = alloca {i8*, i64}, align 16
	%26 = alloca [1 x i8], align 16
	%27 = alloca i8, align 16
	%28 = alloca {i8*, i64}, align 16
	%29 = alloca [1 x i8], align 16
	%30 = alloca {i8*, i64}, align 16
	%31 = alloca [1 x i8], align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca {i8*, i64}, align 16
	%35 = alloca {i8*, i64}, align 16
	%36 = alloca [1 x i8], align 16
	%37 = alloca {i8*, i64}, align 16
	%38 = alloca [1 x i8], align 16
	%39 = alloca i64, align 16
	%40 = alloca {i8*, i64}, align 16
	%41 = alloca [1 x i8], align 16
	%42 = alloca {i8*, i64}, align 16
	%43 = alloca [2 x i8], align 16
	%44 = alloca {i8*, i64}, align 16
	%45 = alloca [2 x i8], align 16
	%46 = alloca {i8*, i64}, align 16
	%47 = alloca [3 x i8], align 16
	%48 = alloca {i8*, i64}, align 16
	%49 = alloca i64, align 16
	%50 = alloca i64, align 16
	%51 = alloca {i8*, i64}, align 16
	%52 = alloca {i8*, i64}, align 16
	%53 = alloca {i8*, i64}, align 16
	%54 = alloca [2 x i8], align 16
	%55 = alloca {i8*, i64}, align 16
	%56 = zext i1 %_.1 to i8
	store i8 %56, i8* %0
	%57 = zext i1 %_.2 to i8
	store i8 %57, i8* %1
	store i64 %_.4, i64* %2
	store i8 %_.5, i8* %3
	; b
	; CompoundLit
	%58 = bitcast %strconv.format_digits.Buffer-246* %5 to %..rawptr
	; ZeroInit
	%59 = call %..rawptr @mem.zero(%..rawptr %58, i64 24)
	store %strconv.format_digits.Buffer-246 {{i8*, i64} zeroinitializer, i64 zeroinitializer}, %strconv.format_digits.Buffer-246* %5
	%60 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%61 = getelementptr inbounds %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %5, i32 0, i32 0
	store {i8*, i64} %60, {i8*, i64}* %61
	%62 = load %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %5, align 8
	store %strconv.format_digits.Buffer-246 %62, %strconv.format_digits.Buffer-246* %4
	; prec
	%63 = load i64, i64* %2, align 8
	store i64 %63, i64* %6
	; SwitchStmt
	%64 = load i8, i8* %3, align 1
	%65 = icmp eq i8 %64, 102
	br i1 %65, label %switch.case.body-3, label %switch.case.next-1

switch.case.next-1:
	%66 = icmp eq i8 %64, 70
	br i1 %66, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%67 = icmp eq i8 %64, 101
	br i1 %67, label %switch.fall.body-23, label %switch.case.next-21

switch.case.body-3:
	; TernaryExpr
	%68 = load i8, i8* %1, align 1
	%69 = trunc i8 %68 to i1
	br i1 %69, label %if.then-4, label %if.else-5

if.then-4:
	br label %if.done-6

if.else-5:
	br label %if.done-6

if.done-6:
	%70 = phi i32 [ 45, %if.then-4 ], [ 43, %if.else-5 ]
	%71 = trunc i32 %70 to i8
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %7, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %8, align 1
	%72 = getelementptr inbounds [1 x i8], [1 x i8]* %8, i32 0, i32 0
	store i8 %71, i8* %72
	%73 = getelementptr inbounds [1 x i8], [1 x i8]* %8, i32 0, i32 0
	%74 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 0
	store i8* %73, i8** %74
	%75 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %7, i32 0, i32 1
	store i64 1, i64* %75
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %7, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%76 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%77 = load i64, i64* %76, align 8
	%78 = icmp sgt i64 %77, 0
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-7, label %if.else-11

if.then-7:
	; m
	; min
	; SelectorExpr
	%81 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%82 = load i64, i64* %81, align 8
	; SelectorExpr
	%83 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%84 = load i64, i64* %83, align 8
	%85 = icmp slt i64 %84, %82
	%86 = select i1 %85, i64 %84, i64 %82
	store i64 %86, i64* %9
	; SliceExpr
	%87 = load i64, i64* %9, align 8
	; SelectorExpr
	%88 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 0
	%89 = load {i8*, i64}, {i8*, i64}* %88, align 8
	%90 = extractvalue {i8*, i64} %89, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$120, i32 0, i32 0), i64 71}, i64 125, i64 31, i64 0, i64 %87, i64 %90)
	%91 = extractvalue {i8*, i64} %89, 0
	%92 = getelementptr inbounds i8, i8* %91, i64 0
	%93 = sub i64 %87, 0
	%94 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i32 0, i32 0
	store i8* %92, i8** %94
	%95 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %10, i32 0, i32 1
	store i64 %93, i64* %95
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ForStmt
	br label %for.loop-8

for.loop-8:
	%96 = load i64, i64* %9, align 8
	; SelectorExpr
	%97 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%98 = load i64, i64* %97, align 8
	%99 = icmp slt i64 %96, %98
	%100 = zext i1 %99 to i8
	%101 = trunc i8 %100 to i1
	br i1 %101, label %for.body-9, label %for.done-10

for.body-9:
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %11, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %12, align 1
	%102 = getelementptr inbounds [1 x i8], [1 x i8]* %12, i32 0, i32 0
	store i8 48, i8* %102
	%103 = getelementptr inbounds [1 x i8], [1 x i8]* %12, i32 0, i32 0
	%104 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %11, i32 0, i32 0
	store i8* %103, i8** %104
	%105 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %11, i32 0, i32 1
	store i64 1, i64* %105
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %11, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%106 = load i64, i64* %9, align 8
	%107 = add i64 %106, 1
	store i64 %107, i64* %9
	br label %for.loop-8

for.done-10:
	br label %if.done-12

if.else-11:
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %13, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %14, align 1
	%108 = getelementptr inbounds [1 x i8], [1 x i8]* %14, i32 0, i32 0
	store i8 48, i8* %108
	%109 = getelementptr inbounds [1 x i8], [1 x i8]* %14, i32 0, i32 0
	%110 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i32 0, i32 0
	store i8* %109, i8** %110
	%111 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %13, i32 0, i32 1
	store i64 1, i64* %111
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %13, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-12

if.done-12:
	; IfStmt
	%112 = load i64, i64* %6, align 8
	%113 = icmp sgt i64 %112, 0
	%114 = zext i1 %113 to i8
	%115 = trunc i8 %114 to i1
	br i1 %115, label %if.then-13, label %if.done-20

if.then-13:
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %15, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %16, align 1
	%116 = getelementptr inbounds [1 x i8], [1 x i8]* %16, i32 0, i32 0
	store i8 46, i8* %116
	%117 = getelementptr inbounds [1 x i8], [1 x i8]* %16, i32 0, i32 0
	%118 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i32 0, i32 0
	store i8* %117, i8** %118
	%119 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i32 0, i32 1
	store i64 1, i64* %119
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %15, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %17, align 1
	store i64 0, i64* %18
	store i64 0, i64* %19
	br label %for.interval.loop-14

for.interval.loop-14:
	%120 = load i64, i64* %6, align 8
	%121 = load i64, i64* %18, align 8
	%122 = icmp slt i64 %121, %120
	br i1 %122, label %for.interval.body-15, label %for.interval.done-19

for.interval.body-15:
	%123 = load i64, i64* %18, align 8
	%124 = load i64, i64* %18, align 8
	%125 = add i64 %124, 1
	store i64 %125, i64* %18
	%126 = load i64, i64* %19, align 8
	%127 = add i64 %126, 1
	store i64 %127, i64* %19
	store i64 %123, i64* %17
	; c
	store i8 48, i8* %20
	; IfStmt
	; j
	; SelectorExpr
	%128 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%129 = load i64, i64* %128, align 8
	%130 = load i64, i64* %17, align 8
	%131 = add i64 %129, %130
	store i64 %131, i64* %21
	%132 = load i64, i64* %21, align 8
	%133 = icmp sle i64 0, %132
	%134 = zext i1 %133 to i8
	%135 = trunc i8 %134 to i1
	br i1 %135, label %cmp.and-16, label %if.done-18

cmp.and-16:
	%136 = load i64, i64* %21, align 8
	; SelectorExpr
	%137 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%138 = load i64, i64* %137, align 8
	%139 = icmp slt i64 %136, %138
	%140 = zext i1 %139 to i8
	%141 = trunc i8 %140 to i1
	br i1 %141, label %if.then-17, label %if.done-18

if.then-17:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%142 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 0
	%143 = load {i8*, i64}, {i8*, i64}* %142, align 8
	%144 = extractvalue {i8*, i64} %143, 0
	%145 = load i64, i64* %21, align 8
	%146 = extractvalue {i8*, i64} %143, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$121, i32 0, i32 0), i64 71}, i64 140, i64 22, i64 %145, i64 %146)
	%147 = getelementptr inbounds i8, i8* %144, i64 %145
	%148 = load i8, i8* %147, align 1
	store i8 %148, i8* %20
	br label %if.done-18

if.done-18:
	%149 = load i8, i8* %20, align 1
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %22, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %23, align 1
	%150 = getelementptr inbounds [1 x i8], [1 x i8]* %23, i32 0, i32 0
	store i8 %149, i8* %150
	%151 = getelementptr inbounds [1 x i8], [1 x i8]* %23, i32 0, i32 0
	%152 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %22, i32 0, i32 0
	store i8* %151, i8** %152
	%153 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %22, i32 0, i32 1
	store i64 1, i64* %153
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %22, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.interval.loop-14

for.interval.done-19:
	br label %if.done-20

if.done-20:
	; ReturnStmt
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %24, align 1
	call void @strconv.format_digits.to_bytes-0({i8*, i64}* %24, %strconv.format_digits.Buffer-246* %4, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%154 = load {i8*, i64}, {i8*, i64}* %24, align 8
	store {i8*, i64} %154, {i8*, i64}* %agg.result
	ret void

switch.case.next-21:
	%155 = icmp eq i8 %64, 69
	br i1 %155, label %switch.fall.body-23, label %switch.case.next-22

switch.case.next-22:
	%156 = icmp eq i8 %64, 103
	br i1 %156, label %switch.fall.body-47, label %switch.case.next-45

switch.fall.body-23:
	; TernaryExpr
	%157 = load i8, i8* %1, align 1
	%158 = trunc i8 %157 to i1
	br i1 %158, label %if.then-24, label %if.else-25

if.then-24:
	br label %if.done-26

if.else-25:
	br label %if.done-26

if.done-26:
	%159 = phi i32 [ 45, %if.then-24 ], [ 43, %if.else-25 ]
	%160 = trunc i32 %159 to i8
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %25, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %26, align 1
	%161 = getelementptr inbounds [1 x i8], [1 x i8]* %26, i32 0, i32 0
	store i8 %160, i8* %161
	%162 = getelementptr inbounds [1 x i8], [1 x i8]* %26, i32 0, i32 0
	%163 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %25, i32 0, i32 0
	store i8* %162, i8** %163
	%164 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %25, i32 0, i32 1
	store i64 1, i64* %164
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %25, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ch
	store i8 48, i8* %27
	; IfStmt
	; SelectorExpr
	%165 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%166 = load i64, i64* %165, align 8
	%167 = icmp ne i64 %166, 0
	%168 = zext i1 %167 to i8
	%169 = trunc i8 %168 to i1
	br i1 %169, label %if.then-27, label %if.done-28

if.then-27:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%170 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 0
	%171 = load {i8*, i64}, {i8*, i64}* %170, align 8
	%172 = extractvalue {i8*, i64} %171, 0
	%173 = extractvalue {i8*, i64} %171, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$122, i32 0, i32 0), i64 71}, i64 152, i64 21, i64 0, i64 %173)
	%174 = getelementptr inbounds i8, i8* %172, i64 0
	%175 = load i8, i8* %174, align 1
	store i8 %175, i8* %27
	br label %if.done-28

if.done-28:
	%176 = load i8, i8* %27, align 1
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %28, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %29, align 1
	%177 = getelementptr inbounds [1 x i8], [1 x i8]* %29, i32 0, i32 0
	store i8 %176, i8* %177
	%178 = getelementptr inbounds [1 x i8], [1 x i8]* %29, i32 0, i32 0
	%179 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %28, i32 0, i32 0
	store i8* %178, i8** %179
	%180 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %28, i32 0, i32 1
	store i64 1, i64* %180
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %28, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	%181 = load i64, i64* %6, align 8
	%182 = icmp sgt i64 %181, 0
	%183 = zext i1 %182 to i8
	%184 = trunc i8 %183 to i1
	br i1 %184, label %if.then-29, label %if.done-35

if.then-29:
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %30, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %31, align 1
	%185 = getelementptr inbounds [1 x i8], [1 x i8]* %31, i32 0, i32 0
	store i8 46, i8* %185
	%186 = getelementptr inbounds [1 x i8], [1 x i8]* %31, i32 0, i32 0
	%187 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %30, i32 0, i32 0
	store i8* %186, i8** %187
	%188 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %30, i32 0, i32 1
	store i64 1, i64* %188
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %30, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; i
	store i64 1, i64* %32
	; m
	; min
	%189 = load i64, i64* %6, align 8
	%190 = add i64 %189, 1
	; SelectorExpr
	%191 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%192 = load i64, i64* %191, align 8
	%193 = icmp slt i64 %192, %190
	%194 = select i1 %193, i64 %192, i64 %190
	store i64 %194, i64* %33
	; IfStmt
	%195 = load i64, i64* %32, align 8
	%196 = load i64, i64* %33, align 8
	%197 = icmp slt i64 %195, %196
	%198 = zext i1 %197 to i8
	%199 = trunc i8 %198 to i1
	br i1 %199, label %if.then-30, label %if.done-31

if.then-30:
	; SliceExpr
	%200 = load i64, i64* %32, align 8
	%201 = load i64, i64* %33, align 8
	; SelectorExpr
	%202 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 0
	%203 = load {i8*, i64}, {i8*, i64}* %202, align 8
	%204 = extractvalue {i8*, i64} %203, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$123, i32 0, i32 0), i64 71}, i64 161, i64 32, i64 %200, i64 %201, i64 %204)
	%205 = extractvalue {i8*, i64} %203, 0
	%206 = getelementptr inbounds i8, i8* %205, i64 %200
	%207 = sub i64 %201, %200
	%208 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %34, i32 0, i32 0
	store i8* %206, i8** %208
	%209 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %34, i32 0, i32 1
	store i64 %207, i64* %209
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %34, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%210 = load i64, i64* %33, align 8
	store i64 %210, i64* %32
	br label %if.done-31

if.done-31:
	; ForStmt
	br label %for.loop-32

for.loop-32:
	%211 = load i64, i64* %32, align 8
	%212 = load i64, i64* %6, align 8
	%213 = icmp sle i64 %211, %212
	%214 = zext i1 %213 to i8
	%215 = trunc i8 %214 to i1
	br i1 %215, label %for.body-33, label %for.done-34

for.body-33:
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %35, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %36, align 1
	%216 = getelementptr inbounds [1 x i8], [1 x i8]* %36, i32 0, i32 0
	store i8 48, i8* %216
	%217 = getelementptr inbounds [1 x i8], [1 x i8]* %36, i32 0, i32 0
	%218 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %35, i32 0, i32 0
	store i8* %217, i8** %218
	%219 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %35, i32 0, i32 1
	store i64 1, i64* %219
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %35, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%220 = load i64, i64* %32, align 8
	%221 = add i64 %220, 1
	store i64 %221, i64* %32
	br label %for.loop-32

for.done-34:
	br label %if.done-35

if.done-35:
	%222 = load i8, i8* %3, align 1
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %37, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %38, align 1
	%223 = getelementptr inbounds [1 x i8], [1 x i8]* %38, i32 0, i32 0
	store i8 %222, i8* %223
	%224 = getelementptr inbounds [1 x i8], [1 x i8]* %38, i32 0, i32 0
	%225 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %37, i32 0, i32 0
	store i8* %224, i8** %225
	%226 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %37, i32 0, i32 1
	store i64 1, i64* %226
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %37, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; exp
	; SelectorExpr
	%227 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%228 = load i64, i64* %227, align 8
	%229 = sub i64 %228, 1
	store i64 %229, i64* %39
	; IfStmt
	; SelectorExpr
	%230 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%231 = load i64, i64* %230, align 8
	%232 = icmp eq i64 %231, 0
	%233 = zext i1 %232 to i8
	%234 = trunc i8 %233 to i1
	br i1 %234, label %if.then-36, label %if.done-37

if.then-36:
	; AssignStmt
	store i64 0, i64* %39
	br label %if.done-37

if.done-37:
	; AssignStmt
	store i8 43, i8* %27
	; IfStmt
	%235 = load i64, i64* %39, align 8
	%236 = icmp slt i64 %235, 0
	%237 = zext i1 %236 to i8
	%238 = trunc i8 %237 to i1
	br i1 %238, label %if.then-38, label %if.done-39

if.then-38:
	; AssignStmt
	store i8 45, i8* %27
	; AssignStmt
	%239 = load i64, i64* %39, align 8
	%240 = sub i64 0, %239
	store i64 %240, i64* %39
	br label %if.done-39

if.done-39:
	%241 = load i8, i8* %27, align 1
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %40, align 1
	; ZeroInit
	store [1 x i8] zeroinitializer, [1 x i8]* %41, align 1
	%242 = getelementptr inbounds [1 x i8], [1 x i8]* %41, i32 0, i32 0
	store i8 %241, i8* %242
	%243 = getelementptr inbounds [1 x i8], [1 x i8]* %41, i32 0, i32 0
	%244 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %40, i32 0, i32 0
	store i8* %243, i8** %244
	%245 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %40, i32 0, i32 1
	store i64 1, i64* %245
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %40, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SwitchStmt
	%246 = load i64, i64* %39, align 8
	%247 = icmp slt i64 %246, 10
	%248 = zext i1 %247 to i8
	%249 = icmp eq i8 1, %248
	br i1 %249, label %switch.case.body-41, label %switch.case.next-40

switch.case.next-40:
	%250 = load i64, i64* %39, align 8
	%251 = icmp slt i64 %250, 100
	%252 = zext i1 %251 to i8
	%253 = icmp eq i8 1, %252
	br i1 %253, label %switch.fall.body-43, label %switch.case.next-42

switch.case.body-41:
	%254 = load i64, i64* %39, align 8
	%255 = trunc i64 %254 to i8
	%256 = add i8 %255, 48
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %42, align 1
	; ZeroInit
	store [2 x i8] zeroinitializer, [2 x i8]* %43, align 1
	%257 = getelementptr inbounds [2 x i8], [2 x i8]* %43, i32 0, i32 0
	store i8 48, i8* %257
	%258 = getelementptr inbounds [2 x i8], [2 x i8]* %43, i32 0, i32 1
	store i8 %256, i8* %258
	%259 = getelementptr inbounds [2 x i8], [2 x i8]* %43, i32 0, i32 0
	%260 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %42, i32 0, i32 0
	store i8* %259, i8** %260
	%261 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %42, i32 0, i32 1
	store i64 2, i64* %261
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %42, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-42:
	%262 = load i64, i64* %39, align 8
	%263 = sdiv i64 %262, 100
	%264 = trunc i64 %263 to i8
	%265 = add i8 %264, 48
	%266 = load i64, i64* %39, align 8
	%267 = sdiv i64 %266, 10
	%268 = trunc i64 %267 to i8
	%269 = urem i8 %268, 10
	%270 = add i8 %269, 48
	%271 = load i64, i64* %39, align 8
	%272 = srem i64 %271, 10
	%273 = trunc i64 %272 to i8
	%274 = add i8 %273, 48
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %46, align 1
	%275 = bitcast [3 x i8]* %47 to %..rawptr
	; ZeroInit
	%276 = call %..rawptr @mem.zero(%..rawptr %275, i64 3)
	%277 = getelementptr inbounds [3 x i8], [3 x i8]* %47, i32 0, i32 0
	store i8 %265, i8* %277
	%278 = getelementptr inbounds [3 x i8], [3 x i8]* %47, i32 0, i32 1
	store i8 %270, i8* %278
	%279 = getelementptr inbounds [3 x i8], [3 x i8]* %47, i32 0, i32 2
	store i8 %274, i8* %279
	%280 = getelementptr inbounds [3 x i8], [3 x i8]* %47, i32 0, i32 0
	%281 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %46, i32 0, i32 0
	store i8* %280, i8** %281
	%282 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %46, i32 0, i32 1
	store i64 3, i64* %282
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %46, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.fall.body-43:
	%283 = load i64, i64* %39, align 8
	%284 = sdiv i64 %283, 10
	%285 = trunc i64 %284 to i8
	%286 = add i8 %285, 48
	%287 = load i64, i64* %39, align 8
	%288 = srem i64 %287, 10
	%289 = trunc i64 %288 to i8
	%290 = add i8 %289, 48
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %44, align 1
	; ZeroInit
	store [2 x i8] zeroinitializer, [2 x i8]* %45, align 1
	%291 = getelementptr inbounds [2 x i8], [2 x i8]* %45, i32 0, i32 0
	store i8 %286, i8* %291
	%292 = getelementptr inbounds [2 x i8], [2 x i8]* %45, i32 0, i32 1
	store i8 %290, i8* %292
	%293 = getelementptr inbounds [2 x i8], [2 x i8]* %45, i32 0, i32 0
	%294 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %44, i32 0, i32 0
	store i8* %293, i8** %294
	%295 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %44, i32 0, i32 1
	store i64 2, i64* %295
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %44, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.done-44:
	; ReturnStmt
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %48, align 1
	call void @strconv.format_digits.to_bytes-0({i8*, i64}* %48, %strconv.format_digits.Buffer-246* %4, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%296 = load {i8*, i64}, {i8*, i64}* %48, align 8
	store {i8*, i64} %296, {i8*, i64}* %agg.result
	ret void

switch.case.next-45:
	%297 = icmp eq i8 %64, 71
	br i1 %297, label %switch.fall.body-47, label %switch.case.next-46

switch.case.next-46:
	%298 = load i8, i8* %3, align 1
	; variadic call argument generation
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %53, align 1
	; ZeroInit
	store [2 x i8] zeroinitializer, [2 x i8]* %54, align 1
	%299 = getelementptr inbounds [2 x i8], [2 x i8]* %54, i32 0, i32 0
	store i8 37, i8* %299
	%300 = getelementptr inbounds [2 x i8], [2 x i8]* %54, i32 0, i32 1
	store i8 %298, i8* %300
	%301 = getelementptr inbounds [2 x i8], [2 x i8]* %54, i32 0, i32 0
	%302 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %53, i32 0, i32 0
	store i8* %301, i8** %302
	%303 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %53, i32 0, i32 1
	store i64 2, i64* %303
	call void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %4, {i8*, i64}* %53, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %55, align 1
	call void @strconv.format_digits.to_bytes-0({i8*, i64}* %55, %strconv.format_digits.Buffer-246* %4, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%304 = load {i8*, i64}, {i8*, i64}* %55, align 8
	store {i8*, i64} %304, {i8*, i64}* %agg.result
	ret void

switch.fall.body-47:
	; eprec
	%305 = load i64, i64* %6, align 8
	store i64 %305, i64* %49
	; IfStmt
	%306 = load i64, i64* %49, align 8
	; SelectorExpr
	%307 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%308 = load i64, i64* %307, align 8
	%309 = icmp sgt i64 %306, %308
	%310 = zext i1 %309 to i8
	%311 = trunc i8 %310 to i1
	br i1 %311, label %cmp.and-48, label %if.done-50

cmp.and-48:
	; SelectorExpr
	%312 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%313 = load i64, i64* %312, align 8
	; SelectorExpr
	%314 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%315 = load i64, i64* %314, align 8
	%316 = icmp sge i64 %313, %315
	%317 = zext i1 %316 to i8
	%318 = trunc i8 %317 to i1
	br i1 %318, label %if.then-49, label %if.done-50

if.then-49:
	; AssignStmt
	; SelectorExpr
	%319 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%320 = load i64, i64* %319, align 8
	store i64 %320, i64* %49
	br label %if.done-50

if.done-50:
	; IfStmt
	%321 = load i8, i8* %0, align 1
	%322 = trunc i8 %321 to i1
	br i1 %322, label %if.then-51, label %if.done-52

if.then-51:
	; AssignStmt
	store i64 6, i64* %49
	br label %if.done-52

if.done-52:
	; exp
	; SelectorExpr
	%323 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%324 = load i64, i64* %323, align 8
	%325 = sub i64 %324, 1
	store i64 %325, i64* %50
	; IfStmt
	%326 = load i64, i64* %50, align 8
	%327 = icmp slt i64 %326, -4
	%328 = zext i1 %327 to i8
	%329 = trunc i8 %328 to i1
	br i1 %329, label %if.then-54, label %cmp.or-53

cmp.or-53:
	%330 = load i64, i64* %50, align 8
	%331 = load i64, i64* %49, align 8
	%332 = icmp sge i64 %330, %331
	%333 = zext i1 %332 to i8
	%334 = trunc i8 %333 to i1
	br i1 %334, label %if.then-54, label %if.done-57

if.then-54:
	; IfStmt
	%335 = load i64, i64* %6, align 8
	; SelectorExpr
	%336 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%337 = load i64, i64* %336, align 8
	%338 = icmp sgt i64 %335, %337
	%339 = zext i1 %338 to i8
	%340 = trunc i8 %339 to i1
	br i1 %340, label %if.then-55, label %if.done-56

if.then-55:
	; AssignStmt
	; SelectorExpr
	%341 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%342 = load i64, i64* %341, align 8
	store i64 %342, i64* %6
	br label %if.done-56

if.done-56:
	; ReturnStmt
	%343 = load i8, i8* %0, align 1
	%344 = load i8, i8* %1, align 1
	%345 = load i64, i64* %6, align 8
	%346 = sub i64 %345, 1
	%347 = load i8, i8* %3, align 1
	%348 = add i8 %347, 101
	%349 = sub i8 %348, 103
	%350 = trunc i8 %343 to i1
	%351 = trunc i8 %344 to i1
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %51, align 1
	call void @strconv.format_digits({i8*, i64}* %51, {i8*, i64}* %_.0, i1 %350, i1 %351, %strconv.Decimal_Slice* %_.3, i64 %346, i8 %349, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%352 = load {i8*, i64}, {i8*, i64}* %51, align 8
	store {i8*, i64} %352, {i8*, i64}* %agg.result
	ret void

if.done-57:
	; IfStmt
	%353 = load i64, i64* %6, align 8
	; SelectorExpr
	%354 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%355 = load i64, i64* %354, align 8
	%356 = icmp sgt i64 %353, %355
	%357 = zext i1 %356 to i8
	%358 = trunc i8 %357 to i1
	br i1 %358, label %if.then-58, label %if.done-59

if.then-58:
	; AssignStmt
	; SelectorExpr
	%359 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 1
	%360 = load i64, i64* %359, align 8
	store i64 %360, i64* %6
	br label %if.done-59

if.done-59:
	; ReturnStmt
	%361 = load i8, i8* %0, align 1
	%362 = load i8, i8* %1, align 1
	; max
	%363 = load i64, i64* %6, align 8
	; SelectorExpr
	%364 = getelementptr inbounds %strconv.Decimal_Slice, %strconv.Decimal_Slice* %_.3, i32 0, i32 2
	%365 = load i64, i64* %364, align 8
	%366 = sub i64 %363, %365
	%367 = icmp sgt i64 %366, 0
	%368 = select i1 %367, i64 %366, i64 0
	%369 = trunc i8 %361 to i1
	%370 = trunc i8 %362 to i1
	; ZeroInit
	store {i8*, i64} zeroinitializer, {i8*, i64}* %52, align 1
	call void @strconv.format_digits({i8*, i64}* %52, {i8*, i64}* %_.0, i1 %369, i1 %370, %strconv.Decimal_Slice* %_.3, i64 %368, i8 102, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%371 = load {i8*, i64}, {i8*, i64}* %52, align 8
	store {i8*, i64} %371, {i8*, i64}* %agg.result
	ret void
}

define void @strconv.format_digits.to_bytes-0({i8*, i64}* sret noalias %agg.result, %strconv.format_digits.Buffer-246* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	; ReturnStmt
	; SliceExpr
	; SelectorExpr
	%1 = getelementptr inbounds %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %_.0, i32 0, i32 1
	%2 = load i64, i64* %1, align 8
	; SelectorExpr
	%3 = getelementptr inbounds %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %_.0, i32 0, i32 0
	%4 = load {i8*, i64}, {i8*, i64}* %3, align 8
	%5 = extractvalue {i8*, i64} %4, 1
	call void @runtime.slice_expr_error_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$124, i32 0, i32 0), i64 71}, i64 110, i64 53, i64 %2, i64 %5)
	%6 = extractvalue {i8*, i64} %4, 0
	%7 = getelementptr inbounds i8, i8* %6, i64 0
	%8 = sub i64 %2, 0
	%9 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i32 0, i32 0
	store i8* %7, i8** %9
	%10 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i32 0, i32 1
	store i64 %8, i64* %10
	%11 = load {i8*, i64}, {i8*, i64}* %0, align 8
	store {i8*, i64} %11, {i8*, i64}* %agg.result
	ret void
}

define void @strconv.format_digits.add_bytes-1(%strconv.format_digits.Buffer-246* %_.0, {i8*, i64}* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strconv.format_digits.Buffer-246*, align 16
	%1 = alloca {i8*, i64}, align 16
	store %strconv.format_digits.Buffer-246* %_.0, %strconv.format_digits.Buffer-246** %0
	; AssignStmt
	; SelectorExpr
	%2 = load %strconv.format_digits.Buffer-246*, %strconv.format_digits.Buffer-246** %0, align 8
	%3 = getelementptr inbounds %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %2, i32 0, i32 1
	; SliceExpr
	; SelectorExpr
	%4 = load %strconv.format_digits.Buffer-246*, %strconv.format_digits.Buffer-246** %0, align 8
	%5 = getelementptr inbounds %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %4, i32 0, i32 1
	%6 = load i64, i64* %5, align 8
	; SelectorExpr
	%7 = load %strconv.format_digits.Buffer-246*, %strconv.format_digits.Buffer-246** %0, align 8
	%8 = getelementptr inbounds %strconv.format_digits.Buffer-246, %strconv.format_digits.Buffer-246* %7, i32 0, i32 0
	%9 = load {i8*, i64}, {i8*, i64}* %8, align 8
	%10 = extractvalue {i8*, i64} %9, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$125, i32 0, i32 0), i64 71}, i64 112, i64 22, i64 %6, i64 %10, i64 %10)
	%11 = extractvalue {i8*, i64} %9, 0
	%12 = getelementptr inbounds i8, i8* %11, i64 %6
	%13 = sub i64 %10, %6
	%14 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i32 0, i32 0
	store i8* %12, i8** %14
	%15 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1, i32 0, i32 1
	store i64 %13, i64* %15
	%16 = call i64 @runtime.copy-7722({i8*, i64}* %1, {i8*, i64}* %_.1)
	%17 = load i64, i64* %3, align 8
	%18 = add i64 %17, %16
	store i64 %18, i64* %3
	ret void
}

define void @strconv.round_shortest(%decimal.Decimal* %_.0, i64 %_.1, i64 %_.2, %strconv.Float_Info* %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %strconv.Float_Info*, align 16
	%4 = alloca i64, align 16
	%5 = alloca %decimal.Decimal, align 16
	%6 = alloca %decimal.Decimal*, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca %decimal.Decimal, align 16
	%10 = alloca %decimal.Decimal*, align 16
	%11 = alloca i8, align 16
	%12 = alloca i64, align 16
	%13 = alloca i64, align 16
	%14 = alloca i64, align 16
	%15 = alloca i8, align 16
	%16 = alloca i8, align 16
	%17 = alloca i8, align 16
	%18 = alloca i8, align 16
	%19 = alloca i8, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	store %strconv.Float_Info* %_.3, %strconv.Float_Info** %3
	; IfStmt
	%20 = load i64, i64* %1, align 8
	%21 = icmp eq i64 %20, 0
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%24 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%25 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %24, i32 0, i32 1
	store i64 0, i64* %25
	; ReturnStmt
	ret void

if.done-2:
	; minexp
	; SelectorExpr
	%26 = load %strconv.Float_Info*, %strconv.Float_Info** %3, align 8
	%27 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %26, i32 0, i32 2
	%28 = load i64, i64* %27, align 8
	%29 = add i64 %28, 1
	store i64 %29, i64* %4
	; IfStmt
	%30 = load i64, i64* %2, align 8
	%31 = load i64, i64* %4, align 8
	%32 = icmp sgt i64 %30, %31
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %cmp.and-3, label %if.done-5

cmp.and-3:
	; SelectorExpr
	%35 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%36 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %35, i32 0, i32 2
	%37 = load i64, i64* %36, align 8
	; SelectorExpr
	%38 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i32 0, i32 1
	%40 = load i64, i64* %39, align 8
	%41 = sub i64 %37, %40
	%42 = mul i64 332, %41
	%43 = load i64, i64* %2, align 8
	; SelectorExpr
	%44 = load %strconv.Float_Info*, %strconv.Float_Info** %3, align 8
	%45 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %44, i32 0, i32 0
	%46 = load i64, i64* %45, align 8
	%47 = bitcast i64 %46 to i64
	%48 = sub i64 %43, %47
	%49 = mul i64 100, %48
	%50 = icmp sge i64 %42, %49
	%51 = zext i1 %50 to i8
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-4, label %if.done-5

if.then-4:
	; ReturnStmt
	ret void

if.done-5:
	; upper_
	%53 = bitcast %decimal.Decimal* %5 to %..rawptr
	; ZeroInit
	%54 = call %..rawptr @mem.zero(%..rawptr %53, i64 408)
	; upper
	store %decimal.Decimal* %5, %decimal.Decimal** %6
	%55 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%56 = load i64, i64* %1, align 8
	%57 = mul i64 2, %56
	%58 = sub i64 %57, 1
	call void @decimal.assign(%decimal.Decimal* %55, i64 %58, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%59 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%60 = load i64, i64* %2, align 8
	; SelectorExpr
	%61 = load %strconv.Float_Info*, %strconv.Float_Info** %3, align 8
	%62 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %61, i32 0, i32 0
	%63 = load i64, i64* %62, align 8
	%64 = bitcast i64 %63 to i64
	%65 = sub i64 %60, %64
	%66 = sub i64 %65, 1
	call void @decimal.shift(%decimal.Decimal* %59, i64 %66, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; mantlo
	; ZeroInit
	store i64 zeroinitializer, i64* %7, align 1
	; explo
	; ZeroInit
	store i64 zeroinitializer, i64* %8, align 1
	; IfStmt
	%67 = load i64, i64* %1, align 8
	; SelectorExpr
	%68 = load %strconv.Float_Info*, %strconv.Float_Info** %3, align 8
	%69 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %68, i32 0, i32 0
	%70 = load i64, i64* %69, align 8
	%71 = bitcast i64 %70 to i64
	%72 = shl i64 1, %71
	%73 = icmp ugt i64 %67, %72
	%74 = zext i1 %73 to i8
	%75 = trunc i8 %74 to i1
	br i1 %75, label %if.then-7, label %cmp.or-6

cmp.or-6:
	%76 = load i64, i64* %2, align 8
	%77 = load i64, i64* %4, align 8
	%78 = icmp eq i64 %76, %77
	%79 = zext i1 %78 to i8
	%80 = trunc i8 %79 to i1
	br i1 %80, label %if.then-7, label %if.else-8

if.then-7:
	; AssignStmt
	%81 = load i64, i64* %1, align 8
	%82 = sub i64 %81, 1
	store i64 %82, i64* %7
	; AssignStmt
	%83 = load i64, i64* %2, align 8
	store i64 %83, i64* %8
	br label %if.done-9

if.else-8:
	; AssignStmt
	%84 = load i64, i64* %1, align 8
	%85 = mul i64 2, %84
	%86 = sub i64 %85, 1
	store i64 %86, i64* %7
	; AssignStmt
	%87 = load i64, i64* %2, align 8
	%88 = sub i64 %87, 1
	store i64 %88, i64* %8
	br label %if.done-9

if.done-9:
	; lower_
	%89 = bitcast %decimal.Decimal* %9 to %..rawptr
	; ZeroInit
	%90 = call %..rawptr @mem.zero(%..rawptr %89, i64 408)
	; lower
	store %decimal.Decimal* %9, %decimal.Decimal** %10
	%91 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%92 = load i64, i64* %7, align 8
	%93 = mul i64 2, %92
	%94 = add i64 %93, 1
	call void @decimal.assign(%decimal.Decimal* %91, i64 %94, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%95 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%96 = load i64, i64* %8, align 8
	; SelectorExpr
	%97 = load %strconv.Float_Info*, %strconv.Float_Info** %3, align 8
	%98 = getelementptr inbounds %strconv.Float_Info, %strconv.Float_Info* %97, i32 0, i32 0
	%99 = load i64, i64* %98, align 8
	%100 = bitcast i64 %99 to i64
	%101 = sub i64 %96, %100
	%102 = sub i64 %101, 1
	call void @decimal.shift(%decimal.Decimal* %95, i64 %102, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; inclusive
	%103 = load i64, i64* %1, align 8
	%104 = urem i64 %103, 2
	%105 = icmp eq i64 %104, 0
	%106 = zext i1 %105 to i8
	store i8 %106, i8* %11
	; RangeStmt
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %12, align 1
	store i64 0, i64* %13
	store i64 0, i64* %14
	br label %for.interval.loop-10

for.interval.loop-10:
	; SelectorExpr
	%107 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%108 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %107, i32 0, i32 1
	%109 = load i64, i64* %108, align 8
	%110 = load i64, i64* %13, align 8
	%111 = icmp slt i64 %110, %109
	br i1 %111, label %for.interval.body-11, label %for.interval.done-34

for.interval.body-11:
	%112 = load i64, i64* %13, align 8
	%113 = load i64, i64* %13, align 8
	%114 = add i64 %113, 1
	store i64 %114, i64* %13
	%115 = load i64, i64* %14, align 8
	%116 = add i64 %115, 1
	store i64 %116, i64* %14
	store i64 %112, i64* %12
	; l
	store i8 48, i8* %15
	; IfStmt
	%117 = load i64, i64* %12, align 8
	; SelectorExpr
	%118 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%119 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %118, i32 0, i32 1
	%120 = load i64, i64* %119, align 8
	%121 = icmp slt i64 %117, %120
	%122 = zext i1 %121 to i8
	%123 = trunc i8 %122 to i1
	br i1 %123, label %if.then-12, label %if.done-13

if.then-12:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%124 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%125 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %124, i32 0, i32 0
	%126 = load i64, i64* %12, align 8
	%127 = trunc i64 %126 to i32
	%128 = getelementptr inbounds [384 x i8], [384 x i8]* %125, i32 0, i32 %127
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$126, i32 0, i32 0), i64 71}, i64 263, i64 21, i64 %126, i64 384)
	%129 = load i8, i8* %128, align 1
	store i8 %129, i8* %15
	br label %if.done-13

if.done-13:
	; m
	; IndexExpr
	; SelectorExpr
	%130 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%131 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %130, i32 0, i32 0
	%132 = load i64, i64* %12, align 8
	%133 = trunc i64 %132 to i32
	%134 = getelementptr inbounds [384 x i8], [384 x i8]* %131, i32 0, i32 %133
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$127, i32 0, i32 0), i64 71}, i64 265, i64 17, i64 %132, i64 384)
	%135 = load i8, i8* %134, align 1
	store i8 %135, i8* %16
	; u
	store i8 48, i8* %17
	; IfStmt
	%136 = load i64, i64* %12, align 8
	; SelectorExpr
	%137 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%138 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %137, i32 0, i32 1
	%139 = load i64, i64* %138, align 8
	%140 = icmp slt i64 %136, %139
	%141 = zext i1 %140 to i8
	%142 = trunc i8 %141 to i1
	br i1 %142, label %if.then-14, label %if.done-15

if.then-14:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%143 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%144 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %143, i32 0, i32 0
	%145 = load i64, i64* %12, align 8
	%146 = trunc i64 %145 to i32
	%147 = getelementptr inbounds [384 x i8], [384 x i8]* %144, i32 0, i32 %146
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$128, i32 0, i32 0), i64 71}, i64 268, i64 21, i64 %145, i64 384)
	%148 = load i8, i8* %147, align 1
	store i8 %148, i8* %17
	br label %if.done-15

if.done-15:
	; ok_round_down
	%149 = load i8, i8* %15, align 1
	%150 = load i8, i8* %16, align 1
	%151 = icmp ne i8 %149, %150
	%152 = zext i1 %151 to i8
	%153 = load i8, i8* %15, align 1
	%154 = load i8, i8* %16, align 1
	%155 = icmp ne i8 %153, %154
	%156 = zext i1 %155 to i8
	%157 = trunc i8 %156 to i1
	br i1 %157, label %logical.cmp.done-19, label %logical.cmp.rhs-16

logical.cmp.rhs-16:
	%158 = load i8, i8* %11, align 1
	%159 = trunc i8 %158 to i1
	br i1 %159, label %logical.cmp.rhs-17, label %logical.cmp.done-18

logical.cmp.rhs-17:
	%160 = load i64, i64* %12, align 8
	%161 = add i64 %160, 1
	; SelectorExpr
	%162 = load %decimal.Decimal*, %decimal.Decimal** %10, align 8
	%163 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %162, i32 0, i32 1
	%164 = load i64, i64* %163, align 8
	%165 = icmp eq i64 %161, %164
	%166 = zext i1 %165 to i8
	br label %logical.cmp.done-18

logical.cmp.done-18:
	%167 = phi i8 [ 0, %logical.cmp.rhs-16 ], [ %166, %logical.cmp.rhs-17 ]
	br label %logical.cmp.done-19

logical.cmp.done-19:
	%168 = phi i8 [ 1, %if.done-15 ], [ %167, %logical.cmp.done-18 ]
	store i8 %168, i8* %18
	; ok_round_up
	%169 = load i8, i8* %16, align 1
	%170 = load i8, i8* %17, align 1
	%171 = icmp ne i8 %169, %170
	%172 = zext i1 %171 to i8
	%173 = load i8, i8* %16, align 1
	%174 = load i8, i8* %17, align 1
	%175 = icmp ne i8 %173, %174
	%176 = zext i1 %175 to i8
	%177 = trunc i8 %176 to i1
	br i1 %177, label %logical.cmp.rhs-20, label %logical.cmp.done-26

logical.cmp.rhs-20:
	%178 = load i8, i8* %11, align 1
	%179 = trunc i8 %178 to i1
	br i1 %179, label %logical.cmp.done-22, label %logical.cmp.rhs-21

logical.cmp.rhs-21:
	%180 = load i8, i8* %16, align 1
	%181 = add i8 %180, 1
	%182 = load i8, i8* %17, align 1
	%183 = icmp ult i8 %181, %182
	%184 = zext i1 %183 to i8
	br label %logical.cmp.done-22

logical.cmp.done-22:
	%185 = phi i8 [ 1, %logical.cmp.rhs-20 ], [ %184, %logical.cmp.rhs-21 ]
	%186 = load i8, i8* %11, align 1
	%187 = trunc i8 %186 to i1
	br i1 %187, label %logical.cmp.done-25, label %cmp.or-23

cmp.or-23:
	%188 = load i8, i8* %16, align 1
	%189 = add i8 %188, 1
	%190 = load i8, i8* %17, align 1
	%191 = icmp ult i8 %189, %190
	%192 = zext i1 %191 to i8
	%193 = trunc i8 %192 to i1
	br i1 %193, label %logical.cmp.done-25, label %logical.cmp.rhs-24

logical.cmp.rhs-24:
	%194 = load i64, i64* %12, align 8
	%195 = add i64 %194, 1
	; SelectorExpr
	%196 = load %decimal.Decimal*, %decimal.Decimal** %6, align 8
	%197 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %196, i32 0, i32 1
	%198 = load i64, i64* %197, align 8
	%199 = icmp slt i64 %195, %198
	%200 = zext i1 %199 to i8
	br label %logical.cmp.done-25

logical.cmp.done-25:
	%201 = phi i8 [ 1, %logical.cmp.done-22 ], [ 1, %cmp.or-23 ], [ %200, %logical.cmp.rhs-24 ]
	br label %logical.cmp.done-26

logical.cmp.done-26:
	%202 = phi i8 [ 0, %logical.cmp.done-19 ], [ %201, %logical.cmp.done-25 ]
	store i8 %202, i8* %19
	; IfStmt
	%203 = load i8, i8* %18, align 1
	%204 = trunc i8 %203 to i1
	br i1 %204, label %cmp.and-27, label %if.done-29

cmp.and-27:
	%205 = load i8, i8* %19, align 1
	%206 = trunc i8 %205 to i1
	br i1 %206, label %if.then-28, label %if.done-29

if.then-28:
	%207 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%208 = load i64, i64* %12, align 8
	%209 = add i64 %208, 1
	call void @decimal.round(%decimal.Decimal* %207, i64 %209, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-29:
	; IfStmt
	%210 = load i8, i8* %18, align 1
	%211 = trunc i8 %210 to i1
	br i1 %211, label %if.then-30, label %if.done-31

if.then-30:
	%212 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%213 = load i64, i64* %12, align 8
	%214 = add i64 %213, 1
	call void @decimal.round_down(%decimal.Decimal* %212, i64 %214, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-31:
	; IfStmt
	%215 = load i8, i8* %19, align 1
	%216 = trunc i8 %215 to i1
	br i1 %216, label %if.then-32, label %if.done-33

if.then-32:
	%217 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%218 = load i64, i64* %12, align 8
	%219 = add i64 %218, 1
	call void @decimal.round_up(%decimal.Decimal* %217, i64 %219, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-33:
	br label %for.interval.loop-10

for.interval.done-34:
	ret void
}

define void @strconv.is_integer_negative({i64, i8}* sret noalias %agg.result, i64 %_.0, i1 %_.1, i64 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i8, align 16
	%5 = alloca i8, align 16
	%6 = alloca i16, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca %runtime.Source_Code_Location, align 16
	%10 = alloca {i64, i8}, align 16
	store i64 %_.0, i64* %0
	%11 = zext i1 %_.1 to i8
	store i8 %11, i8* %1
	store i64 %_.2, i64* %2
	; ZeroInit
	store i64 zeroinitializer, i64* %3, align 1
	; ZeroInit
	store i8 zeroinitializer, i8* %4, align 1
	; AssignStmt
	%12 = load i64, i64* %0, align 8
	store i64 %12, i64* %3
	; IfStmt
	%13 = load i8, i8* %1, align 1
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-1, label %if.done-11

if.then-1:
	; SwitchStmt
	%15 = load i64, i64* %2, align 8
	%16 = icmp eq i64 %15, 8
	br i1 %16, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%17 = icmp eq i64 %15, 16
	br i1 %17, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; i
	%18 = load i64, i64* %3, align 8
	%19 = trunc i64 %18 to i8
	store i8 %19, i8* %5
	; AssignStmt
	%20 = load i8, i8* %5, align 1
	%21 = icmp slt i8 %20, 0
	%22 = zext i1 %21 to i8
	store i8 %22, i8* %4
	; AssignStmt
	%23 = load i8, i8* %5, align 1
	%24 = sext i8 %23 to i64
	; abs
	%25 = icmp slt i64 %24, 0
	%26 = sub i64 0, %24
	%27 = select i1 %25, i64 %26, i64 %24
	%28 = bitcast i64 %27 to i64
	store i64 %28, i64* %3
	br label %switch.done-10

switch.case.next-4:
	%29 = icmp eq i64 %15, 32
	br i1 %29, label %switch.fall.body-7, label %switch.case.next-6

switch.fall.body-5:
	; i
	%30 = load i64, i64* %3, align 8
	%31 = trunc i64 %30 to i16
	store i16 %31, i16* %6
	; AssignStmt
	%32 = load i16, i16* %6, align 2
	%33 = icmp slt i16 %32, 0
	%34 = zext i1 %33 to i8
	store i8 %34, i8* %4
	; AssignStmt
	%35 = load i16, i16* %6, align 2
	%36 = sext i16 %35 to i64
	; abs
	%37 = icmp slt i64 %36, 0
	%38 = sub i64 0, %36
	%39 = select i1 %37, i64 %38, i64 %36
	%40 = bitcast i64 %39 to i64
	store i64 %40, i64* %3
	br label %switch.done-10

switch.case.next-6:
	%41 = icmp eq i64 %15, 64
	br i1 %41, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-7:
	; i
	%42 = load i64, i64* %3, align 8
	%43 = trunc i64 %42 to i32
	store i32 %43, i32* %7
	; AssignStmt
	%44 = load i32, i32* %7, align 4
	%45 = icmp slt i32 %44, 0
	%46 = zext i1 %45 to i8
	store i8 %46, i8* %4
	; AssignStmt
	%47 = load i32, i32* %7, align 4
	%48 = sext i32 %47 to i64
	; abs
	%49 = icmp slt i64 %48, 0
	%50 = sub i64 0, %48
	%51 = select i1 %49, i64 %50, i64 %48
	%52 = bitcast i64 %51 to i64
	store i64 %52, i64* %3
	br label %switch.done-10

switch.case.next-8:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$129, i32 0, i32 0), i64 71}, i64 315, i64 4, %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$12a, i32 0, i32 0), i64 19}, i64 13027542680929226001}, %runtime.Source_Code_Location* %9
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([42 x i8], [42 x i8]* @str$12b, i32 0, i32 0), i64 41}, %runtime.Source_Code_Location* %9, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-10

switch.fall.body-9:
	; i
	%53 = load i64, i64* %3, align 8
	%54 = bitcast i64 %53 to i64
	store i64 %54, i64* %8
	; AssignStmt
	%55 = load i64, i64* %8, align 8
	%56 = icmp slt i64 %55, 0
	%57 = zext i1 %56 to i8
	store i8 %57, i8* %4
	; AssignStmt
	%58 = load i64, i64* %8, align 8
	; abs
	%59 = icmp slt i64 %58, 0
	%60 = sub i64 0, %58
	%61 = select i1 %59, i64 %60, i64 %58
	%62 = bitcast i64 %61 to i64
	store i64 %62, i64* %3
	br label %switch.done-10

switch.done-10:
	br label %if.done-11

if.done-11:
	; ReturnStmt
	%63 = load i64, i64* %3, align 8
	%64 = load i8, i8* %4, align 1
	%65 = getelementptr inbounds {i64, i8}, {i64, i8}* %10, i32 0, i32 0
	store i64 %63, i64* %65
	%66 = getelementptr inbounds {i64, i8}, {i64, i8}* %10, i32 0, i32 1
	store i8 %64, i8* %66
	%67 = load {i64, i8}, {i64, i8}* %10, align 8
	store {i64, i8} %67, {i64, i8}* %agg.result
	ret void
}

define void @strconv.append_bits(%..string* sret noalias %agg.result, {i8*, i64}* %_.0, i64 %_.1, i64 %_.2, i1 %_.3, i64 %_.4, %..string %_.5, i8 %_.6, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..string, align 16
	%5 = alloca i8, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca [129 x i8], align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i8, align 16
	%11 = alloca {i64, i8}, align 16
	%12 = alloca i64, align 16
	%13 = alloca i8, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca %..string, align 16
	store i64 %_.1, i64* %0
	store i64 %_.2, i64* %1
	%18 = zext i1 %_.3 to i8
	store i8 %18, i8* %2
	store i64 %_.4, i64* %3
	store %..string %_.5, %..string* %4
	store i8 %_.6, i8* %5
	; IfStmt
	%19 = load i64, i64* %1, align 8
	%20 = icmp slt i64 %19, 2
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%23 = load i64, i64* %1, align 8
	%24 = icmp sgt i64 %23, 32
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-2, label %if.done-3

if.then-2:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$12c, i32 0, i32 0), i64 71}, i64 323, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$12d, i32 0, i32 0), i64 11}, i64 13027609751138532700}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([44 x i8], [44 x i8]* @str$12e, i32 0, i32 0), i64 43}, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %if.done-3

if.done-3:
	; a
	%27 = bitcast [129 x i8]* %7 to %..rawptr
	; ZeroInit
	%28 = call %..rawptr @mem.zero(%..rawptr %27, i64 129)
	; i
	store i64 129, i64* %8
	; u
	; neg
	%29 = load i64, i64* %0, align 8
	%30 = load i8, i8* %2, align 1
	%31 = load i64, i64* %3, align 8
	%32 = trunc i8 %30 to i1
	; ZeroInit
	store {i64, i8} zeroinitializer, {i64, i8}* %11, align 1
	call void @strconv.is_integer_negative({i64, i8}* %11, i64 %29, i1 %32, i64 %31, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%33 = load {i64, i8}, {i64, i8}* %11, align 8
	%34 = extractvalue {i64, i8} %33, 0
	%35 = extractvalue {i64, i8} %33, 1
	store i64 %34, i64* %9
	store i8 %35, i8* %10
	; b
	%36 = load i64, i64* %1, align 8
	%37 = bitcast i64 %36 to i64
	store i64 %37, i64* %12
	; ForStmt
	br label %for.loop-4

for.loop-4:
	%38 = load i64, i64* %9, align 8
	%39 = load i64, i64* %12, align 8
	%40 = icmp uge i64 %38, %39
	%41 = zext i1 %40 to i8
	%42 = trunc i8 %41 to i1
	br i1 %42, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	%43 = load i64, i64* %8, align 8
	%44 = sub i64 %43, 1
	store i64 %44, i64* %8
	; AssignStmt
	; IndexExpr
	%45 = load i64, i64* %8, align 8
	%46 = trunc i64 %45 to i32
	%47 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %46
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$12f, i32 0, i32 0), i64 71}, i64 331, i64 11, i64 %45, i64 129)
	; IndexExpr
	%48 = load %..string, %..string* %4, align 8
	%49 = extractvalue %..string %48, 0
	%50 = extractvalue %..string %48, 1
	%51 = load i64, i64* %9, align 8
	%52 = load i64, i64* %12, align 8
	%53 = urem i64 %51, %52
	%54 = bitcast i64 %53 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$130, i32 0, i32 0), i64 71}, i64 331, i64 23, i64 %54, i64 %50)
	%55 = getelementptr inbounds i8, i8* %49, i64 %54
	%56 = load i8, i8* %55, align 1
	store i8 %56, i8* %47
	; AssignStmt
	%57 = load i64, i64* %12, align 8
	%58 = load i64, i64* %9, align 8
	%59 = udiv i64 %58, %57
	store i64 %59, i64* %9
	br label %for.loop-4

for.done-6:
	; AssignStmt
	%60 = load i64, i64* %8, align 8
	%61 = sub i64 %60, 1
	store i64 %61, i64* %8
	; AssignStmt
	; IndexExpr
	%62 = load i64, i64* %8, align 8
	%63 = trunc i64 %62 to i32
	%64 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %63
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$131, i32 0, i32 0), i64 71}, i64 334, i64 10, i64 %62, i64 129)
	; IndexExpr
	%65 = load %..string, %..string* %4, align 8
	%66 = extractvalue %..string %65, 0
	%67 = extractvalue %..string %65, 1
	%68 = load i64, i64* %9, align 8
	%69 = load i64, i64* %12, align 8
	%70 = urem i64 %68, %69
	%71 = bitcast i64 %70 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$132, i32 0, i32 0), i64 71}, i64 334, i64 22, i64 %71, i64 %67)
	%72 = getelementptr inbounds i8, i8* %66, i64 %71
	%73 = load i8, i8* %72, align 1
	store i8 %73, i8* %64
	; IfStmt
	%74 = load i8, i8* %5, align 1
	; bit_set in
	%75 = sub i64 0, 0
	%76 = shl i64 1, %75
	%77 = trunc i64 %76 to i8
	%78 = bitcast i8 %74 to i8
	%79 = and i8 %78, %77
	%80 = icmp ne i8 %79, 0
	%81 = zext i1 %80 to i8
	%82 = trunc i8 %81 to i1
	br i1 %82, label %if.then-7, label %if.done-21

if.then-7:
	; ok
	store i8 1, i8* %13
	; SwitchStmt
	%83 = load i64, i64* %1, align 8
	%84 = icmp eq i64 %83, 2
	br i1 %84, label %switch.case.body-9, label %switch.case.next-8

switch.case.next-8:
	%85 = icmp eq i64 %83, 8
	br i1 %85, label %switch.fall.body-11, label %switch.case.next-10

switch.case.body-9:
	; AssignStmt
	%86 = load i64, i64* %8, align 8
	%87 = sub i64 %86, 1
	store i64 %87, i64* %8
	; AssignStmt
	; IndexExpr
	%88 = load i64, i64* %8, align 8
	%89 = trunc i64 %88 to i32
	%90 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %89
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$133, i32 0, i32 0), i64 71}, i64 339, i64 20, i64 %88, i64 129)
	store i8 98, i8* %90
	br label %switch.done-18

switch.case.next-10:
	%91 = icmp eq i64 %83, 10
	br i1 %91, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	%92 = load i64, i64* %8, align 8
	%93 = sub i64 %92, 1
	store i64 %93, i64* %8
	; AssignStmt
	; IndexExpr
	%94 = load i64, i64* %8, align 8
	%95 = trunc i64 %94 to i32
	%96 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %95
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$134, i32 0, i32 0), i64 71}, i64 340, i64 20, i64 %94, i64 129)
	store i8 111, i8* %96
	br label %switch.done-18

switch.case.next-12:
	%97 = icmp eq i64 %83, 12
	br i1 %97, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	%98 = load i64, i64* %8, align 8
	%99 = sub i64 %98, 1
	store i64 %99, i64* %8
	; AssignStmt
	; IndexExpr
	%100 = load i64, i64* %8, align 8
	%101 = trunc i64 %100 to i32
	%102 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %101
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$135, i32 0, i32 0), i64 71}, i64 341, i64 20, i64 %100, i64 129)
	store i8 100, i8* %102
	br label %switch.done-18

switch.case.next-14:
	%103 = icmp eq i64 %83, 16
	br i1 %103, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	%104 = load i64, i64* %8, align 8
	%105 = sub i64 %104, 1
	store i64 %105, i64* %8
	; AssignStmt
	; IndexExpr
	%106 = load i64, i64* %8, align 8
	%107 = trunc i64 %106 to i32
	%108 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %107
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$136, i32 0, i32 0), i64 71}, i64 342, i64 20, i64 %106, i64 129)
	store i8 122, i8* %108
	br label %switch.done-18

switch.case.next-16:
	; AssignStmt
	store i8 0, i8* %13
	br label %switch.done-18

switch.fall.body-17:
	; AssignStmt
	%109 = load i64, i64* %8, align 8
	%110 = sub i64 %109, 1
	store i64 %110, i64* %8
	; AssignStmt
	; IndexExpr
	%111 = load i64, i64* %8, align 8
	%112 = trunc i64 %111 to i32
	%113 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %112
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$137, i32 0, i32 0), i64 71}, i64 343, i64 20, i64 %111, i64 129)
	store i8 120, i8* %113
	br label %switch.done-18

switch.done-18:
	; IfStmt
	%114 = load i8, i8* %13, align 1
	%115 = trunc i8 %114 to i1
	br i1 %115, label %if.then-19, label %if.done-20

if.then-19:
	; AssignStmt
	%116 = load i64, i64* %8, align 8
	%117 = sub i64 %116, 1
	store i64 %117, i64* %8
	; AssignStmt
	; IndexExpr
	%118 = load i64, i64* %8, align 8
	%119 = trunc i64 %118 to i32
	%120 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %119
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$138, i32 0, i32 0), i64 71}, i64 347, i64 12, i64 %118, i64 129)
	store i8 48, i8* %120
	br label %if.done-20

if.done-20:
	br label %if.done-21

if.done-21:
	; SwitchStmt
	%121 = load i8, i8* %10, align 1
	%122 = icmp eq i8 1, %121
	br i1 %122, label %switch.case.body-23, label %switch.case.next-22

switch.case.next-22:
	%123 = load i8, i8* %5, align 1
	; bit_set in
	%124 = sub i64 1, 0
	%125 = shl i64 1, %124
	%126 = trunc i64 %125 to i8
	%127 = bitcast i8 %123 to i8
	%128 = and i8 %127, %126
	%129 = icmp ne i8 %128, 0
	%130 = zext i1 %129 to i8
	%131 = icmp eq i8 1, %130
	br i1 %131, label %switch.fall.body-25, label %switch.case.next-24

switch.case.body-23:
	; AssignStmt
	%132 = load i64, i64* %8, align 8
	%133 = sub i64 %132, 1
	store i64 %133, i64* %8
	; AssignStmt
	; IndexExpr
	%134 = load i64, i64* %8, align 8
	%135 = trunc i64 %134 to i32
	%136 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %135
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$139, i32 0, i32 0), i64 71}, i64 353, i64 11, i64 %134, i64 129)
	store i8 45, i8* %136
	br label %switch.done-28

switch.case.next-24:
	%137 = load i8, i8* %5, align 1
	; bit_set in
	%138 = sub i64 2, 0
	%139 = shl i64 1, %138
	%140 = trunc i64 %139 to i8
	%141 = bitcast i8 %137 to i8
	%142 = and i8 %141, %140
	%143 = icmp ne i8 %142, 0
	%144 = zext i1 %143 to i8
	%145 = icmp eq i8 1, %144
	br i1 %145, label %switch.fall.body-27, label %switch.case.next-26

switch.fall.body-25:
	; AssignStmt
	%146 = load i64, i64* %8, align 8
	%147 = sub i64 %146, 1
	store i64 %147, i64* %8
	; AssignStmt
	; IndexExpr
	%148 = load i64, i64* %8, align 8
	%149 = trunc i64 %148 to i32
	%150 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %149
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$13a, i32 0, i32 0), i64 71}, i64 355, i64 11, i64 %148, i64 129)
	store i8 43, i8* %150
	br label %switch.done-28

switch.case.next-26:
	br label %switch.done-28

switch.fall.body-27:
	; AssignStmt
	%151 = load i64, i64* %8, align 8
	%152 = sub i64 %151, 1
	store i64 %152, i64* %8
	; AssignStmt
	; IndexExpr
	%153 = load i64, i64* %8, align 8
	%154 = trunc i64 %153 to i32
	%155 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 %154
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$13b, i32 0, i32 0), i64 71}, i64 357, i64 11, i64 %153, i64 129)
	store i8 32, i8* %155
	br label %switch.done-28

switch.done-28:
	; out
	; SliceExpr
	%156 = load i64, i64* %8, align 8
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$13c, i32 0, i32 0), i64 71}, i64 360, i64 10, i64 %156, i64 129, i64 129)
	%157 = getelementptr inbounds [129 x i8], [129 x i8]* %7, i32 0, i32 0
	%158 = getelementptr inbounds i8, i8* %157, i64 %156
	%159 = sub i64 129, %156
	%160 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i32 0, i32 0
	store i8* %158, i8** %160
	%161 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i32 0, i32 1
	store i64 %159, i64* %161
	%162 = load {i8*, i64}, {i8*, i64}* %15, align 8
	store {i8*, i64} %162, {i8*, i64}* %14
	%163 = call i64 @runtime.copy-7722({i8*, i64}* %_.0, {i8*, i64}* %14)
	; ReturnStmt
	; SliceExpr
	%164 = load {i8*, i64}, {i8*, i64}* %14, align 8
	%165 = extractvalue {i8*, i64} %164, 1
	%166 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%167 = extractvalue {i8*, i64} %166, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$13d, i32 0, i32 0), i64 71}, i64 362, i64 19, i64 0, i64 %165, i64 %167)
	%168 = extractvalue {i8*, i64} %166, 0
	%169 = getelementptr inbounds i8, i8* %168, i64 0
	%170 = sub i64 %165, 0
	%171 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i32 0, i32 0
	store i8* %169, i8** %171
	%172 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i32 0, i32 1
	store i64 %170, i64* %172
	%173 = load {i8*, i64}, {i8*, i64}* %16, align 8
	%174 = extractvalue {i8*, i64} %173, 0
	%175 = extractvalue {i8*, i64} %173, 1
	%176 = getelementptr inbounds %..string, %..string* %17, i32 0, i32 0
	store i8* %174, i8** %176
	%177 = getelementptr inbounds %..string, %..string* %17, i32 0, i32 1
	store i64 %175, i64* %177
	%178 = load %..string, %..string* %17, align 8
	store %..string %178, %..string* %agg.result
	ret void
}

define void @strconv.is_integer_negative_128({i128, i8}* sret noalias %agg.result, <2 x i64> %_.0, i1 %_.1, i64 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i128, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i128, align 16
	%4 = alloca i8, align 16
	%5 = alloca i8, align 16
	%6 = alloca i16, align 16
	%7 = alloca i32, align 16
	%8 = alloca i64, align 16
	%9 = alloca i128, align 16
	%10 = alloca %runtime.Source_Code_Location, align 16
	%11 = alloca {i128, i8}, align 16
	%12 = bitcast <2 x i64> %_.0 to i128
	store i128 %12, i128* %0
	%13 = zext i1 %_.1 to i8
	store i8 %13, i8* %1
	store i64 %_.2, i64* %2
	; ZeroInit
	store i128 zeroinitializer, i128* %3, align 1
	; ZeroInit
	store i8 zeroinitializer, i8* %4, align 1
	; AssignStmt
	%14 = load i128, i128* %0, align 8
	store i128 %14, i128* %3
	; IfStmt
	%15 = load i8, i8* %1, align 1
	%16 = trunc i8 %15 to i1
	br i1 %16, label %if.then-1, label %if.done-13

if.then-1:
	; SwitchStmt
	%17 = load i64, i64* %2, align 8
	%18 = icmp eq i64 %17, 8
	br i1 %18, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%19 = icmp eq i64 %17, 16
	br i1 %19, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; i
	%20 = load i128, i128* %3, align 8
	%21 = trunc i128 %20 to i8
	store i8 %21, i8* %5
	; AssignStmt
	%22 = load i8, i8* %5, align 1
	%23 = icmp slt i8 %22, 0
	%24 = zext i1 %23 to i8
	store i8 %24, i8* %4
	; AssignStmt
	%25 = load i8, i8* %5, align 1
	%26 = sext i8 %25 to i128
	; abs
	%27 = icmp slt i128 %26, 0
	%28 = sub i128 0, %26
	%29 = select i1 %27, i128 %28, i128 %26
	%30 = bitcast i128 %29 to i128
	store i128 %30, i128* %3
	br label %switch.done-12

switch.case.next-4:
	%31 = icmp eq i64 %17, 32
	br i1 %31, label %switch.fall.body-7, label %switch.case.next-6

switch.fall.body-5:
	; i
	%32 = load i128, i128* %3, align 8
	%33 = trunc i128 %32 to i16
	store i16 %33, i16* %6
	; AssignStmt
	%34 = load i16, i16* %6, align 2
	%35 = icmp slt i16 %34, 0
	%36 = zext i1 %35 to i8
	store i8 %36, i8* %4
	; AssignStmt
	%37 = load i16, i16* %6, align 2
	%38 = sext i16 %37 to i128
	; abs
	%39 = icmp slt i128 %38, 0
	%40 = sub i128 0, %38
	%41 = select i1 %39, i128 %40, i128 %38
	%42 = bitcast i128 %41 to i128
	store i128 %42, i128* %3
	br label %switch.done-12

switch.case.next-6:
	%43 = icmp eq i64 %17, 64
	br i1 %43, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-7:
	; i
	%44 = load i128, i128* %3, align 8
	%45 = trunc i128 %44 to i32
	store i32 %45, i32* %7
	; AssignStmt
	%46 = load i32, i32* %7, align 4
	%47 = icmp slt i32 %46, 0
	%48 = zext i1 %47 to i8
	store i8 %48, i8* %4
	; AssignStmt
	%49 = load i32, i32* %7, align 4
	%50 = sext i32 %49 to i128
	; abs
	%51 = icmp slt i128 %50, 0
	%52 = sub i128 0, %50
	%53 = select i1 %51, i128 %52, i128 %50
	%54 = bitcast i128 %53 to i128
	store i128 %54, i128* %3
	br label %switch.done-12

switch.case.next-8:
	%55 = icmp eq i64 %17, 128
	br i1 %55, label %switch.fall.body-11, label %switch.case.next-10

switch.fall.body-9:
	; i
	%56 = load i128, i128* %3, align 8
	%57 = trunc i128 %56 to i64
	store i64 %57, i64* %8
	; AssignStmt
	%58 = load i64, i64* %8, align 8
	%59 = icmp slt i64 %58, 0
	%60 = zext i1 %59 to i8
	store i8 %60, i8* %4
	; AssignStmt
	%61 = load i64, i64* %8, align 8
	%62 = sext i64 %61 to i128
	; abs
	%63 = icmp slt i128 %62, 0
	%64 = sub i128 0, %62
	%65 = select i1 %63, i128 %64, i128 %62
	%66 = bitcast i128 %65 to i128
	store i128 %66, i128* %3
	br label %switch.done-12

switch.case.next-10:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$13e, i32 0, i32 0), i64 71}, i64 390, i64 4, %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$13f, i32 0, i32 0), i64 23}, i64 13027677920859409634}, %runtime.Source_Code_Location* %10
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([42 x i8], [42 x i8]* @str$140, i32 0, i32 0), i64 41}, %runtime.Source_Code_Location* %10, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %switch.done-12

switch.fall.body-11:
	; i
	%67 = load i128, i128* %3, align 8
	%68 = bitcast i128 %67 to i128
	store i128 %68, i128* %9
	; AssignStmt
	%69 = load i128, i128* %9, align 8
	%70 = icmp slt i128 %69, 0
	%71 = zext i1 %70 to i8
	store i8 %71, i8* %4
	; AssignStmt
	%72 = load i128, i128* %9, align 8
	; abs
	%73 = icmp slt i128 %72, 0
	%74 = sub i128 0, %72
	%75 = select i1 %73, i128 %74, i128 %72
	%76 = bitcast i128 %75 to i128
	store i128 %76, i128* %3
	br label %switch.done-12

switch.done-12:
	br label %if.done-13

if.done-13:
	; ReturnStmt
	%77 = load i128, i128* %3, align 8
	%78 = load i8, i8* %4, align 1
	%79 = getelementptr inbounds {i128, i8}, {i128, i8}* %11, i32 0, i32 0
	store i128 %77, i128* %79
	%80 = getelementptr inbounds {i128, i8}, {i128, i8}* %11, i32 0, i32 1
	store i8 %78, i8* %80
	%81 = load {i128, i8}, {i128, i8}* %11, align 8
	store {i128, i8} %81, {i128, i8}* %agg.result
	ret void
}

define void @strconv.append_bits_128(%..string* sret noalias %agg.result, {i8*, i64}* %_.0, <2 x i64> %_.1, i64 %_.2, i1 %_.3, i64 %_.4, %..string %_.5, i8 %_.6, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i128, align 16
	%1 = alloca i64, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..string, align 16
	%5 = alloca i8, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca [140 x i8], align 16
	%8 = alloca i64, align 16
	%9 = alloca i128, align 16
	%10 = alloca i8, align 16
	%11 = alloca {i128, i8}, align 16
	%12 = alloca i128, align 16
	%13 = alloca i8, align 16
	%14 = alloca {i8*, i64}, align 16
	%15 = alloca {i8*, i64}, align 16
	%16 = alloca {i8*, i64}, align 16
	%17 = alloca %..string, align 16
	%18 = bitcast <2 x i64> %_.1 to i128
	store i128 %18, i128* %0
	store i64 %_.2, i64* %1
	%19 = zext i1 %_.3 to i8
	store i8 %19, i8* %2
	store i64 %_.4, i64* %3
	store %..string %_.5, %..string* %4
	store i8 %_.6, i8* %5
	; IfStmt
	%20 = load i64, i64* %1, align 8
	%21 = icmp slt i64 %20, 2
	%22 = zext i1 %21 to i8
	%23 = trunc i8 %22 to i1
	br i1 %23, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%24 = load i64, i64* %1, align 8
	%25 = icmp sgt i64 %24, 32
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-2, label %if.done-3

if.then-2:
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$141, i32 0, i32 0), i64 71}, i64 399, i64 3, %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$142, i32 0, i32 0), i64 15}, i64 13027666925743144056}, %runtime.Source_Code_Location* %6
	call void @runtime.panic(%..string {i8* getelementptr inbounds ([44 x i8], [44 x i8]* @str$143, i32 0, i32 0), i64 43}, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr) noreturn
	br label %if.done-3

if.done-3:
	; a
	%28 = bitcast [140 x i8]* %7 to %..rawptr
	; ZeroInit
	%29 = call %..rawptr @mem.zero(%..rawptr %28, i64 140)
	; i
	store i64 140, i64* %8
	; u
	; neg
	%30 = load i128, i128* %0, align 8
	%31 = load i8, i8* %2, align 1
	%32 = load i64, i64* %3, align 8
	%33 = bitcast i128 %30 to <2 x i64>
	%34 = trunc i8 %31 to i1
	%35 = bitcast {i128, i8}* %11 to %..rawptr
	; ZeroInit
	%36 = call %..rawptr @mem.zero(%..rawptr %35, i64 24)
	call void @strconv.is_integer_negative_128({i128, i8}* %11, <2 x i64> %33, i1 %34, i64 %32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%37 = load {i128, i8}, {i128, i8}* %11, align 8
	%38 = extractvalue {i128, i8} %37, 0
	%39 = extractvalue {i128, i8} %37, 1
	store i128 %38, i128* %9
	store i8 %39, i8* %10
	; b
	%40 = load i64, i64* %1, align 8
	%41 = sext i64 %40 to i128
	store i128 %41, i128* %12
	; ForStmt
	br label %for.loop-4

for.loop-4:
	%42 = load i128, i128* %9, align 8
	%43 = load i128, i128* %12, align 8
	%44 = icmp uge i128 %42, %43
	%45 = zext i1 %44 to i8
	%46 = trunc i8 %45 to i1
	br i1 %46, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	%47 = load i64, i64* %8, align 8
	%48 = sub i64 %47, 1
	store i64 %48, i64* %8
	; AssignStmt
	; IndexExpr
	%49 = load i64, i64* %8, align 8
	%50 = trunc i64 %49 to i32
	%51 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %50
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$144, i32 0, i32 0), i64 71}, i64 407, i64 11, i64 %49, i64 140)
	; IndexExpr
	%52 = load %..string, %..string* %4, align 8
	%53 = extractvalue %..string %52, 0
	%54 = extractvalue %..string %52, 1
	%55 = load i128, i128* %9, align 8
	%56 = load i128, i128* %12, align 8
	%57 = urem i128 %55, %56
	%58 = trunc i128 %57 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$145, i32 0, i32 0), i64 71}, i64 407, i64 23, i64 %58, i64 %54)
	%59 = getelementptr inbounds i8, i8* %53, i64 %58
	%60 = load i8, i8* %59, align 1
	store i8 %60, i8* %51
	; AssignStmt
	%61 = load i128, i128* %12, align 8
	%62 = load i128, i128* %9, align 8
	%63 = udiv i128 %62, %61
	store i128 %63, i128* %9
	br label %for.loop-4

for.done-6:
	; AssignStmt
	%64 = load i64, i64* %8, align 8
	%65 = sub i64 %64, 1
	store i64 %65, i64* %8
	; AssignStmt
	; IndexExpr
	%66 = load i64, i64* %8, align 8
	%67 = trunc i64 %66 to i32
	%68 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %67
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$146, i32 0, i32 0), i64 71}, i64 410, i64 10, i64 %66, i64 140)
	; IndexExpr
	%69 = load %..string, %..string* %4, align 8
	%70 = extractvalue %..string %69, 0
	%71 = extractvalue %..string %69, 1
	%72 = load i128, i128* %9, align 8
	%73 = load i128, i128* %12, align 8
	%74 = urem i128 %72, %73
	%75 = trunc i128 %74 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$147, i32 0, i32 0), i64 71}, i64 410, i64 22, i64 %75, i64 %71)
	%76 = getelementptr inbounds i8, i8* %70, i64 %75
	%77 = load i8, i8* %76, align 1
	store i8 %77, i8* %68
	; IfStmt
	%78 = load i8, i8* %5, align 1
	; bit_set in
	%79 = sub i64 0, 0
	%80 = shl i64 1, %79
	%81 = trunc i64 %80 to i8
	%82 = bitcast i8 %78 to i8
	%83 = and i8 %82, %81
	%84 = icmp ne i8 %83, 0
	%85 = zext i1 %84 to i8
	%86 = trunc i8 %85 to i1
	br i1 %86, label %if.then-7, label %if.done-21

if.then-7:
	; ok
	store i8 1, i8* %13
	; SwitchStmt
	%87 = load i64, i64* %1, align 8
	%88 = icmp eq i64 %87, 2
	br i1 %88, label %switch.case.body-9, label %switch.case.next-8

switch.case.next-8:
	%89 = icmp eq i64 %87, 8
	br i1 %89, label %switch.fall.body-11, label %switch.case.next-10

switch.case.body-9:
	; AssignStmt
	%90 = load i64, i64* %8, align 8
	%91 = sub i64 %90, 1
	store i64 %91, i64* %8
	; AssignStmt
	; IndexExpr
	%92 = load i64, i64* %8, align 8
	%93 = trunc i64 %92 to i32
	%94 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %93
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$148, i32 0, i32 0), i64 71}, i64 415, i64 20, i64 %92, i64 140)
	store i8 98, i8* %94
	br label %switch.done-18

switch.case.next-10:
	%95 = icmp eq i64 %87, 10
	br i1 %95, label %switch.fall.body-13, label %switch.case.next-12

switch.fall.body-11:
	; AssignStmt
	%96 = load i64, i64* %8, align 8
	%97 = sub i64 %96, 1
	store i64 %97, i64* %8
	; AssignStmt
	; IndexExpr
	%98 = load i64, i64* %8, align 8
	%99 = trunc i64 %98 to i32
	%100 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %99
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$149, i32 0, i32 0), i64 71}, i64 416, i64 20, i64 %98, i64 140)
	store i8 111, i8* %100
	br label %switch.done-18

switch.case.next-12:
	%101 = icmp eq i64 %87, 12
	br i1 %101, label %switch.fall.body-15, label %switch.case.next-14

switch.fall.body-13:
	; AssignStmt
	%102 = load i64, i64* %8, align 8
	%103 = sub i64 %102, 1
	store i64 %103, i64* %8
	; AssignStmt
	; IndexExpr
	%104 = load i64, i64* %8, align 8
	%105 = trunc i64 %104 to i32
	%106 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %105
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$14a, i32 0, i32 0), i64 71}, i64 417, i64 20, i64 %104, i64 140)
	store i8 100, i8* %106
	br label %switch.done-18

switch.case.next-14:
	%107 = icmp eq i64 %87, 16
	br i1 %107, label %switch.fall.body-17, label %switch.case.next-16

switch.fall.body-15:
	; AssignStmt
	%108 = load i64, i64* %8, align 8
	%109 = sub i64 %108, 1
	store i64 %109, i64* %8
	; AssignStmt
	; IndexExpr
	%110 = load i64, i64* %8, align 8
	%111 = trunc i64 %110 to i32
	%112 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %111
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$14b, i32 0, i32 0), i64 71}, i64 418, i64 20, i64 %110, i64 140)
	store i8 122, i8* %112
	br label %switch.done-18

switch.case.next-16:
	; AssignStmt
	store i8 0, i8* %13
	br label %switch.done-18

switch.fall.body-17:
	; AssignStmt
	%113 = load i64, i64* %8, align 8
	%114 = sub i64 %113, 1
	store i64 %114, i64* %8
	; AssignStmt
	; IndexExpr
	%115 = load i64, i64* %8, align 8
	%116 = trunc i64 %115 to i32
	%117 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %116
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$14c, i32 0, i32 0), i64 71}, i64 419, i64 20, i64 %115, i64 140)
	store i8 120, i8* %117
	br label %switch.done-18

switch.done-18:
	; IfStmt
	%118 = load i8, i8* %13, align 1
	%119 = trunc i8 %118 to i1
	br i1 %119, label %if.then-19, label %if.done-20

if.then-19:
	; AssignStmt
	%120 = load i64, i64* %8, align 8
	%121 = sub i64 %120, 1
	store i64 %121, i64* %8
	; AssignStmt
	; IndexExpr
	%122 = load i64, i64* %8, align 8
	%123 = trunc i64 %122 to i32
	%124 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %123
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$14d, i32 0, i32 0), i64 71}, i64 423, i64 12, i64 %122, i64 140)
	store i8 48, i8* %124
	br label %if.done-20

if.done-20:
	br label %if.done-21

if.done-21:
	; SwitchStmt
	%125 = load i8, i8* %10, align 1
	%126 = icmp eq i8 1, %125
	br i1 %126, label %switch.case.body-23, label %switch.case.next-22

switch.case.next-22:
	%127 = load i8, i8* %5, align 1
	; bit_set in
	%128 = sub i64 1, 0
	%129 = shl i64 1, %128
	%130 = trunc i64 %129 to i8
	%131 = bitcast i8 %127 to i8
	%132 = and i8 %131, %130
	%133 = icmp ne i8 %132, 0
	%134 = zext i1 %133 to i8
	%135 = icmp eq i8 1, %134
	br i1 %135, label %switch.fall.body-25, label %switch.case.next-24

switch.case.body-23:
	; AssignStmt
	%136 = load i64, i64* %8, align 8
	%137 = sub i64 %136, 1
	store i64 %137, i64* %8
	; AssignStmt
	; IndexExpr
	%138 = load i64, i64* %8, align 8
	%139 = trunc i64 %138 to i32
	%140 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %139
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$14e, i32 0, i32 0), i64 71}, i64 429, i64 11, i64 %138, i64 140)
	store i8 45, i8* %140
	br label %switch.done-28

switch.case.next-24:
	%141 = load i8, i8* %5, align 1
	; bit_set in
	%142 = sub i64 2, 0
	%143 = shl i64 1, %142
	%144 = trunc i64 %143 to i8
	%145 = bitcast i8 %141 to i8
	%146 = and i8 %145, %144
	%147 = icmp ne i8 %146, 0
	%148 = zext i1 %147 to i8
	%149 = icmp eq i8 1, %148
	br i1 %149, label %switch.fall.body-27, label %switch.case.next-26

switch.fall.body-25:
	; AssignStmt
	%150 = load i64, i64* %8, align 8
	%151 = sub i64 %150, 1
	store i64 %151, i64* %8
	; AssignStmt
	; IndexExpr
	%152 = load i64, i64* %8, align 8
	%153 = trunc i64 %152 to i32
	%154 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %153
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$14f, i32 0, i32 0), i64 71}, i64 431, i64 11, i64 %152, i64 140)
	store i8 43, i8* %154
	br label %switch.done-28

switch.case.next-26:
	br label %switch.done-28

switch.fall.body-27:
	; AssignStmt
	%155 = load i64, i64* %8, align 8
	%156 = sub i64 %155, 1
	store i64 %156, i64* %8
	; AssignStmt
	; IndexExpr
	%157 = load i64, i64* %8, align 8
	%158 = trunc i64 %157 to i32
	%159 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 %158
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$150, i32 0, i32 0), i64 71}, i64 433, i64 11, i64 %157, i64 140)
	store i8 32, i8* %159
	br label %switch.done-28

switch.done-28:
	; out
	; SliceExpr
	%160 = load i64, i64* %8, align 8
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$151, i32 0, i32 0), i64 71}, i64 436, i64 10, i64 %160, i64 140, i64 140)
	%161 = getelementptr inbounds [140 x i8], [140 x i8]* %7, i32 0, i32 0
	%162 = getelementptr inbounds i8, i8* %161, i64 %160
	%163 = sub i64 140, %160
	%164 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i32 0, i32 0
	store i8* %162, i8** %164
	%165 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %15, i32 0, i32 1
	store i64 %163, i64* %165
	%166 = load {i8*, i64}, {i8*, i64}* %15, align 8
	store {i8*, i64} %166, {i8*, i64}* %14
	%167 = call i64 @runtime.copy-7722({i8*, i64}* %_.0, {i8*, i64}* %14)
	; ReturnStmt
	; SliceExpr
	%168 = load {i8*, i64}, {i8*, i64}* %14, align 8
	%169 = extractvalue {i8*, i64} %168, 1
	%170 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%171 = extractvalue {i8*, i64} %170, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([72 x i8], [72 x i8]* @str$152, i32 0, i32 0), i64 71}, i64 438, i64 19, i64 0, i64 %169, i64 %171)
	%172 = extractvalue {i8*, i64} %170, 0
	%173 = getelementptr inbounds i8, i8* %172, i64 0
	%174 = sub i64 %169, 0
	%175 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i32 0, i32 0
	store i8* %173, i8** %175
	%176 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %16, i32 0, i32 1
	store i64 %174, i64* %176
	%177 = load {i8*, i64}, {i8*, i64}* %16, align 8
	%178 = extractvalue {i8*, i64} %177, 0
	%179 = extractvalue {i8*, i64} %177, 1
	%180 = getelementptr inbounds %..string, %..string* %17, i32 0, i32 0
	store i8* %178, i8** %180
	%181 = getelementptr inbounds %..string, %..string* %17, i32 0, i32 1
	store i64 %179, i64* %181
	%182 = load %..string, %..string* %17, align 8
	store %..string %182, %..string* %agg.result
	ret void
}

define void @strings.builder_from_slice(%strings.Builder* sret noalias %agg.result, {i8*, i64}* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %mem.Raw_Slice, align 16
	%1 = alloca %mem.Raw_Dynamic_Array, align 16
	%2 = alloca %mem.Raw_Dynamic_Array, align 16
	%3 = alloca %mem.Allocator, align 16
	; s
	%4 = bitcast {i8*, i64}* %_.0 to %mem.Raw_Slice*
	%5 = load %mem.Raw_Slice, %mem.Raw_Slice* %4, align 8
	store %mem.Raw_Slice %5, %mem.Raw_Slice* %0
	; d
	; CompoundLit
	%6 = bitcast %mem.Raw_Dynamic_Array* %2 to %..rawptr
	; ZeroInit
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 40)
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 0, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %2
	; SelectorExpr
	%8 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %0, i32 0, i32 0
	%9 = load %..rawptr, %..rawptr* %8, align 8
	%10 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i32 0, i32 0
	store %..rawptr %9, %..rawptr* %10
	; SelectorExpr
	%11 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %0, i32 0, i32 1
	%12 = load i64, i64* %11, align 8
	%13 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i32 0, i32 2
	store i64 %12, i64* %13
	; SelectorExpr
	; ZeroInit
	store %mem.Allocator zeroinitializer, %mem.Allocator* %3, align 1
	call void @mem.nil_allocator(%mem.Allocator* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%14 = load %mem.Allocator, %mem.Allocator* %3, align 8
	%15 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, i32 0, i32 3
	store %mem.Allocator %14, %mem.Allocator* %15
	%16 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %2, align 8
	store %mem.Raw_Dynamic_Array %16, %mem.Raw_Dynamic_Array* %1
	; ReturnStmt
	%17 = bitcast %mem.Raw_Dynamic_Array* %1 to %strings.Builder*
	%18 = load %strings.Builder, %strings.Builder* %17, align 8
	store %strings.Builder %18, %strings.Builder* %agg.result
	ret void
}

define void @strings.to_string(%..string* sret noalias %agg.result, %strings.Builder* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64}, align 16
	%1 = alloca %..string, align 16
	; ReturnStmt
	; SliceExpr
	; SelectorExpr
	%2 = getelementptr inbounds %strings.Builder, %strings.Builder* %_.0, i32 0, i32 0
	%3 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %2, align 8
	%4 = extractvalue {i8*, i64, i64, %mem.Allocator} %3, 1
	%5 = extractvalue {i8*, i64, i64, %mem.Allocator} %3, 0
	%6 = getelementptr inbounds i8, i8* %5, i64 0
	%7 = sub i64 %4, 0
	%8 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i32 0, i32 0
	store i8* %6, i8** %8
	%9 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %0, i32 0, i32 1
	store i64 %7, i64* %9
	%10 = load {i8*, i64}, {i8*, i64}* %0, align 8
	%11 = extractvalue {i8*, i64} %10, 0
	%12 = extractvalue {i8*, i64} %10, 1
	%13 = getelementptr inbounds %..string, %..string* %1, i32 0, i32 0
	store i8* %11, i8** %13
	%14 = getelementptr inbounds %..string, %..string* %1, i32 0, i32 1
	store i64 %12, i64* %14
	%15 = load %..string, %..string* %1, align 8
	store %..string %15, %..string* %agg.result
	ret void
}

define void @strings.write_byte(%strings.Builder* %_.0, i8 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Source_Code_Location, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store i8 %_.1, i8* %1
	; SelectorExpr
	%3 = load %strings.Builder*, %strings.Builder** %0, align 8
	%4 = getelementptr inbounds %strings.Builder, %strings.Builder* %3, i32 0, i32 0
	%5 = load i8, i8* %1, align 1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$153, i32 0, i32 0), i64 65}, i64 50, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$154, i32 0, i32 0), i64 10}, i64 3004020323194892896}, %runtime.Source_Code_Location* %2
	call void @runtime.append_elem-8299({i8*, i64, i64, %mem.Allocator}* %4, i8 %5, %runtime.Source_Code_Location* %2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define i64 @strings.write_rune(%strings.Builder* %_.0, i32 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca i32, align 16
	%2 = alloca [4 x i8], align 16
	%3 = alloca i64, align 16
	%4 = alloca {[4 x i8], i64}, align 16
	%5 = alloca {i8*, i64}, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store i32 %_.1, i32* %1
	; IfStmt
	%6 = load i32, i32* %1, align 4
	%7 = icmp slt i32 %6, 128
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	%10 = load %strings.Builder*, %strings.Builder** %0, align 8
	%11 = load i32, i32* %1, align 4
	%12 = trunc i32 %11 to i8
	call void @strings.write_byte(%strings.Builder* %10, i8 %12, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret i64 1

if.done-2:
	; s
	; n
	; SelectorExpr
	%13 = load i32, i32* %1, align 4
	; ZeroInit
	store {[4 x i8], i64} zeroinitializer, {[4 x i8], i64}* %4, align 1
	call void @utf8.encode_rune({[4 x i8], i64}* %4, i32 %13, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%14 = load {[4 x i8], i64}, {[4 x i8], i64}* %4, align 8
	%15 = extractvalue {[4 x i8], i64} %14, 0
	%16 = extractvalue {[4 x i8], i64} %14, 1
	store [4 x i8] %15, [4 x i8]* %2
	store i64 %16, i64* %3
	%17 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SliceExpr
	%18 = load i64, i64* %3, align 8
	call void @runtime.slice_expr_error_hi(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$155, i32 0, i32 0), i64 65}, i64 60, i64 18, i64 %18, i64 4)
	%19 = getelementptr inbounds [4 x i8], [4 x i8]* %2, i32 0, i32 0
	%20 = getelementptr inbounds i8, i8* %19, i64 0
	%21 = sub i64 %18, 0
	%22 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 0
	store i8* %20, i8** %22
	%23 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 1
	store i64 %21, i64* %23
	call void @strings.write_bytes(%strings.Builder* %17, {i8*, i64}* %5, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	%24 = load i64, i64* %3, align 8
	ret i64 %24
}

define void @strings.write_string(%strings.Builder* %_.0, %..string %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i8*, align 16
	%3 = alloca {i8*, i64}, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store %..string %_.1, %..string* %1
	%4 = load %strings.Builder*, %strings.Builder** %0, align 8
	%5 = load %..string, %..string* %1, align 8
	%6 = extractvalue %..string %5, 0
	store i8* %6, i8** %2
	%7 = extractvalue %..string %5, 1
	%8 = sub i64 %7, 0
	%9 = load i8*, i8** %2, align 8
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i32 0, i32 0
	store i8* %10, i8** %11
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %3, i32 0, i32 1
	store i64 %8, i64* %12
	call void @strings.write_bytes(%strings.Builder* %4, {i8*, i64}* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @strings.write_bytes(%strings.Builder* %_.0, {i8*, i64}* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca %runtime.Source_Code_Location, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	; SelectorExpr
	%2 = load %strings.Builder*, %strings.Builder** %0, align 8
	%3 = getelementptr inbounds %strings.Builder, %strings.Builder* %2, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$156, i32 0, i32 0), i64 65}, i64 69, i64 2, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$157, i32 0, i32 0), i64 11}, i64 3003931262753035177}, %runtime.Source_Code_Location* %1
	call void @runtime.append_elems-8310({i8*, i64, i64, %mem.Allocator}* %3, {i8*, i64}* %_.1, %runtime.Source_Code_Location* %1, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @strings.write_quoted_string(%strings.Builder* %_.0, %..string %_.1, i8 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca %..string, align 16
	%2 = alloca i8, align 16
	%3 = alloca i64, align 16
	%4 = alloca %..string, align 16
	%5 = alloca i32, align 16
	%6 = alloca {i32, i64}, align 16
	%7 = alloca %..string, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store %..string %_.1, %..string* %1
	store i8 %_.2, i8* %2
	%8 = load %strings.Builder*, %strings.Builder** %0, align 8
	%9 = load i8, i8* %2, align 1
	call void @strings.write_byte(%strings.Builder* %8, i8 %9, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ForStmt
	; width
	; s
	%10 = load %..string, %..string* %1, align 8
	store i64 0, i64* %3
	store %..string %10, %..string* %4
	br label %for.loop-1

for.loop-1:
	%11 = load %..string, %..string* %4, align 8
	%12 = extractvalue %..string %11, 1
	%13 = icmp sgt i64 %12, 0
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %for.body-2, label %for.done-9

for.body-2:
	; r
	; IndexExpr
	%16 = load %..string, %..string* %4, align 8
	%17 = extractvalue %..string %16, 0
	%18 = extractvalue %..string %16, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$158, i32 0, i32 0), i64 65}, i64 78, i64 15, i64 0, i64 %18)
	%19 = getelementptr inbounds i8, i8* %17, i64 0
	%20 = load i8, i8* %19, align 1
	%21 = zext i8 %20 to i32
	store i32 %21, i32* %5
	; AssignStmt
	store i64 1, i64* %3
	; IfStmt
	%22 = load i32, i32* %5, align 4
	%23 = icmp sge i32 %22, 128
	%24 = zext i1 %23 to i8
	%25 = trunc i8 %24 to i1
	br i1 %25, label %if.then-3, label %if.done-4

if.then-3:
	; AssignStmt
	; SelectorExpr
	%26 = load %..string, %..string* %4, align 8
	; ZeroInit
	store {i32, i64} zeroinitializer, {i32, i64}* %6, align 1
	call void @utf8.decode_rune_in_string({i32, i64}* %6, %..string %26, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%27 = load {i32, i64}, {i32, i64}* %6, align 8
	%28 = extractvalue {i32, i64} %27, 0
	%29 = extractvalue {i32, i64} %27, 1
	store i32 %28, i32* %5
	store i64 %29, i64* %3
	br label %if.done-4

if.done-4:
	; IfStmt
	%30 = load i64, i64* %3, align 8
	%31 = icmp eq i64 %30, 1
	%32 = zext i1 %31 to i8
	%33 = trunc i8 %32 to i1
	br i1 %33, label %cmp.and-5, label %if.done-7

cmp.and-5:
	%34 = load i32, i32* %5, align 4
	%35 = icmp eq i32 %34, 65533
	%36 = zext i1 %35 to i8
	%37 = trunc i8 %36 to i1
	br i1 %37, label %if.then-6, label %if.done-7

if.then-6:
	%38 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %38, i8 92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%39 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %39, i8 120, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%40 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%41 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%42 = extractvalue %..string %41, 0
	%43 = extractvalue %..string %41, 1
	; IndexExpr
	%44 = load %..string, %..string* %4, align 8
	%45 = extractvalue %..string %44, 0
	%46 = extractvalue %..string %44, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$159, i32 0, i32 0), i64 65}, i64 86, i64 33, i64 0, i64 %46)
	%47 = getelementptr inbounds i8, i8* %45, i64 0
	%48 = load i8, i8* %47, align 1
	%49 = lshr i8 %48, 4
	%50 = zext i8 %49 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$15a, i32 0, i32 0), i64 65}, i64 86, i64 32, i64 %50, i64 %43)
	%51 = getelementptr inbounds i8, i8* %42, i64 %50
	%52 = load i8, i8* %51, align 1
	call void @strings.write_byte(%strings.Builder* %40, i8 %52, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%53 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%54 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%55 = extractvalue %..string %54, 0
	%56 = extractvalue %..string %54, 1
	; IndexExpr
	%57 = load %..string, %..string* %4, align 8
	%58 = extractvalue %..string %57, 0
	%59 = extractvalue %..string %57, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$15b, i32 0, i32 0), i64 65}, i64 87, i64 33, i64 0, i64 %59)
	%60 = getelementptr inbounds i8, i8* %58, i64 0
	%61 = load i8, i8* %60, align 1
	%62 = and i8 %61, 15
	%63 = zext i8 %62 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$15c, i32 0, i32 0), i64 65}, i64 87, i64 32, i64 %63, i64 %56)
	%64 = getelementptr inbounds i8, i8* %55, i64 %63
	%65 = load i8, i8* %64, align 1
	call void @strings.write_byte(%strings.Builder* %53, i8 %65, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; continue
	br label %for.post-8

if.done-7:
	%66 = load %strings.Builder*, %strings.Builder** %0, align 8
	%67 = load i32, i32* %5, align 4
	%68 = load i8, i8* %2, align 1
	call void @strings.write_escaped_rune(%strings.Builder* %66, i32 %67, i8 %68, i1 false, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.post-8

for.post-8:
	; AssignStmt
	; SliceExpr
	%69 = load i64, i64* %3, align 8
	%70 = load %..string, %..string* %4, align 8
	%71 = extractvalue %..string %70, 1
	call void @runtime.slice_expr_error_lo_hi(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$15d, i32 0, i32 0), i64 65}, i64 77, i64 43, i64 %69, i64 %71, i64 %71)
	%72 = extractvalue %..string %70, 0
	%73 = getelementptr inbounds i8, i8* %72, i64 %69
	%74 = sub i64 %71, %69
	%75 = getelementptr inbounds %..string, %..string* %7, i32 0, i32 0
	store i8* %73, i8** %75
	%76 = getelementptr inbounds %..string, %..string* %7, i32 0, i32 1
	store i64 %74, i64* %76
	%77 = load %..string, %..string* %7, align 8
	store %..string %77, %..string* %4
	br label %for.loop-1

for.done-9:
	%78 = load %strings.Builder*, %strings.Builder** %0, align 8
	%79 = load i8, i8* %2, align 1
	call void @strings.write_byte(%strings.Builder* %78, i8 %79, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @strings.write_encoded_rune(%strings.Builder* %_.0, i32 %_.1, i1 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i8, align 16
	%3 = alloca [2 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca %..string, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store i32 %_.1, i32* %1
	%7 = zext i1 %_.2 to i8
	store i8 %7, i8* %2
	; IfStmt
	%8 = load i8, i8* %2, align 1
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	%10 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %10, i8 39, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-2

if.done-2:
	; SwitchStmt
	%11 = load i32, i32* %1, align 4
	%12 = icmp eq i32 %11, 7
	br i1 %12, label %switch.case.body-4, label %switch.case.next-3

switch.case.next-3:
	%13 = icmp eq i32 %11, 8
	br i1 %13, label %switch.fall.body-6, label %switch.case.next-5

switch.case.body-4:
	%14 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %14, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$15e, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-5:
	%15 = icmp eq i32 %11, 27
	br i1 %15, label %switch.fall.body-8, label %switch.case.next-7

switch.fall.body-6:
	%16 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %16, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$15f, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-7:
	%17 = icmp eq i32 %11, 12
	br i1 %17, label %switch.fall.body-10, label %switch.case.next-9

switch.fall.body-8:
	%18 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %18, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$160, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-9:
	%19 = icmp eq i32 %11, 10
	br i1 %19, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%20 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %20, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$161, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-11:
	%21 = icmp eq i32 %11, 13
	br i1 %21, label %switch.fall.body-14, label %switch.case.next-13

switch.fall.body-12:
	%22 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %22, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$162, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-13:
	%23 = icmp eq i32 %11, 9
	br i1 %23, label %switch.fall.body-16, label %switch.case.next-15

switch.fall.body-14:
	%24 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %24, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$163, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-15:
	%25 = icmp eq i32 %11, 11
	br i1 %25, label %switch.fall.body-18, label %switch.case.next-17

switch.fall.body-16:
	%26 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %26, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$164, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

switch.case.next-17:
	; IfStmt
	%27 = load i32, i32* %1, align 4
	%28 = icmp slt i32 %27, 32
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %if.then-19, label %if.else-27

switch.fall.body-18:
	%31 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %31, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$165, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-29

if.then-19:
	%32 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %32, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$166, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; buf
	; ZeroInit
	store [2 x i8] zeroinitializer, [2 x i8]* %3, align 1
	; s
	; SelectorExpr
	; SliceExpr
	%33 = getelementptr inbounds [2 x i8], [2 x i8]* %3, i32 0, i32 0
	%34 = getelementptr inbounds i8, i8* %33, i64 0
	%35 = sub i64 2, 0
	%36 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 0
	store i8* %34, i8** %36
	%37 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 1
	store i64 %35, i64* %37
	%38 = load i32, i32* %1, align 4
	%39 = sext i32 %38 to i64
	; SelectorExpr
	%40 = load %..string, %..string* @strconv.digits, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %6, align 1
	call void @strconv.append_bits(%..string* %6, {i8*, i64}* %5, i64 %39, i64 16, i1 true, i64 64, %..string %40, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%41 = load %..string, %..string* %6, align 8
	store %..string %41, %..string* %4
	; SwitchStmt
	%42 = load %..string, %..string* %4, align 8
	%43 = extractvalue %..string %42, 1
	%44 = icmp eq i64 %43, 0
	br i1 %44, label %switch.case.body-21, label %switch.case.next-20

switch.case.next-20:
	%45 = icmp eq i64 %43, 1
	br i1 %45, label %switch.fall.body-23, label %switch.case.next-22

switch.case.body-21:
	%46 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %46, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$167, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-26

switch.case.next-22:
	%47 = icmp eq i64 %43, 2
	br i1 %47, label %switch.fall.body-25, label %switch.case.next-24

switch.fall.body-23:
	%48 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %48, i8 48, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-26

switch.case.next-24:
	br label %switch.done-26

switch.fall.body-25:
	%49 = load %strings.Builder*, %strings.Builder** %0, align 8
	%50 = load %..string, %..string* %4, align 8
	call void @strings.write_string(%strings.Builder* %49, %..string %50, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-26

switch.done-26:
	br label %if.done-28

if.else-27:
	%51 = load %strings.Builder*, %strings.Builder** %0, align 8
	%52 = load i32, i32* %1, align 4
	%53 = call i64 @strings.write_rune(%strings.Builder* %51, i32 %52, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-28

if.done-28:
	br label %switch.done-29

switch.done-29:
	; IfStmt
	%54 = load i8, i8* %2, align 1
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-30, label %if.done-31

if.then-30:
	%56 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %56, i8 39, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-31

if.done-31:
	ret void
}

define void @strings.write_escaped_rune(%strings.Builder* %_.0, i32 %_.1, i8 %_.2, i1 %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca i32, align 16
	%2 = alloca i8, align 16
	%3 = alloca i8, align 16
	%4 = alloca i64, align 16
	%5 = alloca i32, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store i32 %_.1, i32* %1
	store i8 %_.2, i8* %2
	%8 = zext i1 %_.3 to i8
	store i8 %8, i8* %3
	; IfStmt
	%9 = load i8, i8* %3, align 1
	%10 = trunc i8 %9 to i1
	br i1 %10, label %if.then-1, label %if.done-9

if.then-1:
	; SwitchStmt
	%11 = load i32, i32* %1, align 4
	%12 = icmp eq i32 %11, 60
	br i1 %12, label %switch.case.body-5, label %switch.case.next-2

switch.case.next-2:
	%13 = icmp eq i32 %11, 62
	br i1 %13, label %switch.case.body-5, label %switch.case.next-3

switch.case.next-3:
	%14 = icmp eq i32 %11, 38
	br i1 %14, label %switch.case.body-5, label %switch.case.next-4

switch.case.next-4:
	br label %if.done-9

switch.case.body-5:
	%15 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %15, i8 92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%16 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %16, i8 117, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ForStmt
	; s
	store i64 12, i64* %4
	br label %for.loop-6

for.loop-6:
	%17 = load i64, i64* %4, align 8
	%18 = icmp sge i64 %17, 0
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %for.body-7, label %for.done-8

for.body-7:
	%21 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%22 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%23 = extractvalue %..string %22, 0
	%24 = extractvalue %..string %22, 1
	%25 = load i32, i32* %1, align 4
	%26 = load i64, i64* %4, align 8
	%27 = bitcast i64 %26 to i64
	%28 = trunc i64 %27 to i32
	%29 = ashr i32 %25, %28
	%30 = and i32 %29, 15
	%31 = sext i32 %30 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$168, i32 0, i32 0), i64 65}, i64 149, i64 32, i64 %31, i64 %24)
	%32 = getelementptr inbounds i8, i8* %23, i64 %31
	%33 = load i8, i8* %32, align 1
	call void @strings.write_byte(%strings.Builder* %21, i8 %33, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%34 = load i64, i64* %4, align 8
	%35 = sub i64 %34, 4
	store i64 %35, i64* %4
	br label %for.loop-6

for.done-8:
	; ReturnStmt
	ret void

if.done-9:
	; IfStmt
	%36 = load i32, i32* %1, align 4
	%37 = load i8, i8* %2, align 1
	%38 = zext i8 %37 to i32
	%39 = icmp eq i32 %36, %38
	%40 = zext i1 %39 to i8
	%41 = trunc i8 %40 to i1
	br i1 %41, label %if.then-11, label %cmp.or-10

cmp.or-10:
	%42 = load i32, i32* %1, align 4
	%43 = icmp eq i32 %42, 92
	%44 = zext i1 %43 to i8
	%45 = trunc i8 %44 to i1
	br i1 %45, label %if.then-11, label %if.else-12

if.then-11:
	%46 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %46, i8 92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%47 = load %strings.Builder*, %strings.Builder** %0, align 8
	%48 = load i32, i32* %1, align 4
	%49 = trunc i32 %48 to i8
	call void @strings.write_byte(%strings.Builder* %47, i8 %49, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.else-12:
	; IfStmt
	%50 = load i32, i32* %1, align 4
	%51 = call i8 @strings.write_escaped_rune.is_printable-0(i32 %50, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%52 = trunc i8 %51 to i1
	br i1 %52, label %if.then-13, label %if.done-14

if.then-13:
	%53 = load %strings.Builder*, %strings.Builder** %0, align 8
	%54 = load i32, i32* %1, align 4
	call void @strings.write_encoded_rune(%strings.Builder* %53, i32 %54, i1 false, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-14:
	; SwitchStmt
	%55 = load i32, i32* %1, align 4
	%56 = icmp eq i32 %55, 7
	br i1 %56, label %switch.case.body-16, label %switch.case.next-15

switch.case.next-15:
	%57 = icmp eq i32 %55, 8
	br i1 %57, label %switch.fall.body-18, label %switch.case.next-17

switch.case.body-16:
	%58 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %58, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$169, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-17:
	%59 = icmp eq i32 %55, 27
	br i1 %59, label %switch.fall.body-20, label %switch.case.next-19

switch.fall.body-18:
	%60 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %60, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$16a, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-19:
	%61 = icmp eq i32 %55, 12
	br i1 %61, label %switch.fall.body-22, label %switch.case.next-21

switch.fall.body-20:
	%62 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %62, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$16b, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-21:
	%63 = icmp eq i32 %55, 10
	br i1 %63, label %switch.fall.body-24, label %switch.case.next-23

switch.fall.body-22:
	%64 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %64, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$16c, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-23:
	%65 = icmp eq i32 %55, 13
	br i1 %65, label %switch.fall.body-26, label %switch.case.next-25

switch.fall.body-24:
	%66 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %66, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$16d, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-25:
	%67 = icmp eq i32 %55, 9
	br i1 %67, label %switch.fall.body-28, label %switch.case.next-27

switch.fall.body-26:
	%68 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %68, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$16e, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-27:
	%69 = icmp eq i32 %55, 11
	br i1 %69, label %switch.fall.body-30, label %switch.case.next-29

switch.fall.body-28:
	%70 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %70, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$16f, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-29:
	; SwitchStmt
	; c
	%71 = load i32, i32* %1, align 4
	store i32 %71, i32* %5
	%72 = load i32, i32* %5, align 4
	%73 = icmp slt i32 %72, 32
	%74 = zext i1 %73 to i8
	%75 = icmp eq i8 1, %74
	br i1 %75, label %switch.case.body-32, label %switch.case.next-31

switch.fall.body-30:
	%76 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %76, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$170, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-44

switch.case.next-31:
	%77 = load i32, i32* %5, align 4
	%78 = icmp sgt i32 %77, 1114111
	%79 = zext i1 %78 to i8
	%80 = icmp eq i8 1, %79
	br i1 %80, label %switch.fall.body-34, label %switch.case.next-33

switch.case.body-32:
	%81 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %81, i8 92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%82 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %82, i8 120, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%83 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%84 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%85 = extractvalue %..string %84, 0
	%86 = extractvalue %..string %84, 1
	%87 = load i32, i32* %5, align 4
	%88 = trunc i32 %87 to i8
	%89 = lshr i8 %88, 4
	%90 = zext i8 %89 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$171, i32 0, i32 0), i64 65}, i64 177, i64 31, i64 %90, i64 %86)
	%91 = getelementptr inbounds i8, i8* %85, i64 %90
	%92 = load i8, i8* %91, align 1
	call void @strings.write_byte(%strings.Builder* %83, i8 %92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%93 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%94 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%95 = extractvalue %..string %94, 0
	%96 = extractvalue %..string %94, 1
	%97 = load i32, i32* %5, align 4
	%98 = trunc i32 %97 to i8
	%99 = and i8 %98, 15
	%100 = zext i8 %99 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$172, i32 0, i32 0), i64 65}, i64 178, i64 31, i64 %100, i64 %96)
	%101 = getelementptr inbounds i8, i8* %95, i64 %100
	%102 = load i8, i8* %101, align 1
	call void @strings.write_byte(%strings.Builder* %93, i8 %102, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-43

switch.case.next-33:
	%103 = load i32, i32* %5, align 4
	%104 = icmp slt i32 %103, 65536
	%105 = zext i1 %104 to i8
	%106 = icmp eq i8 1, %105
	br i1 %106, label %switch.fall.body-36, label %switch.case.next-35

switch.fall.body-34:
	; AssignStmt
	store i32 65533, i32* %5
	; fallthrough
	br label %switch.fall.body-36

switch.case.next-35:
	%107 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %107, i8 92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%108 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %108, i8 85, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ForStmt
	; s
	store i64 28, i64* %7
	br label %for.loop-40

switch.fall.body-36:
	%109 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %109, i8 92, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%110 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %110, i8 117, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ForStmt
	; s
	store i64 12, i64* %6
	br label %for.loop-37

for.loop-37:
	%111 = load i64, i64* %6, align 8
	%112 = icmp sge i64 %111, 0
	%113 = zext i1 %112 to i8
	%114 = trunc i8 %113 to i1
	br i1 %114, label %for.body-38, label %for.done-39

for.body-38:
	%115 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%116 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%117 = extractvalue %..string %116, 0
	%118 = extractvalue %..string %116, 1
	%119 = load i32, i32* %5, align 4
	%120 = load i64, i64* %6, align 8
	%121 = bitcast i64 %120 to i64
	%122 = trunc i64 %121 to i32
	%123 = ashr i32 %119, %122
	%124 = and i32 %123, 15
	%125 = sext i32 %124 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$173, i32 0, i32 0), i64 65}, i64 187, i64 32, i64 %125, i64 %118)
	%126 = getelementptr inbounds i8, i8* %117, i64 %125
	%127 = load i8, i8* %126, align 1
	call void @strings.write_byte(%strings.Builder* %115, i8 %127, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%128 = load i64, i64* %6, align 8
	%129 = sub i64 %128, 4
	store i64 %129, i64* %6
	br label %for.loop-37

for.done-39:
	br label %switch.done-43

for.loop-40:
	%130 = load i64, i64* %7, align 8
	%131 = icmp sge i64 %130, 0
	%132 = zext i1 %131 to i8
	%133 = trunc i8 %132 to i1
	br i1 %133, label %for.body-41, label %for.done-42

for.body-41:
	%134 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	%135 = load %..string, %..string* @strings.DIGITS_LOWER, align 8
	%136 = extractvalue %..string %135, 0
	%137 = extractvalue %..string %135, 1
	%138 = load i32, i32* %5, align 4
	%139 = load i64, i64* %7, align 8
	%140 = bitcast i64 %139 to i64
	%141 = trunc i64 %140 to i32
	%142 = ashr i32 %138, %141
	%143 = and i32 %142, 15
	%144 = sext i32 %143 to i64
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$174, i32 0, i32 0), i64 65}, i64 193, i64 32, i64 %144, i64 %137)
	%145 = getelementptr inbounds i8, i8* %136, i64 %144
	%146 = load i8, i8* %145, align 1
	call void @strings.write_byte(%strings.Builder* %134, i8 %146, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%147 = load i64, i64* %7, align 8
	%148 = sub i64 %147, 4
	store i64 %148, i64* %7
	br label %for.loop-40

for.done-42:
	br label %switch.done-43

switch.done-43:
	br label %switch.done-44

switch.done-44:
	ret void
}

define i8 @strings.write_escaped_rune.is_printable-0(i32 %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i32, align 16
	store i32 %_.0, i32* %0
	; IfStmt
	%1 = load i32, i32* %0, align 4
	%2 = icmp sle i32 %1, 255
	%3 = zext i1 %2 to i8
	%4 = trunc i8 %3 to i1
	br i1 %4, label %if.then-1, label %if.done-6

if.then-1:
	; SwitchStmt
	%5 = load i32, i32* %0, align 4
	%6 = icmp sle i32 32, %5
	%7 = icmp sle i32 %5, 126
	%8 = zext i1 %6 to i8
	%9 = zext i1 %7 to i8
	%10 = and i8 %8, %9
	%11 = trunc i8 %10 to i1
	br i1 %11, label %switch.case.body-3, label %switch.case.next-2

switch.case.next-2:
	%12 = icmp sle i32 161, %5
	%13 = icmp sle i32 %5, 255
	%14 = zext i1 %12 to i8
	%15 = zext i1 %13 to i8
	%16 = and i8 %14, %15
	%17 = trunc i8 %16 to i1
	br i1 %17, label %switch.fall.body-5, label %switch.case.next-4

switch.case.body-3:
	; ReturnStmt
	ret i8 1

switch.case.next-4:
	br label %if.done-6

switch.fall.body-5:
	; ReturnStmt
	%18 = load i32, i32* %0, align 4
	%19 = icmp ne i32 %18, 173
	%20 = zext i1 %19 to i8
	ret i8 %20

if.done-6:
	; ReturnStmt
	ret i8 0
}

define void @strings.write_u64(%strings.Builder* %_.0, i64 %_.1, i64 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca [32 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca %..string, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	; buf
	%7 = bitcast [32 x i8]* %3 to %..rawptr
	; ZeroInit
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 32)
	; s
	; SelectorExpr
	; SliceExpr
	%9 = getelementptr inbounds [32 x i8], [32 x i8]* %3, i32 0, i32 0
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = sub i64 32, 0
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 0
	store i8* %10, i8** %12
	%13 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 1
	store i64 %11, i64* %13
	%14 = load i64, i64* %1, align 8
	%15 = load i64, i64* %2, align 8
	; SelectorExpr
	%16 = load %..string, %..string* @strconv.digits, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %6, align 1
	call void @strconv.append_bits(%..string* %6, {i8*, i64}* %5, i64 %14, i64 %15, i1 false, i64 64, %..string %16, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%17 = load %..string, %..string* %6, align 8
	store %..string %17, %..string* %4
	%18 = load %strings.Builder*, %strings.Builder** %0, align 8
	%19 = load %..string, %..string* %4, align 8
	call void @strings.write_string(%strings.Builder* %18, %..string %19, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @strings.write_i64(%strings.Builder* %_.0, i64 %_.1, i64 %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca [32 x i8], align 16
	%4 = alloca %..string, align 16
	%5 = alloca {i8*, i64}, align 16
	%6 = alloca %..string, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store i64 %_.1, i64* %1
	store i64 %_.2, i64* %2
	; buf
	%7 = bitcast [32 x i8]* %3 to %..rawptr
	; ZeroInit
	%8 = call %..rawptr @mem.zero(%..rawptr %7, i64 32)
	; s
	; SelectorExpr
	; SliceExpr
	%9 = getelementptr inbounds [32 x i8], [32 x i8]* %3, i32 0, i32 0
	%10 = getelementptr inbounds i8, i8* %9, i64 0
	%11 = sub i64 32, 0
	%12 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 0
	store i8* %10, i8** %12
	%13 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %5, i32 0, i32 1
	store i64 %11, i64* %13
	%14 = load i64, i64* %1, align 8
	%15 = bitcast i64 %14 to i64
	%16 = load i64, i64* %2, align 8
	; SelectorExpr
	%17 = load %..string, %..string* @strconv.digits, align 8
	; ZeroInit
	store %..string zeroinitializer, %..string* %6, align 1
	call void @strconv.append_bits(%..string* %6, {i8*, i64}* %5, i64 %15, i64 %16, i1 true, i64 64, %..string %17, i8 zeroinitializer, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%18 = load %..string, %..string* %6, align 8
	store %..string %18, %..string* %4
	%19 = load %strings.Builder*, %strings.Builder** %0, align 8
	%20 = load %..string, %..string* %4, align 8
	call void @strings.write_string(%strings.Builder* %19, %..string %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @decimal.trim(%decimal.Decimal* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	; ForStmt
	br label %for.loop-1

for.loop-1:
	; SelectorExpr
	%1 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%2 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %1, i32 0, i32 1
	%3 = load i64, i64* %2, align 8
	%4 = icmp sgt i64 %3, 0
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %cmp.and-2, label %for.done-4

cmp.and-2:
	; IndexExpr
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i32 0, i32 0
	; SelectorExpr
	%9 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%10 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %9, i32 0, i32 1
	%11 = load i64, i64* %10, align 8
	%12 = sub i64 %11, 1
	%13 = trunc i64 %12 to i32
	%14 = getelementptr inbounds [384 x i8], [384 x i8]* %8, i32 0, i32 %13
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$175, i32 0, i32 0), i64 65}, i64 50, i64 32, i64 %12, i64 384)
	%15 = load i8, i8* %14, align 1
	%16 = icmp eq i8 %15, 48
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %for.body-3, label %for.done-4

for.body-3:
	; AssignStmt
	; SelectorExpr
	%19 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%20 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %19, i32 0, i32 1
	%21 = load i64, i64* %20, align 8
	%22 = sub i64 %21, 1
	store i64 %22, i64* %20
	br label %for.loop-1

for.done-4:
	; IfStmt
	; SelectorExpr
	%23 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%24 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %23, i32 0, i32 1
	%25 = load i64, i64* %24, align 8
	%26 = icmp eq i64 %25, 0
	%27 = zext i1 %26 to i8
	%28 = trunc i8 %27 to i1
	br i1 %28, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%29 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%30 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %29, i32 0, i32 2
	store i64 0, i64* %30
	br label %if.done-6

if.done-6:
	ret void
}

define void @decimal.assign(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca [64 x i8], align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; buf
	%6 = bitcast [64 x i8]* %2 to %..rawptr
	; ZeroInit
	%7 = call %..rawptr @mem.zero(%..rawptr %6, i64 64)
	; n
	store i64 0, i64* %3
	; ForStmt
	; i
	%8 = load i64, i64* %1, align 8
	store i64 %8, i64* %4
	br label %for.loop-1

for.loop-1:
	%9 = load i64, i64* %4, align 8
	%10 = icmp ugt i64 %9, 0
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %for.body-2, label %for.done-3

for.body-2:
	; j
	%13 = load i64, i64* %4, align 8
	%14 = udiv i64 %13, 10
	store i64 %14, i64* %5
	; AssignStmt
	%15 = load i64, i64* %5, align 8
	%16 = mul i64 10, %15
	%17 = load i64, i64* %4, align 8
	%18 = sub i64 %17, %16
	store i64 %18, i64* %4
	; AssignStmt
	; IndexExpr
	%19 = load i64, i64* %3, align 8
	%20 = trunc i64 %19 to i32
	%21 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 %20
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$176, i32 0, i32 0), i64 65}, i64 65, i64 7, i64 %19, i64 64)
	%22 = load i64, i64* %4, align 8
	%23 = add i64 48, %22
	%24 = trunc i64 %23 to i8
	store i8 %24, i8* %21
	; AssignStmt
	%25 = load i64, i64* %3, align 8
	%26 = add i64 %25, 1
	store i64 %26, i64* %3
	; AssignStmt
	%27 = load i64, i64* %5, align 8
	store i64 %27, i64* %4
	br label %for.loop-1

for.done-3:
	; AssignStmt
	; SelectorExpr
	%28 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%29 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %28, i32 0, i32 1
	store i64 0, i64* %29
	; ForStmt
	; AssignStmt
	%30 = load i64, i64* %3, align 8
	%31 = sub i64 %30, 1
	store i64 %31, i64* %3
	br label %for.loop-4

for.loop-4:
	%32 = load i64, i64* %3, align 8
	%33 = icmp sge i64 %32, 0
	%34 = zext i1 %33 to i8
	%35 = trunc i8 %34 to i1
	br i1 %35, label %for.body-5, label %for.done-6

for.body-5:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%36 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%37 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %36, i32 0, i32 0
	; SelectorExpr
	%38 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i32 0, i32 1
	%40 = load i64, i64* %39, align 8
	%41 = trunc i64 %40 to i32
	%42 = getelementptr inbounds [384 x i8], [384 x i8]* %37, i32 0, i32 %41
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$177, i32 0, i32 0), i64 65}, i64 72, i64 14, i64 %40, i64 384)
	; IndexExpr
	%43 = load i64, i64* %3, align 8
	%44 = trunc i64 %43 to i32
	%45 = getelementptr inbounds [64 x i8], [64 x i8]* %2, i32 0, i32 %44
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$178, i32 0, i32 0), i64 65}, i64 72, i64 27, i64 %43, i64 64)
	%46 = load i8, i8* %45, align 1
	store i8 %46, i8* %42
	; AssignStmt
	; SelectorExpr
	%47 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%48 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %47, i32 0, i32 1
	%49 = load i64, i64* %48, align 8
	%50 = add i64 %49, 1
	store i64 %50, i64* %48
	; AssignStmt
	%51 = load i64, i64* %3, align 8
	%52 = sub i64 %51, 1
	store i64 %52, i64* %3
	br label %for.loop-4

for.done-6:
	; AssignStmt
	; SelectorExpr
	%53 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%54 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %53, i32 0, i32 2
	; SelectorExpr
	%55 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%56 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %55, i32 0, i32 1
	%57 = load i64, i64* %56, align 8
	store i64 %57, i64* %54
	%58 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %58, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @decimal.shift_right(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; r
	store i64 0, i64* %2
	; w
	store i64 0, i64* %3
	; n
	; ZeroInit
	store i64 zeroinitializer, i64* %4, align 1
	; ForStmt
	br label %for.loop-1

for.loop-1:
	%10 = load i64, i64* %4, align 8
	%11 = load i64, i64* %1, align 8
	%12 = lshr i64 %10, %11
	%13 = icmp eq i64 %12, 0
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %for.body-2, label %for.done-10

for.body-2:
	; IfStmt
	%16 = load i64, i64* %2, align 8
	; SelectorExpr
	%17 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%18 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %17, i32 0, i32 1
	%19 = load i64, i64* %18, align 8
	%20 = icmp sge i64 %16, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-3, label %if.done-9

if.then-3:
	; IfStmt
	%23 = load i64, i64* %4, align 8
	%24 = icmp eq i64 %23, 0
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-4, label %if.done-5

if.then-4:
	; AssignStmt
	; SelectorExpr
	%27 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%28 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %27, i32 0, i32 1
	store i64 0, i64* %28
	; ReturnStmt
	ret void

if.done-5:
	; ForStmt
	br label %for.loop-6

for.loop-6:
	%29 = load i64, i64* %4, align 8
	%30 = load i64, i64* %1, align 8
	%31 = lshr i64 %29, %30
	%32 = icmp eq i64 %31, 0
	%33 = zext i1 %32 to i8
	%34 = trunc i8 %33 to i1
	br i1 %34, label %for.body-7, label %for.done-8

for.body-7:
	; AssignStmt
	%35 = load i64, i64* %4, align 8
	%36 = mul i64 %35, 10
	store i64 %36, i64* %4
	; AssignStmt
	%37 = load i64, i64* %2, align 8
	%38 = add i64 %37, 1
	store i64 %38, i64* %2
	br label %for.loop-6

for.done-8:
	; break
	br label %for.done-10

if.done-9:
	; c
	; IndexExpr
	; SelectorExpr
	%39 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%40 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %39, i32 0, i32 0
	%41 = load i64, i64* %2, align 8
	%42 = trunc i64 %41 to i32
	%43 = getelementptr inbounds [384 x i8], [384 x i8]* %40, i32 0, i32 %42
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$179, i32 0, i32 0), i64 65}, i64 99, i64 22, i64 %41, i64 384)
	%44 = load i8, i8* %43, align 1
	%45 = zext i8 %44 to i64
	store i64 %45, i64* %5
	; AssignStmt
	%46 = load i64, i64* %4, align 8
	%47 = mul i64 %46, 10
	%48 = load i64, i64* %5, align 8
	%49 = add i64 %47, %48
	%50 = sub i64 %49, 48
	store i64 %50, i64* %4
	; AssignStmt
	%51 = load i64, i64* %2, align 8
	%52 = add i64 %51, 1
	store i64 %52, i64* %2
	br label %for.loop-1

for.done-10:
	; AssignStmt
	; SelectorExpr
	%53 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%54 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %53, i32 0, i32 2
	%55 = load i64, i64* %2, align 8
	%56 = sub i64 %55, 1
	%57 = load i64, i64* %54, align 8
	%58 = sub i64 %57, %56
	store i64 %58, i64* %54
	; mask
	%59 = load i64, i64* %1, align 8
	%60 = shl i64 1, %59
	%61 = sub i64 %60, 1
	store i64 %61, i64* %6
	; ForStmt
	br label %for.loop-11

for.loop-11:
	%62 = load i64, i64* %2, align 8
	; SelectorExpr
	%63 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%64 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %63, i32 0, i32 1
	%65 = load i64, i64* %64, align 8
	%66 = icmp slt i64 %62, %65
	%67 = zext i1 %66 to i8
	%68 = trunc i8 %67 to i1
	br i1 %68, label %for.body-12, label %for.done-13

for.body-12:
	; c
	; IndexExpr
	; SelectorExpr
	%69 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%70 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %69, i32 0, i32 0
	%71 = load i64, i64* %2, align 8
	%72 = trunc i64 %71 to i32
	%73 = getelementptr inbounds [384 x i8], [384 x i8]* %70, i32 0, i32 %72
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$17a, i32 0, i32 0), i64 65}, i64 107, i64 22, i64 %71, i64 384)
	%74 = load i8, i8* %73, align 1
	%75 = zext i8 %74 to i64
	store i64 %75, i64* %7
	; dig
	%76 = load i64, i64* %4, align 8
	%77 = load i64, i64* %1, align 8
	%78 = lshr i64 %76, %77
	store i64 %78, i64* %8
	; AssignStmt
	%79 = load i64, i64* %6, align 8
	%80 = load i64, i64* %4, align 8
	%81 = and i64 %80, %79
	store i64 %81, i64* %4
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%82 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%83 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %82, i32 0, i32 0
	%84 = load i64, i64* %3, align 8
	%85 = trunc i64 %84 to i32
	%86 = getelementptr inbounds [384 x i8], [384 x i8]* %83, i32 0, i32 %85
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$17b, i32 0, i32 0), i64 65}, i64 110, i64 12, i64 %84, i64 384)
	%87 = load i64, i64* %8, align 8
	%88 = add i64 48, %87
	%89 = trunc i64 %88 to i8
	store i8 %89, i8* %86
	; AssignStmt
	%90 = load i64, i64* %3, align 8
	%91 = add i64 %90, 1
	store i64 %91, i64* %3
	; AssignStmt
	%92 = load i64, i64* %4, align 8
	%93 = mul i64 %92, 10
	%94 = load i64, i64* %7, align 8
	%95 = add i64 %93, %94
	%96 = sub i64 %95, 48
	store i64 %96, i64* %4
	; AssignStmt
	%97 = load i64, i64* %2, align 8
	%98 = add i64 %97, 1
	store i64 %98, i64* %2
	br label %for.loop-11

for.done-13:
	; ForStmt
	br label %for.loop-14

for.loop-14:
	%99 = load i64, i64* %4, align 8
	%100 = icmp ugt i64 %99, 0
	%101 = zext i1 %100 to i8
	%102 = trunc i8 %101 to i1
	br i1 %102, label %for.body-15, label %for.done-21

for.body-15:
	; dig
	%103 = load i64, i64* %4, align 8
	%104 = load i64, i64* %1, align 8
	%105 = lshr i64 %103, %104
	store i64 %105, i64* %9
	; AssignStmt
	%106 = load i64, i64* %6, align 8
	%107 = load i64, i64* %4, align 8
	%108 = and i64 %107, %106
	store i64 %108, i64* %4
	; IfStmt
	%109 = load i64, i64* %3, align 8
	%110 = icmp slt i64 %109, 384
	%111 = zext i1 %110 to i8
	%112 = trunc i8 %111 to i1
	br i1 %112, label %if.then-16, label %if.else-17

if.then-16:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%113 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%114 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %113, i32 0, i32 0
	%115 = load i64, i64* %3, align 8
	%116 = trunc i64 %115 to i32
	%117 = getelementptr inbounds [384 x i8], [384 x i8]* %114, i32 0, i32 %116
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$17c, i32 0, i32 0), i64 65}, i64 119, i64 13, i64 %115, i64 384)
	%118 = load i64, i64* %9, align 8
	%119 = add i64 48, %118
	%120 = trunc i64 %119 to i8
	store i8 %120, i8* %117
	; AssignStmt
	%121 = load i64, i64* %3, align 8
	%122 = add i64 %121, 1
	store i64 %122, i64* %3
	br label %if.done-20

if.else-17:
	; IfStmt
	%123 = load i64, i64* %9, align 8
	%124 = icmp ugt i64 %123, 0
	%125 = zext i1 %124 to i8
	%126 = trunc i8 %125 to i1
	br i1 %126, label %if.then-18, label %if.done-19

if.then-18:
	; AssignStmt
	; SelectorExpr
	%127 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%128 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %127, i32 0, i32 4
	store i8 1, i8* %128
	br label %if.done-19

if.done-19:
	br label %if.done-20

if.done-20:
	; AssignStmt
	%129 = load i64, i64* %4, align 8
	%130 = mul i64 %129, 10
	store i64 %130, i64* %4
	br label %for.loop-14

for.done-21:
	; AssignStmt
	; SelectorExpr
	%131 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%132 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %131, i32 0, i32 1
	%133 = load i64, i64* %3, align 8
	store i64 %133, i64* %132
	%134 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %134, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @decimal.shift_left(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca i64, align 16
	%7 = alloca i64, align 16
	%8 = alloca i64, align 16
	%9 = alloca i64, align 16
	%10 = alloca i64, align 16
	%11 = alloca %runtime.Source_Code_Location, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; capacity
	%12 = load i64, i64* %1, align 8
	%13 = uitofp i64 %12 to double
	%14 = fmul double %13, 0x3fd34413509f7a00
	%15 = fadd double %14, 0x3ff0000000000000
	%16 = fptosi double %15 to i64
	store i64 %16, i64* %2
	; r
	; SelectorExpr
	%17 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%18 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %17, i32 0, i32 1
	%19 = load i64, i64* %18, align 8
	store i64 %19, i64* %3
	; w
	; SelectorExpr
	%20 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%21 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %20, i32 0, i32 1
	%22 = load i64, i64* %21, align 8
	%23 = load i64, i64* %2, align 8
	%24 = add i64 %22, %23
	store i64 %24, i64* %4
	; d
	store i64 384, i64* %5
	; n
	; ZeroInit
	store i64 zeroinitializer, i64* %6, align 1
	; ForStmt
	; AssignStmt
	%25 = load i64, i64* %3, align 8
	%26 = sub i64 %25, 1
	store i64 %26, i64* %3
	br label %for.loop-1

for.loop-1:
	%27 = load i64, i64* %3, align 8
	%28 = icmp sge i64 %27, 0
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %for.body-2, label %for.done-8

for.body-2:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%31 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%32 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %31, i32 0, i32 0
	%33 = load i64, i64* %3, align 8
	%34 = trunc i64 %33 to i32
	%35 = getelementptr inbounds [384 x i8], [384 x i8]* %32, i32 0, i32 %34
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$17d, i32 0, i32 0), i64 65}, i64 145, i64 23, i64 %33, i64 384)
	%36 = load i8, i8* %35, align 1
	%37 = zext i8 %36 to i64
	%38 = sub i64 %37, 48
	%39 = load i64, i64* %1, align 8
	%40 = shl i64 %38, %39
	%41 = load i64, i64* %6, align 8
	%42 = add i64 %41, %40
	store i64 %42, i64* %6
	; quo
	%43 = load i64, i64* %6, align 8
	%44 = udiv i64 %43, 10
	store i64 %44, i64* %7
	; rem
	%45 = load i64, i64* %6, align 8
	%46 = load i64, i64* %7, align 8
	%47 = mul i64 10, %46
	%48 = sub i64 %45, %47
	store i64 %48, i64* %8
	; AssignStmt
	%49 = load i64, i64* %4, align 8
	%50 = sub i64 %49, 1
	store i64 %50, i64* %4
	; IfStmt
	%51 = load i64, i64* %4, align 8
	%52 = load i64, i64* %5, align 8
	%53 = icmp slt i64 %51, %52
	%54 = zext i1 %53 to i8
	%55 = trunc i8 %54 to i1
	br i1 %55, label %if.then-3, label %if.else-4

if.then-3:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%56 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%57 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %56, i32 0, i32 0
	%58 = load i64, i64* %4, align 8
	%59 = trunc i64 %58 to i32
	%60 = getelementptr inbounds [384 x i8], [384 x i8]* %57, i32 0, i32 %59
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$17e, i32 0, i32 0), i64 65}, i64 150, i64 13, i64 %58, i64 384)
	%61 = load i64, i64* %8, align 8
	%62 = add i64 48, %61
	%63 = trunc i64 %62 to i8
	store i8 %63, i8* %60
	br label %if.done-7

if.else-4:
	; IfStmt
	%64 = load i64, i64* %8, align 8
	%65 = icmp ne i64 %64, 0
	%66 = zext i1 %65 to i8
	%67 = trunc i8 %66 to i1
	br i1 %67, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%68 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%69 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %68, i32 0, i32 4
	store i8 1, i8* %69
	br label %if.done-6

if.done-6:
	br label %if.done-7

if.done-7:
	; AssignStmt
	%70 = load i64, i64* %7, align 8
	store i64 %70, i64* %6
	; AssignStmt
	%71 = load i64, i64* %3, align 8
	%72 = sub i64 %71, 1
	store i64 %72, i64* %3
	br label %for.loop-1

for.done-8:
	; ForStmt
	br label %for.loop-9

for.loop-9:
	%73 = load i64, i64* %6, align 8
	%74 = icmp ugt i64 %73, 0
	%75 = zext i1 %74 to i8
	%76 = trunc i8 %75 to i1
	br i1 %76, label %for.body-10, label %for.done-16

for.body-10:
	; quo
	%77 = load i64, i64* %6, align 8
	%78 = udiv i64 %77, 10
	store i64 %78, i64* %9
	; rem
	%79 = load i64, i64* %6, align 8
	%80 = load i64, i64* %9, align 8
	%81 = mul i64 10, %80
	%82 = sub i64 %79, %81
	store i64 %82, i64* %10
	; AssignStmt
	%83 = load i64, i64* %4, align 8
	%84 = sub i64 %83, 1
	store i64 %84, i64* %4
	; IfStmt
	%85 = load i64, i64* %4, align 8
	%86 = load i64, i64* %5, align 8
	%87 = icmp slt i64 %85, %86
	%88 = zext i1 %87 to i8
	%89 = trunc i8 %88 to i1
	br i1 %89, label %if.then-11, label %if.else-12

if.then-11:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%90 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%91 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %90, i32 0, i32 0
	%92 = load i64, i64* %4, align 8
	%93 = trunc i64 %92 to i32
	%94 = getelementptr inbounds [384 x i8], [384 x i8]* %91, i32 0, i32 %93
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$17f, i32 0, i32 0), i64 65}, i64 162, i64 13, i64 %92, i64 384)
	%95 = load i64, i64* %10, align 8
	%96 = add i64 48, %95
	%97 = trunc i64 %96 to i8
	store i8 %97, i8* %94
	br label %if.done-15

if.else-12:
	; IfStmt
	%98 = load i64, i64* %10, align 8
	%99 = icmp ne i64 %98, 0
	%100 = zext i1 %99 to i8
	%101 = trunc i8 %100 to i1
	br i1 %101, label %if.then-13, label %if.done-14

if.then-13:
	; AssignStmt
	; SelectorExpr
	%102 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%103 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %102, i32 0, i32 4
	store i8 1, i8* %103
	br label %if.done-14

if.done-14:
	br label %if.done-15

if.done-15:
	; AssignStmt
	%104 = load i64, i64* %9, align 8
	store i64 %104, i64* %6
	br label %for.loop-9

for.done-16:
	%105 = load i64, i64* %4, align 8
	%106 = icmp sge i64 %105, 0
	%107 = zext i1 %106 to i8
	%108 = trunc i8 %107 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$180, i32 0, i32 0), i64 65}, i64 170, i64 2, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$181, i32 0, i32 0), i64 10}, i64 13333254875994028187}, %runtime.Source_Code_Location* %11
	%109 = call i8 @runtime.assert(i1 %108, %..string zeroinitializer, %runtime.Source_Code_Location* %11, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%110 = load i64, i64* %4, align 8
	%111 = load i64, i64* %2, align 8
	%112 = sub i64 %111, %110
	store i64 %112, i64* %2
	; AssignStmt
	; SelectorExpr
	%113 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%114 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %113, i32 0, i32 1
	; min
	%115 = load i64, i64* %5, align 8
	; SelectorExpr
	%116 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%117 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %116, i32 0, i32 1
	%118 = load i64, i64* %117, align 8
	%119 = load i64, i64* %2, align 8
	%120 = add i64 %118, %119
	%121 = icmp slt i64 %120, %115
	%122 = select i1 %121, i64 %120, i64 %115
	store i64 %122, i64* %114
	; AssignStmt
	; SelectorExpr
	%123 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%124 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %123, i32 0, i32 2
	%125 = load i64, i64* %2, align 8
	%126 = load i64, i64* %124, align 8
	%127 = add i64 %126, %125
	store i64 %127, i64* %124
	%128 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %128, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @decimal.shift(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; SwitchStmt
	; k
	%3 = load i64, i64* %1, align 8
	store i64 %3, i64* %2
	; SelectorExpr
	%4 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%5 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %4, i32 0, i32 1
	%6 = load i64, i64* %5, align 8
	%7 = icmp eq i64 %6, 0
	%8 = zext i1 %7 to i8
	%9 = icmp eq i8 1, %8
	br i1 %9, label %switch.case.body-2, label %switch.case.next-1

switch.case.next-1:
	%10 = load i64, i64* %2, align 8
	%11 = icmp sgt i64 %10, 0
	%12 = zext i1 %11 to i8
	%13 = icmp eq i8 1, %12
	br i1 %13, label %switch.fall.body-4, label %switch.case.next-3

switch.case.body-2:
	br label %switch.done-13

switch.case.next-3:
	%14 = load i64, i64* %2, align 8
	%15 = icmp slt i64 %14, 0
	%16 = zext i1 %15 to i8
	%17 = icmp eq i8 1, %16
	br i1 %17, label %switch.fall.body-9, label %switch.case.next-8

switch.fall.body-4:
	; ForStmt
	br label %for.loop-5

for.loop-5:
	%18 = load i64, i64* %2, align 8
	%19 = icmp sgt i64 %18, 60
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %for.body-6, label %for.done-7

for.body-6:
	%22 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.shift_left(%decimal.Decimal* %22, i64 60, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%23 = load i64, i64* %2, align 8
	%24 = sub i64 %23, 60
	store i64 %24, i64* %2
	br label %for.loop-5

for.done-7:
	%25 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%26 = load i64, i64* %2, align 8
	%27 = bitcast i64 %26 to i64
	call void @decimal.shift_left(%decimal.Decimal* %25, i64 %27, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-13

switch.case.next-8:
	br label %switch.done-13

switch.fall.body-9:
	; ForStmt
	br label %for.loop-10

for.loop-10:
	%28 = load i64, i64* %2, align 8
	%29 = icmp slt i64 %28, -60
	%30 = zext i1 %29 to i8
	%31 = trunc i8 %30 to i1
	br i1 %31, label %for.body-11, label %for.done-12

for.body-11:
	%32 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.shift_right(%decimal.Decimal* %32, i64 60, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; AssignStmt
	%33 = load i64, i64* %2, align 8
	%34 = add i64 %33, 60
	store i64 %34, i64* %2
	br label %for.loop-10

for.done-12:
	%35 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%36 = load i64, i64* %2, align 8
	%37 = sub i64 0, %36
	%38 = bitcast i64 %37 to i64
	call void @decimal.shift_right(%decimal.Decimal* %35, i64 %38, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-13

switch.done-13:
	ret void
}

define i8 @decimal.can_round_up(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i32 0, i32 1
	%9 = load i64, i64* %8, align 8
	%10 = icmp sge i64 %6, %9
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret i8 0

if.done-3:
	; IfStmt
	; IndexExpr
	; SelectorExpr
	%13 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%14 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %13, i32 0, i32 0
	%15 = load i64, i64* %1, align 8
	%16 = trunc i64 %15 to i32
	%17 = getelementptr inbounds [384 x i8], [384 x i8]* %14, i32 0, i32 %16
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$182, i32 0, i32 0), i64 65}, i64 204, i64 14, i64 %15, i64 384)
	%18 = load i8, i8* %17, align 1
	%19 = icmp eq i8 %18, 53
	%20 = zext i1 %19 to i8
	%21 = trunc i8 %20 to i1
	br i1 %21, label %cmp.and-4, label %if.done-10

cmp.and-4:
	%22 = load i64, i64* %1, align 8
	%23 = add i64 %22, 1
	; SelectorExpr
	%24 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%25 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %24, i32 0, i32 1
	%26 = load i64, i64* %25, align 8
	%27 = icmp eq i64 %23, %26
	%28 = zext i1 %27 to i8
	%29 = trunc i8 %28 to i1
	br i1 %29, label %if.then-5, label %if.done-10

if.then-5:
	; IfStmt
	; SelectorExpr
	%30 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%31 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %30, i32 0, i32 4
	%32 = load i8, i8* %31, align 1
	%33 = trunc i8 %32 to i1
	br i1 %33, label %if.then-6, label %if.done-7

if.then-6:
	; ReturnStmt
	ret i8 1

if.done-7:
	; ReturnStmt
	%34 = load i64, i64* %1, align 8
	%35 = icmp sgt i64 %34, 0
	%36 = zext i1 %35 to i8
	%37 = load i64, i64* %1, align 8
	%38 = icmp sgt i64 %37, 0
	%39 = zext i1 %38 to i8
	%40 = trunc i8 %39 to i1
	br i1 %40, label %logical.cmp.rhs-8, label %logical.cmp.done-9

logical.cmp.rhs-8:
	; IndexExpr
	; SelectorExpr
	%41 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%42 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %41, i32 0, i32 0
	%43 = load i64, i64* %1, align 8
	%44 = sub i64 %43, 1
	%45 = trunc i64 %44 to i32
	%46 = getelementptr inbounds [384 x i8], [384 x i8]* %42, i32 0, i32 %45
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$183, i32 0, i32 0), i64 65}, i64 206, i64 30, i64 %44, i64 384)
	%47 = load i8, i8* %46, align 1
	%48 = sub i8 %47, 48
	%49 = urem i8 %48, 2
	%50 = icmp ne i8 %49, 0
	%51 = zext i1 %50 to i8
	br label %logical.cmp.done-9

logical.cmp.done-9:
	%52 = phi i8 [ 0, %if.done-7 ], [ %51, %logical.cmp.rhs-8 ]
	ret i8 %52

if.done-10:
	; ReturnStmt
	; IndexExpr
	; SelectorExpr
	%53 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%54 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %53, i32 0, i32 0
	%55 = load i64, i64* %1, align 8
	%56 = trunc i64 %55 to i32
	%57 = getelementptr inbounds [384 x i8], [384 x i8]* %54, i32 0, i32 %56
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$184, i32 0, i32 0), i64 65}, i64 209, i64 18, i64 %55, i64 384)
	%58 = load i8, i8* %57, align 1
	%59 = icmp uge i8 %58, 53
	%60 = zext i1 %59 to i8
	ret i8 %60
}

define void @decimal.round(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i32 0, i32 1
	%9 = load i64, i64* %8, align 8
	%10 = icmp sge i64 %6, %9
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; IfStmt
	%13 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%14 = load i64, i64* %1, align 8
	%15 = call i8 @decimal.can_round_up(%decimal.Decimal* %13, i64 %14, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%16 = trunc i8 %15 to i1
	br i1 %16, label %if.then-4, label %if.else-5

if.then-4:
	%17 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%18 = load i64, i64* %1, align 8
	call void @decimal.round_up(%decimal.Decimal* %17, i64 %18, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-6

if.else-5:
	%19 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%20 = load i64, i64* %1, align 8
	call void @decimal.round_down(%decimal.Decimal* %19, i64 %20, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-6

if.done-6:
	ret void
}

define void @decimal.round_up(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca i8, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%4 = load i64, i64* %1, align 8
	%5 = icmp slt i64 %4, 0
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%8 = load i64, i64* %1, align 8
	; SelectorExpr
	%9 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%10 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %9, i32 0, i32 1
	%11 = load i64, i64* %10, align 8
	%12 = icmp sge i64 %8, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; ForStmt
	; i
	%15 = load i64, i64* %1, align 8
	%16 = sub i64 %15, 1
	store i64 %16, i64* %2
	br label %for.loop-4

for.loop-4:
	%17 = load i64, i64* %2, align 8
	%18 = icmp sge i64 %17, 0
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %for.body-5, label %for.done-8

for.body-5:
	; IfStmt
	; c
	; IndexExpr
	; SelectorExpr
	%21 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%22 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %21, i32 0, i32 0
	%23 = load i64, i64* %2, align 8
	%24 = trunc i64 %23 to i32
	%25 = getelementptr inbounds [384 x i8], [384 x i8]* %22, i32 0, i32 %24
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$185, i32 0, i32 0), i64 65}, i64 225, i64 20, i64 %23, i64 384)
	%26 = load i8, i8* %25, align 1
	store i8 %26, i8* %3
	%27 = load i8, i8* %3, align 1
	%28 = icmp ult i8 %27, 57
	%29 = zext i1 %28 to i8
	%30 = trunc i8 %29 to i1
	br i1 %30, label %if.then-6, label %if.done-7

if.then-6:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%31 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%32 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %31, i32 0, i32 0
	%33 = load i64, i64* %2, align 8
	%34 = trunc i64 %33 to i32
	%35 = getelementptr inbounds [384 x i8], [384 x i8]* %32, i32 0, i32 %34
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([66 x i8], [66 x i8]* @str$186, i32 0, i32 0), i64 65}, i64 226, i64 13, i64 %33, i64 384)
	%36 = load i8, i8* %35, align 1
	%37 = add i8 %36, 1
	store i8 %37, i8* %35
	; AssignStmt
	; SelectorExpr
	%38 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%39 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %38, i32 0, i32 1
	%40 = load i64, i64* %2, align 8
	%41 = add i64 %40, 1
	store i64 %41, i64* %39
	; ReturnStmt
	ret void

if.done-7:
	; AssignStmt
	%42 = load i64, i64* %2, align 8
	%43 = sub i64 %42, 1
	store i64 %43, i64* %2
	br label %for.loop-4

for.done-8:
	; AssignStmt
	; IndexExpr
	; SelectorExpr
	%44 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%45 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %44, i32 0, i32 0
	%46 = getelementptr inbounds [384 x i8], [384 x i8]* %45, i32 0, i32 0
	store i8 49, i8* %46
	; AssignStmt
	; SelectorExpr
	%47 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%48 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %47, i32 0, i32 1
	store i64 1, i64* %48
	; AssignStmt
	; SelectorExpr
	%49 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%50 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %49, i32 0, i32 2
	%51 = load i64, i64* %50, align 8
	%52 = add i64 %51, 1
	store i64 %52, i64* %50
	ret void
}

define void @decimal.round_down(%decimal.Decimal* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %decimal.Decimal*, align 16
	%1 = alloca i64, align 16
	store %decimal.Decimal* %_.0, %decimal.Decimal** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%2 = load i64, i64* %1, align 8
	%3 = icmp slt i64 %2, 0
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-2, label %cmp.or-1

cmp.or-1:
	%6 = load i64, i64* %1, align 8
	; SelectorExpr
	%7 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%8 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %7, i32 0, i32 1
	%9 = load i64, i64* %8, align 8
	%10 = icmp sge i64 %6, %9
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-2, label %if.done-3

if.then-2:
	; ReturnStmt
	ret void

if.done-3:
	; AssignStmt
	; SelectorExpr
	%13 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	%14 = getelementptr inbounds %decimal.Decimal, %decimal.Decimal* %13, i32 0, i32 1
	%15 = load i64, i64* %1, align 8
	store i64 %15, i64* %14
	%16 = load %decimal.Decimal*, %decimal.Decimal** %0, align 8
	call void @decimal.trim(%decimal.Decimal* %16, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define i8 @reflect.is_rune(%runtime.Type_Info* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Rune, i8}, align 16
	store %runtime.Type_Info* %_.0, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%10 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i32 0, i32 3
	; cast - union_cast
	; ZeroInit
	store {%runtime.Type_Info_Rune, i8} zeroinitializer, {%runtime.Type_Info_Rune, i8}* %3, align 1
	%12 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %11, i64 0, i32 2 ; UnionTagPtr
	%13 = load i64, i64* %12, align 8
	%14 = icmp eq i64 %13, 3
	br i1 %14, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%15 = getelementptr inbounds {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, i32 0, i32 0
	%16 = getelementptr inbounds {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, i32 0, i32 1
	%17 = bitcast {[0 x i64], [88 x i8], i64}* %11 to %runtime.Type_Info_Rune*
	%18 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %17, align 1
	store %runtime.Type_Info_Rune %18, %runtime.Type_Info_Rune* %15
	store i8 1, i8* %16
	br label %union_cast.end-4

union_cast.end-4:
	%19 = load {%runtime.Type_Info_Rune, i8}, {%runtime.Type_Info_Rune, i8}* %3, align 1
	%20 = extractvalue {%runtime.Type_Info_Rune, i8} %19, 1
	store i8 %20, i8* %1
	; ReturnStmt
	%21 = load i8, i8* %1, align 1
	ret i8 %21
}

define i8 @reflect.is_any(%runtime.Type_Info* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Any, i8}, align 16
	store %runtime.Type_Info* %_.0, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%10 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i32 0, i32 3
	; cast - union_cast
	; ZeroInit
	store {%runtime.Type_Info_Any, i8} zeroinitializer, {%runtime.Type_Info_Any, i8}* %3, align 1
	%12 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %11, i64 0, i32 2 ; UnionTagPtr
	%13 = load i64, i64* %12, align 8
	%14 = icmp eq i64 %13, 9
	br i1 %14, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%15 = getelementptr inbounds {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, i32 0, i32 0
	%16 = getelementptr inbounds {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, i32 0, i32 1
	%17 = bitcast {[0 x i64], [88 x i8], i64}* %11 to %runtime.Type_Info_Any*
	%18 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %17, align 1
	store %runtime.Type_Info_Any %18, %runtime.Type_Info_Any* %15
	store i8 1, i8* %16
	br label %union_cast.end-4

union_cast.end-4:
	%19 = load {%runtime.Type_Info_Any, i8}, {%runtime.Type_Info_Any, i8}* %3, align 1
	%20 = extractvalue {%runtime.Type_Info_Any, i8} %19, 1
	store i8 %20, i8* %1
	; ReturnStmt
	%21 = load i8, i8* %1, align 1
	ret i8 %21
}

define i8 @reflect.is_string(%runtime.Type_Info* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_String, i8}, align 16
	store %runtime.Type_Info* %_.0, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%10 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i32 0, i32 3
	; cast - union_cast
	; ZeroInit
	store {%runtime.Type_Info_String, i8} zeroinitializer, {%runtime.Type_Info_String, i8}* %3, align 1
	%12 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %11, i64 0, i32 2 ; UnionTagPtr
	%13 = load i64, i64* %12, align 8
	%14 = icmp eq i64 %13, 7
	br i1 %14, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%15 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, i32 0, i32 0
	%16 = getelementptr inbounds {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, i32 0, i32 1
	%17 = bitcast {[0 x i64], [88 x i8], i64}* %11 to %runtime.Type_Info_String*
	%18 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %17, align 1
	store %runtime.Type_Info_String %18, %runtime.Type_Info_String* %15
	store i8 1, i8* %16
	br label %union_cast.end-4

union_cast.end-4:
	%19 = load {%runtime.Type_Info_String, i8}, {%runtime.Type_Info_String, i8}* %3, align 1
	%20 = extractvalue {%runtime.Type_Info_String, i8} %19, 1
	store i8 %20, i8* %1
	; ReturnStmt
	%21 = load i8, i8* %1, align 1
	ret i8 %21
}

define i8 @reflect.is_enum(%runtime.Type_Info* %_.0, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %runtime.Type_Info*, align 16
	%1 = alloca i8, align 16
	%2 = alloca %runtime.Type_Info*, align 16
	%3 = alloca {%runtime.Type_Info_Enum, i8}, align 16
	store %runtime.Type_Info* %_.0, %runtime.Type_Info** %0
	; IfStmt
	%4 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%5 = icmp eq %runtime.Type_Info* %4, zeroinitializer
	%6 = zext i1 %5 to i8
	%7 = trunc i8 %6 to i1
	br i1 %7, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; ok
	; SelectorExpr
	; SelectorExpr
	%8 = load %runtime.Type_Info*, %runtime.Type_Info** %0, align 8
	%9 = call %runtime.Type_Info* @runtime.type_info_base(%runtime.Type_Info* %8)
	store %runtime.Type_Info* %9, %runtime.Type_Info** %2
	%10 = load %runtime.Type_Info*, %runtime.Type_Info** %2, align 8
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %10, i32 0, i32 3
	; cast - union_cast
	%12 = bitcast {%runtime.Type_Info_Enum, i8}* %3 to %..rawptr
	; ZeroInit
	%13 = call %..rawptr @mem.zero(%..rawptr %12, i64 48)
	%14 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %11, i64 0, i32 2 ; UnionTagPtr
	%15 = load i64, i64* %14, align 8
	%16 = icmp eq i64 %15, 19
	br i1 %16, label %union_cast.ok-3, label %union_cast.end-4

union_cast.ok-3:
	%17 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, i32 0, i32 0
	%18 = getelementptr inbounds {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, i32 0, i32 1
	%19 = bitcast {[0 x i64], [88 x i8], i64}* %11 to %runtime.Type_Info_Enum*
	%20 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %19, align 8
	store %runtime.Type_Info_Enum %20, %runtime.Type_Info_Enum* %17
	store i8 1, i8* %18
	br label %union_cast.end-4

union_cast.end-4:
	%21 = load {%runtime.Type_Info_Enum, i8}, {%runtime.Type_Info_Enum, i8}* %3, align 8
	%22 = extractvalue {%runtime.Type_Info_Enum, i8} %21, 1
	store i8 %22, i8* %1
	; ReturnStmt
	%23 = load i8, i8* %1, align 1
	ret i8 %23
}

define void @reflect.write_typeid(%strings.Builder* %_.0, %..typeid %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca %..typeid, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store %..typeid %_.1, %..typeid* %1
	%2 = load %strings.Builder*, %strings.Builder** %0, align 8
	%3 = load %..typeid, %..typeid* %1, align 8
	%4 = call %runtime.Type_Info* @runtime.__type_info_of(%..typeid %3)
	call void @reflect.write_type(%strings.Builder* %2, %runtime.Type_Info* %4, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	ret void
}

define void @reflect.write_type(%strings.Builder* %_.0, %runtime.Type_Info* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %strings.Builder*, align 16
	%1 = alloca %runtime.Type_Info*, align 16
	%2 = alloca %runtime.Type_Info_Named, align 16
	%3 = alloca %runtime.Type_Info_Integer, align 16
	%4 = alloca %runtime.Type_Info_Rune, align 16
	%5 = alloca %runtime.Type_Info_Float, align 16
	%6 = alloca %runtime.Type_Info_Complex, align 16
	%7 = alloca %runtime.Type_Info_String, align 16
	%8 = alloca %runtime.Type_Info_Boolean, align 16
	%9 = alloca %runtime.Type_Info_Any, align 16
	%10 = alloca %runtime.Type_Info_Type_Id, align 16
	%11 = alloca %runtime.Type_Info_Pointer, align 16
	%12 = alloca %runtime.Type_Info_Procedure, align 16
	%13 = alloca %runtime.Type_Info_Tuple, align 16
	%14 = alloca {%runtime.Type_Info_Tuple, i8}, align 16
	%15 = alloca %runtime.Type_Info*, align 16
	%16 = alloca i64, align 16
	%17 = alloca i64, align 16
	%18 = alloca i64, align 16
	%19 = alloca %runtime.Type_Info_Tuple, align 16
	%20 = alloca i64, align 16
	%21 = alloca %..string, align 16
	%22 = alloca i64, align 16
	%23 = alloca i64, align 16
	%24 = alloca i64, align 16
	%25 = alloca %runtime.Type_Info*, align 16
	%26 = alloca %runtime.Type_Info_Array, align 16
	%27 = alloca %runtime.Type_Info_Dynamic_Array, align 16
	%28 = alloca %runtime.Type_Info_Slice, align 16
	%29 = alloca %runtime.Type_Info_Map, align 16
	%30 = alloca %runtime.Type_Info_Struct, align 16
	%31 = alloca %..string, align 16
	%32 = alloca i64, align 16
	%33 = alloca i64, align 16
	%34 = alloca i64, align 16
	%35 = alloca %runtime.Type_Info_Union, align 16
	%36 = alloca %runtime.Type_Info*, align 16
	%37 = alloca i64, align 16
	%38 = alloca i64, align 16
	%39 = alloca i64, align 16
	%40 = alloca %runtime.Type_Info_Enum, align 16
	%41 = alloca %..string, align 16
	%42 = alloca i64, align 16
	%43 = alloca i64, align 16
	%44 = alloca i64, align 16
	%45 = alloca %runtime.Type_Info_Bit_Field, align 16
	%46 = alloca %..string, align 16
	%47 = alloca i64, align 16
	%48 = alloca i64, align 16
	%49 = alloca i64, align 16
	%50 = alloca %runtime.Type_Info_Bit_Set, align 16
	%51 = alloca %runtime.Type_Info_Opaque, align 16
	%52 = alloca %runtime.Type_Info_Simd_Vector, align 16
	store %strings.Builder* %_.0, %strings.Builder** %0
	store %runtime.Type_Info* %_.1, %runtime.Type_Info** %1
	; IfStmt
	%53 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%54 = icmp eq %runtime.Type_Info* %53, zeroinitializer
	%55 = zext i1 %54 to i8
	%56 = trunc i8 %55 to i1
	br i1 %56, label %if.then-1, label %if.done-2

if.then-1:
	%57 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %57, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$187, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; ReturnStmt
	ret void

if.done-2:
	; TypeSwitchStmt
	; SelectorExpr
	%58 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%59 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %58, i32 0, i32 3
	; get union's tag
	%60 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %59, i64 0, i32 2 ; UnionTagPtr
	%61 = load i64, i64* %60, align 8
	%62 = bitcast {[0 x i64], [88 x i8], i64}* %59 to %..rawptr
	%63 = icmp eq i64 %61, 1
	br i1 %63, label %typeswitch.body-4, label %typeswitch.next-3

typeswitch.next-3:
	%64 = icmp eq i64 %61, 2
	br i1 %64, label %typeswitch.body-6, label %typeswitch.next-5

typeswitch.body-4:
	%65 = bitcast %..rawptr %62 to %runtime.Type_Info_Named*
	%66 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %65, align 8
	store %runtime.Type_Info_Named %66, %runtime.Type_Info_Named* %2
	%67 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%68 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %2, i32 0, i32 0
	%69 = load %..string, %..string* %68, align 8
	call void @strings.write_string(%strings.Builder* %67, %..string %69, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-5:
	%70 = icmp eq i64 %61, 3
	br i1 %70, label %typeswitch.body-23, label %typeswitch.next-22

typeswitch.body-6:
	%71 = bitcast %..rawptr %62 to %runtime.Type_Info_Integer*
	%72 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %71, align 1
	store %runtime.Type_Info_Integer %72, %runtime.Type_Info_Integer* %3
	; SwitchStmt
	; SelectorExpr
	%73 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%74 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %73, i32 0, i32 2
	%75 = load %..typeid, %..typeid* %74, align 8
	%76 = icmp eq %..typeid %75, 4683743612465315844
	br i1 %76, label %switch.case.body-8, label %switch.case.next-7

switch.case.next-7:
	%77 = icmp eq %..typeid %75, 72057594037928008
	br i1 %77, label %switch.fall.body-10, label %switch.case.next-9

switch.case.body-8:
	%78 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %78, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$188, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-21

switch.case.next-9:
	%79 = icmp eq %..typeid %75, 72057594037927989
	br i1 %79, label %switch.fall.body-12, label %switch.case.next-11

switch.fall.body-10:
	%80 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %80, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$189, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-21

switch.case.next-11:
	%81 = load %strings.Builder*, %strings.Builder** %0, align 8
	; TernaryExpr
	; SelectorExpr
	%82 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %3, i32 0, i32 0
	%83 = load i8, i8* %82, align 1
	%84 = trunc i8 %83 to i1
	br i1 %84, label %if.then-13, label %if.else-14

switch.fall.body-12:
	%85 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %85, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$18a, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-21

if.then-13:
	br label %if.done-15

if.else-14:
	br label %if.done-15

if.done-15:
	%86 = phi i32 [ 105, %if.then-13 ], [ 117, %if.else-14 ]
	%87 = trunc i32 %86 to i8
	call void @strings.write_byte(%strings.Builder* %81, i8 %87, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%88 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%89 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%90 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %89, i32 0, i32 0
	%91 = load i64, i64* %90, align 8
	%92 = mul i64 8, %91
	%93 = bitcast i64 %92 to i64
	call void @strings.write_i64(%strings.Builder* %88, i64 %93, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SwitchStmt
	; SelectorExpr
	%94 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %3, i32 0, i32 1
	%95 = load i8, i8* %94, align 1
	%96 = icmp eq i8 %95, 1
	br i1 %96, label %switch.case.body-17, label %switch.case.next-16

switch.case.next-16:
	%97 = icmp eq i8 %95, 2
	br i1 %97, label %switch.fall.body-19, label %switch.case.next-18

switch.case.body-17:
	%98 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %98, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$18b, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-20

switch.case.next-18:
	br label %switch.done-20

switch.fall.body-19:
	%99 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %99, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$18c, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-20

switch.done-20:
	br label %switch.done-21

switch.done-21:
	br label %typeswitch.done-136

typeswitch.next-22:
	%100 = icmp eq i64 %61, 4
	br i1 %100, label %typeswitch.body-25, label %typeswitch.next-24

typeswitch.body-23:
	%101 = bitcast %..rawptr %62 to %runtime.Type_Info_Rune*
	%102 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %101, align 1
	store %runtime.Type_Info_Rune %102, %runtime.Type_Info_Rune* %4
	%103 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %103, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$18d, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-24:
	%104 = icmp eq i64 %61, 5
	br i1 %104, label %typeswitch.body-27, label %typeswitch.next-26

typeswitch.body-25:
	%105 = bitcast %..rawptr %62 to %runtime.Type_Info_Float*
	%106 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %105, align 1
	store %runtime.Type_Info_Float %106, %runtime.Type_Info_Float* %5
	%107 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %107, i8 102, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%108 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%109 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%110 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %109, i32 0, i32 0
	%111 = load i64, i64* %110, align 8
	%112 = mul i64 8, %111
	%113 = bitcast i64 %112 to i64
	call void @strings.write_i64(%strings.Builder* %108, i64 %113, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-26:
	%114 = icmp eq i64 %61, 7
	br i1 %114, label %typeswitch.body-29, label %typeswitch.next-28

typeswitch.body-27:
	%115 = bitcast %..rawptr %62 to %runtime.Type_Info_Complex*
	%116 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %115, align 1
	store %runtime.Type_Info_Complex %116, %runtime.Type_Info_Complex* %6
	%117 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %117, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$18e, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%118 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%119 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%120 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %119, i32 0, i32 0
	%121 = load i64, i64* %120, align 8
	%122 = mul i64 8, %121
	%123 = bitcast i64 %122 to i64
	call void @strings.write_i64(%strings.Builder* %118, i64 %123, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-28:
	%124 = icmp eq i64 %61, 8
	br i1 %124, label %typeswitch.body-34, label %typeswitch.next-33

typeswitch.body-29:
	%125 = bitcast %..rawptr %62 to %runtime.Type_Info_String*
	%126 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %125, align 1
	store %runtime.Type_Info_String %126, %runtime.Type_Info_String* %7
	; IfStmt
	; SelectorExpr
	%127 = getelementptr inbounds %runtime.Type_Info_String, %runtime.Type_Info_String* %7, i32 0, i32 0
	%128 = load i8, i8* %127, align 1
	%129 = trunc i8 %128 to i1
	br i1 %129, label %if.then-30, label %if.else-31

if.then-30:
	%130 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %130, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$18f, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-32

if.else-31:
	%131 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %131, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$190, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-32

if.done-32:
	br label %typeswitch.done-136

typeswitch.next-33:
	%132 = icmp eq i64 %61, 9
	br i1 %132, label %typeswitch.body-39, label %typeswitch.next-38

typeswitch.body-34:
	%133 = bitcast %..rawptr %62 to %runtime.Type_Info_Boolean*
	%134 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %133, align 1
	store %runtime.Type_Info_Boolean %134, %runtime.Type_Info_Boolean* %8
	; SwitchStmt
	; SelectorExpr
	%135 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%136 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %135, i32 0, i32 2
	%137 = load %..typeid, %..typeid* %136, align 8
	%138 = icmp eq %..typeid %137, 504403158265495572
	br i1 %138, label %switch.case.body-36, label %switch.case.next-35

switch.case.next-35:
	%139 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %139, i8 98, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%140 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%141 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%142 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i32 0, i32 0
	%143 = load i64, i64* %142, align 8
	%144 = mul i64 8, %143
	%145 = bitcast i64 %144 to i64
	call void @strings.write_i64(%strings.Builder* %140, i64 %145, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-37

switch.case.body-36:
	%146 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %146, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$191, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-37

switch.done-37:
	br label %typeswitch.done-136

typeswitch.next-38:
	%147 = icmp eq i64 %61, 10
	br i1 %147, label %typeswitch.body-41, label %typeswitch.next-40

typeswitch.body-39:
	%148 = bitcast %..rawptr %62 to %runtime.Type_Info_Any*
	%149 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %148, align 1
	store %runtime.Type_Info_Any %149, %runtime.Type_Info_Any* %9
	%150 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %150, %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$192, i32 0, i32 0), i64 3}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-40:
	%151 = icmp eq i64 %61, 11
	br i1 %151, label %typeswitch.body-43, label %typeswitch.next-42

typeswitch.body-41:
	%152 = bitcast %..rawptr %62 to %runtime.Type_Info_Type_Id*
	%153 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %152, align 1
	store %runtime.Type_Info_Type_Id %153, %runtime.Type_Info_Type_Id* %10
	%154 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %154, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$193, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-42:
	%155 = icmp eq i64 %61, 12
	br i1 %155, label %typeswitch.body-48, label %typeswitch.next-47

typeswitch.body-43:
	%156 = bitcast %..rawptr %62 to %runtime.Type_Info_Pointer*
	%157 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %156, align 8
	store %runtime.Type_Info_Pointer %157, %runtime.Type_Info_Pointer* %11
	; IfStmt
	; SelectorExpr
	%158 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i32 0, i32 0
	%159 = load %runtime.Type_Info*, %runtime.Type_Info** %158, align 8
	%160 = icmp eq %runtime.Type_Info* %159, zeroinitializer
	%161 = zext i1 %160 to i8
	%162 = trunc i8 %161 to i1
	br i1 %162, label %if.then-44, label %if.else-45

if.then-44:
	%163 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %163, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$194, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-46

if.else-45:
	%164 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %164, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$195, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%165 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%166 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %11, i32 0, i32 0
	%167 = load %runtime.Type_Info*, %runtime.Type_Info** %166, align 8
	call void @reflect.write_type(%strings.Builder* %165, %runtime.Type_Info* %167, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-46

if.done-46:
	br label %typeswitch.done-136

typeswitch.next-47:
	%168 = icmp eq i64 %61, 16
	br i1 %168, label %typeswitch.body-62, label %typeswitch.next-61

typeswitch.body-48:
	%169 = bitcast %..rawptr %62 to %runtime.Type_Info_Procedure*
	%170 = load %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %169, align 8
	store %runtime.Type_Info_Procedure %170, %runtime.Type_Info_Procedure* %12
	%171 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %171, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$196, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%172 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i32 0, i32 0
	%173 = load %runtime.Type_Info*, %runtime.Type_Info** %172, align 8
	%174 = icmp eq %runtime.Type_Info* %173, zeroinitializer
	%175 = zext i1 %174 to i8
	%176 = trunc i8 %175 to i1
	br i1 %176, label %if.then-49, label %if.else-50

if.then-49:
	%177 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %177, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$197, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-58

if.else-50:
	; t
	; SelectorExpr
	; SelectorExpr
	%178 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i32 0, i32 0
	%179 = load %runtime.Type_Info*, %runtime.Type_Info** %178, align 8
	%180 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %179, i32 0, i32 3
	; cast - union_cast
	%181 = bitcast {%runtime.Type_Info_Tuple, i8}* %14 to %..rawptr
	; ZeroInit
	%182 = call %..rawptr @mem.zero(%..rawptr %181, i64 40)
	%183 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %180, i64 0, i32 2 ; UnionTagPtr
	%184 = load i64, i64* %183, align 8
	%185 = icmp eq i64 %184, 16
	br i1 %185, label %union_cast.ok-51, label %union_cast.end-52

union_cast.ok-51:
	%186 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i32 0, i32 0
	%187 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i32 0, i32 1
	%188 = bitcast {[0 x i64], [88 x i8], i64}* %180 to %runtime.Type_Info_Tuple*
	%189 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %188, align 8
	store %runtime.Type_Info_Tuple %189, %runtime.Type_Info_Tuple* %186
	store i8 1, i8* %187
	br label %union_cast.end-52

union_cast.end-52:
	%190 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i32 0, i32 1
	%191 = load i8, i8* %190, align 1
	%192 = trunc i8 %191 to i1
	call void @runtime.type_assertion_check(i1 %192, %..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$198, i32 0, i32 0), i64 63}, i64 350, i64 21, %..typeid 1224979098644774922, %..typeid 3458764513820540972)
	%193 = getelementptr inbounds {%runtime.Type_Info_Tuple, i8}, {%runtime.Type_Info_Tuple, i8}* %14, i32 0, i32 0
	%194 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %193, align 8
	store %runtime.Type_Info_Tuple %194, %runtime.Type_Info_Tuple* %13
	%195 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %195, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$199, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; t
	; ZeroInit
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %15, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %16, align 1
	; SelectorExpr
	%196 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %13, i32 0, i32 0
	%197 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %196, align 8
	%198 = extractvalue {%runtime.Type_Info**, i64} %197, 1
	store i64 %198, i64* %17
	store i64 -1, i64* %18
	br label %for.index.loop-53

for.index.loop-53:
	%199 = load i64, i64* %18, align 8
	%200 = add i64 %199, 1
	store i64 %200, i64* %18
	%201 = load i64, i64* %17, align 8
	%202 = icmp slt i64 %200, %201
	br i1 %202, label %for.index.body-54, label %for.index.done-57

for.index.body-54:
	%203 = load i64, i64* %18, align 8
	%204 = extractvalue {%runtime.Type_Info**, i64} %197, 0
	%205 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %204, i64 %203
	%206 = load %runtime.Type_Info*, %runtime.Type_Info** %205, align 8
	store %runtime.Type_Info* %206, %runtime.Type_Info** %15
	store i64 %203, i64* %16
	; IfStmt
	%207 = load i64, i64* %16, align 8
	%208 = icmp sgt i64 %207, 0
	%209 = zext i1 %208 to i8
	%210 = trunc i8 %209 to i1
	br i1 %210, label %if.then-55, label %if.done-56

if.then-55:
	%211 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %211, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$19a, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-56

if.done-56:
	%212 = load %strings.Builder*, %strings.Builder** %0, align 8
	%213 = load %runtime.Type_Info*, %runtime.Type_Info** %15, align 8
	call void @reflect.write_type(%strings.Builder* %212, %runtime.Type_Info* %213, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-53

for.index.done-57:
	%214 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %214, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$19b, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-58

if.done-58:
	; IfStmt
	; SelectorExpr
	%215 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i32 0, i32 1
	%216 = load %runtime.Type_Info*, %runtime.Type_Info** %215, align 8
	%217 = icmp ne %runtime.Type_Info* %216, zeroinitializer
	%218 = zext i1 %217 to i8
	%219 = trunc i8 %218 to i1
	br i1 %219, label %if.then-59, label %if.done-60

if.then-59:
	%220 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %220, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$19c, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%221 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%222 = getelementptr inbounds %runtime.Type_Info_Procedure, %runtime.Type_Info_Procedure* %12, i32 0, i32 1
	%223 = load %runtime.Type_Info*, %runtime.Type_Info** %222, align 8
	call void @reflect.write_type(%strings.Builder* %221, %runtime.Type_Info* %223, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-60

if.done-60:
	br label %typeswitch.done-136

typeswitch.next-61:
	%224 = icmp eq i64 %61, 13
	br i1 %224, label %typeswitch.body-75, label %typeswitch.next-74

typeswitch.body-62:
	%225 = bitcast %..rawptr %62 to %runtime.Type_Info_Tuple*
	%226 = load %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %225, align 8
	store %runtime.Type_Info_Tuple %226, %runtime.Type_Info_Tuple* %19
	; count
	; SelectorExpr
	%227 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i32 0, i32 1
	%228 = load {%..string*, i64}, {%..string*, i64}* %227, align 8
	%229 = extractvalue {%..string*, i64} %228, 1
	store i64 %229, i64* %20
	; IfStmt
	%230 = load i64, i64* %20, align 8
	%231 = icmp ne i64 %230, 1
	%232 = zext i1 %231 to i8
	%233 = trunc i8 %232 to i1
	br i1 %233, label %if.then-63, label %if.done-64

if.then-63:
	%234 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %234, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$19d, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-64

if.done-64:
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %21, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %22, align 1
	; SelectorExpr
	%235 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i32 0, i32 1
	%236 = load {%..string*, i64}, {%..string*, i64}* %235, align 8
	%237 = extractvalue {%..string*, i64} %236, 1
	store i64 %237, i64* %23
	store i64 -1, i64* %24
	br label %for.index.loop-65

for.index.loop-65:
	%238 = load i64, i64* %24, align 8
	%239 = add i64 %238, 1
	store i64 %239, i64* %24
	%240 = load i64, i64* %23, align 8
	%241 = icmp slt i64 %239, %240
	br i1 %241, label %for.index.body-66, label %for.index.done-71

for.index.body-66:
	%242 = load i64, i64* %24, align 8
	%243 = extractvalue {%..string*, i64} %236, 0
	%244 = getelementptr inbounds %..string, %..string* %243, i64 %242
	%245 = load %..string, %..string* %244, align 8
	store %..string %245, %..string* %21
	store i64 %242, i64* %22
	; IfStmt
	%246 = load i64, i64* %22, align 8
	%247 = icmp sgt i64 %246, 0
	%248 = zext i1 %247 to i8
	%249 = trunc i8 %248 to i1
	br i1 %249, label %if.then-67, label %if.done-68

if.then-67:
	%250 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %250, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$19e, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-68

if.done-68:
	; t
	; IndexExpr
	; SelectorExpr
	%251 = getelementptr inbounds %runtime.Type_Info_Tuple, %runtime.Type_Info_Tuple* %19, i32 0, i32 0
	%252 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %251, align 8
	%253 = extractvalue {%runtime.Type_Info**, i64} %252, 0
	%254 = load i64, i64* %22, align 8
	%255 = extractvalue {%runtime.Type_Info**, i64} %252, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$19f, i32 0, i32 0), i64 63}, i64 368, i64 20, i64 %254, i64 %255)
	%256 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %253, i64 %254
	%257 = load %runtime.Type_Info*, %runtime.Type_Info** %256, align 8
	store %runtime.Type_Info* %257, %runtime.Type_Info** %25
	; IfStmt
	%258 = load %..string, %..string* %21, align 8
	%259 = extractvalue %..string %258, 1
	%260 = icmp sgt i64 %259, 0
	%261 = zext i1 %260 to i8
	%262 = trunc i8 %261 to i1
	br i1 %262, label %if.then-69, label %if.done-70

if.then-69:
	%263 = load %strings.Builder*, %strings.Builder** %0, align 8
	%264 = load %..string, %..string* %21, align 8
	call void @strings.write_string(%strings.Builder* %263, %..string %264, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%265 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %265, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1a0, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-70

if.done-70:
	%266 = load %strings.Builder*, %strings.Builder** %0, align 8
	%267 = load %runtime.Type_Info*, %runtime.Type_Info** %25, align 8
	call void @reflect.write_type(%strings.Builder* %266, %runtime.Type_Info* %267, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-65

for.index.done-71:
	; IfStmt
	%268 = load i64, i64* %20, align 8
	%269 = icmp ne i64 %268, 1
	%270 = zext i1 %269 to i8
	%271 = trunc i8 %270 to i1
	br i1 %271, label %if.then-72, label %if.done-73

if.then-72:
	%272 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %272, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1a1, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-73

if.done-73:
	br label %typeswitch.done-136

typeswitch.next-74:
	%273 = icmp eq i64 %61, 14
	br i1 %273, label %typeswitch.body-77, label %typeswitch.next-76

typeswitch.body-75:
	%274 = bitcast %..rawptr %62 to %runtime.Type_Info_Array*
	%275 = load %runtime.Type_Info_Array, %runtime.Type_Info_Array* %274, align 8
	store %runtime.Type_Info_Array %275, %runtime.Type_Info_Array* %26
	%276 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %276, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1a2, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%277 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%278 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i32 0, i32 2
	%279 = load i64, i64* %278, align 8
	%280 = bitcast i64 %279 to i64
	call void @strings.write_i64(%strings.Builder* %277, i64 %280, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%281 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %281, %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1a3, i32 0, i32 0), i64 1}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%282 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%283 = getelementptr inbounds %runtime.Type_Info_Array, %runtime.Type_Info_Array* %26, i32 0, i32 0
	%284 = load %runtime.Type_Info*, %runtime.Type_Info** %283, align 8
	call void @reflect.write_type(%strings.Builder* %282, %runtime.Type_Info* %284, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-76:
	%285 = icmp eq i64 %61, 15
	br i1 %285, label %typeswitch.body-79, label %typeswitch.next-78

typeswitch.body-77:
	%286 = bitcast %..rawptr %62 to %runtime.Type_Info_Dynamic_Array*
	%287 = load %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %286, align 8
	store %runtime.Type_Info_Dynamic_Array %287, %runtime.Type_Info_Dynamic_Array* %27
	%288 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %288, %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$1a4, i32 0, i32 0), i64 9}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%289 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%290 = getelementptr inbounds %runtime.Type_Info_Dynamic_Array, %runtime.Type_Info_Dynamic_Array* %27, i32 0, i32 0
	%291 = load %runtime.Type_Info*, %runtime.Type_Info** %290, align 8
	call void @reflect.write_type(%strings.Builder* %289, %runtime.Type_Info* %291, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-78:
	%292 = icmp eq i64 %61, 20
	br i1 %292, label %typeswitch.body-81, label %typeswitch.next-80

typeswitch.body-79:
	%293 = bitcast %..rawptr %62 to %runtime.Type_Info_Slice*
	%294 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %293, align 8
	store %runtime.Type_Info_Slice %294, %runtime.Type_Info_Slice* %28
	%295 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %295, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1a5, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%296 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%297 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %28, i32 0, i32 0
	%298 = load %runtime.Type_Info*, %runtime.Type_Info** %297, align 8
	call void @reflect.write_type(%strings.Builder* %296, %runtime.Type_Info* %298, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-80:
	%299 = icmp eq i64 %61, 17
	br i1 %299, label %typeswitch.body-83, label %typeswitch.next-82

typeswitch.body-81:
	%300 = bitcast %..rawptr %62 to %runtime.Type_Info_Map*
	%301 = load %runtime.Type_Info_Map, %runtime.Type_Info_Map* %300, align 8
	store %runtime.Type_Info_Map %301, %runtime.Type_Info_Map* %29
	%302 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %302, %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1a6, i32 0, i32 0), i64 4}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%303 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%304 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i32 0, i32 0
	%305 = load %runtime.Type_Info*, %runtime.Type_Info** %304, align 8
	call void @reflect.write_type(%strings.Builder* %303, %runtime.Type_Info* %305, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%306 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %306, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%307 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%308 = getelementptr inbounds %runtime.Type_Info_Map, %runtime.Type_Info_Map* %29, i32 0, i32 1
	%309 = load %runtime.Type_Info*, %runtime.Type_Info** %308, align 8
	call void @reflect.write_type(%strings.Builder* %307, %runtime.Type_Info* %309, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-82:
	%310 = icmp eq i64 %61, 18
	br i1 %310, label %typeswitch.body-96, label %typeswitch.next-95

typeswitch.body-83:
	%311 = bitcast %..rawptr %62 to %runtime.Type_Info_Struct*
	%312 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %311, align 8
	store %runtime.Type_Info_Struct %312, %runtime.Type_Info_Struct* %30
	%313 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %313, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1a7, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%314 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i32 0, i32 5
	%315 = load i8, i8* %314, align 1
	%316 = trunc i8 %315 to i1
	br i1 %316, label %if.then-84, label %if.done-85

if.then-84:
	%317 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %317, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$1a8, i32 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-85

if.done-85:
	; IfStmt
	; SelectorExpr
	%318 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i32 0, i32 6
	%319 = load i8, i8* %318, align 1
	%320 = trunc i8 %319 to i1
	br i1 %320, label %if.then-86, label %if.done-87

if.then-86:
	%321 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %321, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1a9, i32 0, i32 0), i64 11}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-87

if.done-87:
	; IfStmt
	; SelectorExpr
	%322 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i32 0, i32 7
	%323 = load i8, i8* %322, align 1
	%324 = trunc i8 %323 to i1
	br i1 %324, label %if.then-88, label %if.done-89

if.then-88:
	%325 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %325, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1aa, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%326 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%327 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%328 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %327, i32 0, i32 1
	%329 = load i64, i64* %328, align 8
	%330 = bitcast i64 %329 to i64
	call void @strings.write_i64(%strings.Builder* %326, i64 %330, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%331 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %331, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-89

if.done-89:
	%332 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %332, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %31, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %32, align 1
	; SelectorExpr
	%333 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i32 0, i32 1
	%334 = load {%..string*, i64}, {%..string*, i64}* %333, align 8
	%335 = extractvalue {%..string*, i64} %334, 1
	store i64 %335, i64* %33
	store i64 -1, i64* %34
	br label %for.index.loop-90

for.index.loop-90:
	%336 = load i64, i64* %34, align 8
	%337 = add i64 %336, 1
	store i64 %337, i64* %34
	%338 = load i64, i64* %33, align 8
	%339 = icmp slt i64 %337, %338
	br i1 %339, label %for.index.body-91, label %for.index.done-94

for.index.body-91:
	%340 = load i64, i64* %34, align 8
	%341 = extractvalue {%..string*, i64} %334, 0
	%342 = getelementptr inbounds %..string, %..string* %341, i64 %340
	%343 = load %..string, %..string* %342, align 8
	store %..string %343, %..string* %31
	store i64 %340, i64* %32
	; IfStmt
	%344 = load i64, i64* %32, align 8
	%345 = icmp sgt i64 %344, 0
	%346 = zext i1 %345 to i8
	%347 = trunc i8 %346 to i1
	br i1 %347, label %if.then-92, label %if.done-93

if.then-92:
	%348 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %348, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1ab, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-93

if.done-93:
	%349 = load %strings.Builder*, %strings.Builder** %0, align 8
	%350 = load %..string, %..string* %31, align 8
	call void @strings.write_string(%strings.Builder* %349, %..string %350, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%351 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %351, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1ac, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%352 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	; SelectorExpr
	%353 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %30, i32 0, i32 0
	%354 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %353, align 8
	%355 = extractvalue {%runtime.Type_Info**, i64} %354, 0
	%356 = load i64, i64* %32, align 8
	%357 = extractvalue {%runtime.Type_Info**, i64} %354, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1ad, i32 0, i32 0), i64 63}, i64 410, i64 31, i64 %356, i64 %357)
	%358 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %355, i64 %356
	%359 = load %runtime.Type_Info*, %runtime.Type_Info** %358, align 8
	call void @reflect.write_type(%strings.Builder* %352, %runtime.Type_Info* %359, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-90

for.index.done-94:
	%360 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %360, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-95:
	%361 = icmp eq i64 %61, 19
	br i1 %361, label %typeswitch.body-105, label %typeswitch.next-104

typeswitch.body-96:
	%362 = bitcast %..rawptr %62 to %runtime.Type_Info_Union*
	%363 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %362, align 8
	store %runtime.Type_Info_Union %363, %runtime.Type_Info_Union* %35
	%364 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %364, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$1ae, i32 0, i32 0), i64 6}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%365 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i32 0, i32 3
	%366 = load i8, i8* %365, align 1
	%367 = trunc i8 %366 to i1
	br i1 %367, label %if.then-97, label %if.done-98

if.then-97:
	%368 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %368, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1af, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%369 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%370 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%371 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %370, i32 0, i32 1
	%372 = load i64, i64* %371, align 8
	%373 = bitcast i64 %372 to i64
	call void @strings.write_i64(%strings.Builder* %369, i64 %373, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%374 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %374, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-98

if.done-98:
	%375 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %375, i8 123, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; variant
	; ZeroInit
	store %runtime.Type_Info* zeroinitializer, %runtime.Type_Info** %36, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %37, align 1
	; SelectorExpr
	%376 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %35, i32 0, i32 0
	%377 = load {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %376, align 8
	%378 = extractvalue {%runtime.Type_Info**, i64} %377, 1
	store i64 %378, i64* %38
	store i64 -1, i64* %39
	br label %for.index.loop-99

for.index.loop-99:
	%379 = load i64, i64* %39, align 8
	%380 = add i64 %379, 1
	store i64 %380, i64* %39
	%381 = load i64, i64* %38, align 8
	%382 = icmp slt i64 %380, %381
	br i1 %382, label %for.index.body-100, label %for.index.done-103

for.index.body-100:
	%383 = load i64, i64* %39, align 8
	%384 = extractvalue {%runtime.Type_Info**, i64} %377, 0
	%385 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %384, i64 %383
	%386 = load %runtime.Type_Info*, %runtime.Type_Info** %385, align 8
	store %runtime.Type_Info* %386, %runtime.Type_Info** %36
	store i64 %383, i64* %37
	; IfStmt
	%387 = load i64, i64* %37, align 8
	%388 = icmp sgt i64 %387, 0
	%389 = zext i1 %388 to i8
	%390 = trunc i8 %389 to i1
	br i1 %390, label %if.then-101, label %if.done-102

if.then-101:
	%391 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %391, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1b0, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-102

if.done-102:
	%392 = load %strings.Builder*, %strings.Builder** %0, align 8
	%393 = load %runtime.Type_Info*, %runtime.Type_Info** %36, align 8
	call void @reflect.write_type(%strings.Builder* %392, %runtime.Type_Info* %393, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-99

for.index.done-103:
	%394 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %394, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-104:
	%395 = icmp eq i64 %61, 21
	br i1 %395, label %typeswitch.body-112, label %typeswitch.next-111

typeswitch.body-105:
	%396 = bitcast %..rawptr %62 to %runtime.Type_Info_Enum*
	%397 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %396, align 8
	store %runtime.Type_Info_Enum %397, %runtime.Type_Info_Enum* %40
	%398 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %398, %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$1b1, i32 0, i32 0), i64 5}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%399 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%400 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i32 0, i32 0
	%401 = load %runtime.Type_Info*, %runtime.Type_Info** %400, align 8
	call void @reflect.write_type(%strings.Builder* %399, %runtime.Type_Info* %401, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%402 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %402, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1b2, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %41, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %42, align 1
	; SelectorExpr
	%403 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %40, i32 0, i32 1
	%404 = load {%..string*, i64}, {%..string*, i64}* %403, align 8
	%405 = extractvalue {%..string*, i64} %404, 1
	store i64 %405, i64* %43
	store i64 -1, i64* %44
	br label %for.index.loop-106

for.index.loop-106:
	%406 = load i64, i64* %44, align 8
	%407 = add i64 %406, 1
	store i64 %407, i64* %44
	%408 = load i64, i64* %43, align 8
	%409 = icmp slt i64 %407, %408
	br i1 %409, label %for.index.body-107, label %for.index.done-110

for.index.body-107:
	%410 = load i64, i64* %44, align 8
	%411 = extractvalue {%..string*, i64} %404, 0
	%412 = getelementptr inbounds %..string, %..string* %411, i64 %410
	%413 = load %..string, %..string* %412, align 8
	store %..string %413, %..string* %41
	store i64 %410, i64* %42
	; IfStmt
	%414 = load i64, i64* %42, align 8
	%415 = icmp sgt i64 %414, 0
	%416 = zext i1 %415 to i8
	%417 = trunc i8 %416 to i1
	br i1 %417, label %if.then-108, label %if.done-109

if.then-108:
	%418 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %418, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1b3, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-109

if.done-109:
	%419 = load %strings.Builder*, %strings.Builder** %0, align 8
	%420 = load %..string, %..string* %41, align 8
	call void @strings.write_string(%strings.Builder* %419, %..string %420, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-106

for.index.done-110:
	%421 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %421, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-111:
	%422 = icmp eq i64 %61, 22
	br i1 %422, label %typeswitch.body-121, label %typeswitch.next-120

typeswitch.body-112:
	%423 = bitcast %..rawptr %62 to %runtime.Type_Info_Bit_Field*
	%424 = load %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %423, align 8
	store %runtime.Type_Info_Bit_Field %424, %runtime.Type_Info_Bit_Field* %45
	%425 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %425, %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1b4, i32 0, i32 0), i64 10}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; IfStmt
	; SelectorExpr
	%426 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%427 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %426, i32 0, i32 1
	%428 = load i64, i64* %427, align 8
	%429 = icmp ne i64 %428, 1
	%430 = zext i1 %429 to i8
	%431 = trunc i8 %430 to i1
	br i1 %431, label %if.then-113, label %if.done-114

if.then-113:
	%432 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %432, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1b5, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%433 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%434 = load %runtime.Type_Info*, %runtime.Type_Info** %1, align 8
	%435 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %434, i32 0, i32 1
	%436 = load i64, i64* %435, align 8
	%437 = bitcast i64 %436 to i64
	call void @strings.write_i64(%strings.Builder* %433, i64 %437, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%438 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %438, i8 32, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-114

if.done-114:
	%439 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %439, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1b6, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; RangeStmt
	; name
	; ZeroInit
	store %..string zeroinitializer, %..string* %46, align 1
	; i
	; ZeroInit
	store i64 zeroinitializer, i64* %47, align 1
	; SelectorExpr
	%440 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i32 0, i32 0
	%441 = load {%..string*, i64}, {%..string*, i64}* %440, align 8
	%442 = extractvalue {%..string*, i64} %441, 1
	store i64 %442, i64* %48
	store i64 -1, i64* %49
	br label %for.index.loop-115

for.index.loop-115:
	%443 = load i64, i64* %49, align 8
	%444 = add i64 %443, 1
	store i64 %444, i64* %49
	%445 = load i64, i64* %48, align 8
	%446 = icmp slt i64 %444, %445
	br i1 %446, label %for.index.body-116, label %for.index.done-119

for.index.body-116:
	%447 = load i64, i64* %49, align 8
	%448 = extractvalue {%..string*, i64} %441, 0
	%449 = getelementptr inbounds %..string, %..string* %448, i64 %447
	%450 = load %..string, %..string* %449, align 8
	store %..string %450, %..string* %46
	store i64 %447, i64* %47
	; IfStmt
	%451 = load i64, i64* %47, align 8
	%452 = icmp sgt i64 %451, 0
	%453 = zext i1 %452 to i8
	%454 = trunc i8 %453 to i1
	br i1 %454, label %if.then-117, label %if.done-118

if.then-117:
	%455 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %455, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1b7, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-118

if.done-118:
	%456 = load %strings.Builder*, %strings.Builder** %0, align 8
	%457 = load %..string, %..string* %46, align 8
	call void @strings.write_string(%strings.Builder* %456, %..string %457, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%458 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %458, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1b8, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%459 = load %strings.Builder*, %strings.Builder** %0, align 8
	; IndexExpr
	; SelectorExpr
	%460 = getelementptr inbounds %runtime.Type_Info_Bit_Field, %runtime.Type_Info_Bit_Field* %45, i32 0, i32 1
	%461 = load {i32*, i64}, {i32*, i64}* %460, align 8
	%462 = extractvalue {i32*, i64} %461, 0
	%463 = load i64, i64* %47, align 8
	%464 = extractvalue {i32*, i64} %461, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([64 x i8], [64 x i8]* @str$1b9, i32 0, i32 0), i64 63}, i64 450, i64 33, i64 %463, i64 %464)
	%465 = getelementptr inbounds i32, i32* %462, i64 %463
	%466 = load i32, i32* %465, align 4
	%467 = sext i32 %466 to i64
	call void @strings.write_i64(%strings.Builder* %459, i64 %467, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %for.index.loop-115

for.index.done-119:
	%468 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %468, i8 125, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-120:
	%469 = icmp eq i64 %61, 23
	br i1 %469, label %typeswitch.body-130, label %typeswitch.next-129

typeswitch.body-121:
	%470 = bitcast %..rawptr %62 to %runtime.Type_Info_Bit_Set*
	%471 = load %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %470, align 8
	store %runtime.Type_Info_Bit_Set %471, %runtime.Type_Info_Bit_Set* %50
	%472 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %472, %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$1ba, i32 0, i32 0), i64 8}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SwitchStmt
	; SelectorExpr
	%473 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 0
	%474 = load %runtime.Type_Info*, %runtime.Type_Info** %473, align 8
	%475 = call i8 @reflect.is_enum(%runtime.Type_Info* %474, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%476 = icmp eq i8 1, %475
	br i1 %476, label %switch.case.body-123, label %switch.case.next-122

switch.case.next-122:
	; SelectorExpr
	%477 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 0
	%478 = load %runtime.Type_Info*, %runtime.Type_Info** %477, align 8
	%479 = call i8 @reflect.is_rune(%runtime.Type_Info* %478, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%480 = icmp eq i8 1, %479
	br i1 %480, label %switch.fall.body-125, label %switch.case.next-124

switch.case.body-123:
	%481 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%482 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 0
	%483 = load %runtime.Type_Info*, %runtime.Type_Info** %482, align 8
	call void @reflect.write_type(%strings.Builder* %481, %runtime.Type_Info* %483, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-126

switch.case.next-124:
	%484 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%485 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 2
	%486 = load i64, i64* %485, align 8
	call void @strings.write_i64(%strings.Builder* %484, i64 %486, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%487 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %487, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1bb, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%488 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%489 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 3
	%490 = load i64, i64* %489, align 8
	call void @strings.write_i64(%strings.Builder* %488, i64 %490, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-126

switch.fall.body-125:
	%491 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%492 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 2
	%493 = load i64, i64* %492, align 8
	%494 = trunc i64 %493 to i32
	call void @strings.write_encoded_rune(%strings.Builder* %491, i32 %494, i1 true, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%495 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %495, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1bc, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%496 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%497 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 3
	%498 = load i64, i64* %497, align 8
	%499 = trunc i64 %498 to i32
	call void @strings.write_encoded_rune(%strings.Builder* %496, i32 %499, i1 true, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %switch.done-126

switch.done-126:
	; IfStmt
	; SelectorExpr
	%500 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 1
	%501 = load %runtime.Type_Info*, %runtime.Type_Info** %500, align 8
	%502 = icmp ne %runtime.Type_Info* %501, zeroinitializer
	%503 = zext i1 %502 to i8
	%504 = trunc i8 %503 to i1
	br i1 %504, label %if.then-127, label %if.done-128

if.then-127:
	%505 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %505, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1bd, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%506 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%507 = getelementptr inbounds %runtime.Type_Info_Bit_Set, %runtime.Type_Info_Bit_Set* %50, i32 0, i32 1
	%508 = load %runtime.Type_Info*, %runtime.Type_Info** %507, align 8
	call void @reflect.write_type(%strings.Builder* %506, %runtime.Type_Info* %508, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-128

if.done-128:
	%509 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %509, i8 93, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-129:
	%510 = icmp eq i64 %61, 24
	br i1 %510, label %typeswitch.body-132, label %typeswitch.next-131

typeswitch.body-130:
	%511 = bitcast %..rawptr %62 to %runtime.Type_Info_Opaque*
	%512 = load %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %511, align 8
	store %runtime.Type_Info_Opaque %512, %runtime.Type_Info_Opaque* %51
	%513 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %513, %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1be, i32 0, i32 0), i64 7}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%514 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%515 = getelementptr inbounds %runtime.Type_Info_Opaque, %runtime.Type_Info_Opaque* %51, i32 0, i32 0
	%516 = load %runtime.Type_Info*, %runtime.Type_Info** %515, align 8
	call void @reflect.write_type(%strings.Builder* %514, %runtime.Type_Info* %516, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %typeswitch.done-136

typeswitch.next-131:
	br label %typeswitch.done-136

typeswitch.body-132:
	%517 = bitcast %..rawptr %62 to %runtime.Type_Info_Simd_Vector*
	%518 = load %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %517, align 8
	store %runtime.Type_Info_Simd_Vector %518, %runtime.Type_Info_Simd_Vector* %52
	; IfStmt
	; SelectorExpr
	%519 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %52, i32 0, i32 3
	%520 = load i8, i8* %519, align 1
	%521 = trunc i8 %520 to i1
	br i1 %521, label %if.then-133, label %if.else-134

if.then-133:
	%522 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %522, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$1bf, i32 0, i32 0), i64 18}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-135

if.else-134:
	%523 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %523, %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$1c0, i32 0, i32 0), i64 18}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%524 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%525 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %52, i32 0, i32 2
	%526 = load i64, i64* %525, align 8
	%527 = bitcast i64 %526 to i64
	call void @strings.write_i64(%strings.Builder* %524, i64 %527, i64 10, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%528 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_string(%strings.Builder* %528, %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1c1, i32 0, i32 0), i64 2}, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%529 = load %strings.Builder*, %strings.Builder** %0, align 8
	; SelectorExpr
	%530 = getelementptr inbounds %runtime.Type_Info_Simd_Vector, %runtime.Type_Info_Simd_Vector* %52, i32 0, i32 0
	%531 = load %runtime.Type_Info*, %runtime.Type_Info** %530, align 8
	call void @reflect.write_type(%strings.Builder* %529, %runtime.Type_Info* %531, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%532 = load %strings.Builder*, %strings.Builder** %0, align 8
	call void @strings.write_byte(%strings.Builder* %532, i8 41, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-135

if.done-135:
	br label %typeswitch.done-136

typeswitch.done-136:
	ret void
}

define i8* @mem.ptr_offset-5849(i8* %_.0, i64 %_.1) alwaysinline #1 {
decls-0:
	%0 = alloca i8*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store i8* %_.0, i8** %0
	store i64 %_.1, i64* %1
	; new
	%3 = load i8*, i8** %0, align 8
	%4 = ptrtoint i8* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 1, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to i8*
	ret i8* %11
}

define %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* @mem.new-6207(%mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, align 16
	; ptr
	%1 = call %..rawptr @mem.alloc(i64 24, i64 8, %mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	%2 = bitcast %..rawptr %1 to %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %2, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0
	; IfStmt
	%3 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%4 = icmp ne %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%7 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%8 = getelementptr inbounds %"LinkedList.LinkedList-387.LinkedList\28int\29-6190", %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %7, i64 0
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190" zeroinitializer, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %8
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%9 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	ret %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %9
}

define i64* @mem.new-6217(%mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca i64*, align 16
	; ptr
	%1 = call %..rawptr @mem.alloc(i64 8, i64 8, %mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	%2 = bitcast %..rawptr %1 to i64*
	store i64* %2, i64** %0
	; IfStmt
	%3 = load i64*, i64** %0, align 8
	%4 = icmp ne i64* %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%7 = load i64*, i64** %0, align 8
	%8 = getelementptr inbounds i64, i64* %7, i64 0
	store i64 zeroinitializer, i64* %8
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%9 = load i64*, i64** %0, align 8
	ret i64* %9
}

define void @LinkedList.insert-6232(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %_.0, i64* %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, align 16
	%1 = alloca i64*, align 16
	%2 = alloca %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, align 16
	%3 = alloca i64*, align 16
	%4 = alloca %"LinkedList.Node-386.Node\28T\29-6193"*, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %_.0, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0
	store i64* %_.1, i64** %1
	; list
	; value
	%6 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	%7 = load i64*, i64** %1, align 8
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %6, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2
	store i64* %7, i64** %3
	; newnode
	; SelectorExpr
	%8 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 0
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([73 x i8], [73 x i8]* @str$1c2, i32 0, i32 0), i64 72}, i64 24, i64 25, %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$1c3, i32 0, i32 0), i64 6}, i64 12378985194617082498}, %runtime.Source_Code_Location* %5
	%9 = call %"LinkedList.Node-386.Node\28T\29-6193"* @mem.new-9572(%mem.Allocator* %8, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %"LinkedList.Node-386.Node\28T\29-6193"* %9, %"LinkedList.Node-386.Node\28T\29-6193"** %4
	; AssignStmt
	; SelectorExpr
	%10 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	%11 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %10, i32 0, i32 0
	%12 = load i64*, i64** %3, align 8
	store i64* %12, i64** %11
	; IfStmt
	; SelectorExpr
	%13 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2, align 8
	%14 = getelementptr inbounds %"LinkedList.LinkedList-387.LinkedList\28int\29-6190", %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %13, i32 0, i32 0
	%15 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %14, align 8
	%16 = icmp eq %"LinkedList.Node-386.Node\28T\29-6193"* %15, zeroinitializer
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%19 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2, align 8
	%20 = getelementptr inbounds %"LinkedList.LinkedList-387.LinkedList\28int\29-6190", %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %19, i32 0, i32 0
	%21 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %21, %"LinkedList.Node-386.Node\28T\29-6193"** %20
	; AssignStmt
	; SelectorExpr
	%22 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2, align 8
	%23 = getelementptr inbounds %"LinkedList.LinkedList-387.LinkedList\28int\29-6190", %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %22, i32 0, i32 1
	%24 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %24, %"LinkedList.Node-386.Node\28T\29-6193"** %23
	; ReturnStmt
	ret void

if.done-2:
	; AssignStmt
	; SelectorExpr
	; SelectorExpr
	%25 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2, align 8
	%26 = getelementptr inbounds %"LinkedList.LinkedList-387.LinkedList\28int\29-6190", %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %25, i32 0, i32 1
	%27 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %26, align 8
	%28 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %27, i32 0, i32 1
	%29 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %29, %"LinkedList.Node-386.Node\28T\29-6193"** %28
	ret void
}

define i64 @LinkedList.removeAt-6292(%"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %_.0, i64 %_.1, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, align 16
	%3 = alloca %"LinkedList.Node-386.Node\28T\29-6193"*, align 16
	%4 = alloca %"LinkedList.Node-386.Node\28T\29-6193"*, align 16
	%5 = alloca i64, align 16
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %_.0, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0
	store i64 %_.1, i64* %1
	; list
	%6 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %0, align 8
	store %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %6, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2
	; previous
	store %"LinkedList.Node-386.Node\28T\29-6193"* zeroinitializer, %"LinkedList.Node-386.Node\28T\29-6193"** %3
	; node
	; SelectorExpr
	%7 = load %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"*, %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"** %2, align 8
	%8 = getelementptr inbounds %"LinkedList.LinkedList-387.LinkedList\28int\29-6190", %"LinkedList.LinkedList-387.LinkedList\28int\29-6190"* %7, i32 0, i32 0
	%9 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %8, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %9, %"LinkedList.Node-386.Node\28T\29-6193"** %4
	; ForStmt
	; i
	store i64 0, i64* %5
	br label %for.loop-1

for.loop-1:
	%10 = load i64, i64* %5, align 8
	%11 = load i64, i64* %1, align 8
	%12 = icmp slt i64 %10, %11
	%13 = zext i1 %12 to i8
	%14 = trunc i8 %13 to i1
	br i1 %14, label %for.body-2, label %for.done-5

for.body-2:
	; IfStmt
	%15 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	%16 = icmp eq %"LinkedList.Node-386.Node\28T\29-6193"* %15, zeroinitializer
	%17 = zext i1 %16 to i8
	%18 = trunc i8 %17 to i1
	br i1 %18, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i64 1

if.done-4:
	; AssignStmt
	%19 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %19, %"LinkedList.Node-386.Node\28T\29-6193"** %3
	; AssignStmt
	; SelectorExpr
	%20 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	%21 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %20, i32 0, i32 1
	%22 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %21, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %22, %"LinkedList.Node-386.Node\28T\29-6193"** %4
	; AssignStmt
	%23 = load i64, i64* %5, align 8
	%24 = add i64 %23, 1
	store i64 %24, i64* %5
	br label %for.loop-1

for.done-5:
	; AssignStmt
	; SelectorExpr
	%25 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	%26 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %25, i32 0, i32 1
	; SelectorExpr
	%27 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %3, align 8
	%28 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %27, i32 0, i32 1
	%29 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %28, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %29, %"LinkedList.Node-386.Node\28T\29-6193"** %26
	; AssignStmt
	; SelectorExpr
	%30 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %3, align 8
	%31 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %30, i32 0, i32 1
	%32 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %4, align 8
	store %"LinkedList.Node-386.Node\28T\29-6193"* %32, %"LinkedList.Node-386.Node\28T\29-6193"** %31
	; ReturnStmt
	ret i64 0
}

define void @mem.make_slice-6890({i8*, i64}* sret noalias %agg.result, i64 %_.1, %mem.Allocator* %_.2, %runtime.Source_Code_Location* %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca %mem.Raw_Slice, align 16
	%3 = alloca %mem.Raw_Slice, align 16
	store i64 %_.1, i64* %0
	; SelectorExpr
	%4 = load i64, i64* %0, align 8
	call void @runtime.make_slice_error_loc(%runtime.Source_Code_Location* %_.3, i64 %4)
	; data
	%5 = load i64, i64* %0, align 8
	%6 = mul i64 1, %5
	%7 = call %..rawptr @mem.alloc(i64 %6, i64 1, %mem.Allocator* %_.2, %runtime.Source_Code_Location* %_.3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %..rawptr %7, %..rawptr* %1
	; s
	; CompoundLit
	; ZeroInit
	store %mem.Raw_Slice zeroinitializer, %mem.Raw_Slice* %3, align 1
	store %mem.Raw_Slice {%..rawptr zeroinitializer, i64 zeroinitializer}, %mem.Raw_Slice* %3
	%8 = load %..rawptr, %..rawptr* %1, align 8
	%9 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %3, i32 0, i32 0
	store %..rawptr %8, %..rawptr* %9
	%10 = load i64, i64* %0, align 8
	%11 = getelementptr inbounds %mem.Raw_Slice, %mem.Raw_Slice* %3, i32 0, i32 1
	store i64 %10, i64* %11
	%12 = load %mem.Raw_Slice, %mem.Raw_Slice* %3, align 8
	store %mem.Raw_Slice %12, %mem.Raw_Slice* %2
	; ReturnStmt
	%13 = bitcast %mem.Raw_Slice* %2 to {i8*, i64}*
	%14 = load {i8*, i64}, {i8*, i64}* %13, align 8
	store {i8*, i64} %14, {i8*, i64}* %agg.result
	ret void
}

define void @mem.make_dynamic_array-6944({%..rawptr*, i64, i64, %mem.Allocator}* sret noalias %agg.result, %mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}, align 16
	; ReturnStmt
	%1 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %0 to %..rawptr
	; ZeroInit
	store {%..rawptr*, i64, i64, %mem.Allocator} zeroinitializer, {%..rawptr*, i64, i64, %mem.Allocator}* %0, align 1
	call void @mem.make_dynamic_array_len_cap-9752({%..rawptr*, i64, i64, %mem.Allocator}* %0, i64 0, i64 16, %mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	%2 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %0, align 8
	store {%..rawptr*, i64, i64, %mem.Allocator} %2, {%..rawptr*, i64, i64, %mem.Allocator}* %agg.result
	ret void
}

define void @runtime.append_elem-6987({%..rawptr*, i64, i64, %mem.Allocator}* %_.0, %..rawptr %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %..rawptr, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca %..rawptr*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca %..rawptr, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %_.0, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	store %..rawptr %_.1, %..rawptr* %1
	; IfStmt
	%8 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = icmp eq {%..rawptr*, i64, i64, %mem.Allocator}* %8, zeroinitializer
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%12 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%13 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %12, align 8
	%14 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %13, 2
	%15 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%16 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %15, align 8
	%17 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %16, 1
	%18 = load i64, i64* %2, align 8
	%19 = add i64 %17, %18
	%20 = icmp sle i64 %14, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%23 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%24 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %23, align 8
	%25 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %24, 2
	%26 = mul i64 2, %25
	; max
	%27 = load i64, i64* %2, align 8
	%28 = icmp sgt i64 8, %27
	%29 = select i1 %28, i64 8, i64 %27
	%30 = add i64 %26, %29
	store i64 %30, i64* %3
	; AssignStmt
	%31 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%32 = load i64, i64* %3, align 8
	%33 = call i8 @runtime.reserve_dynamic_array-9767({%..rawptr*, i64, i64, %mem.Allocator}* %31, i64 %32, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%34 = load i64, i64* %2, align 8
	%35 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%36 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %35, align 8
	%37 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %36, 2
	%38 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {%..rawptr*, i64, i64, %mem.Allocator} %39, 1
	%41 = sub i64 %37, %40
	%42 = icmp slt i64 %41, %34
	%43 = select i1 %42, i64 %41, i64 %34
	store i64 %43, i64* %2
	; IfStmt
	%44 = load i64, i64* %2, align 8
	%45 = icmp sgt i64 %44, 0
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%48 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%49 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %48 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %49, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%50 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%51 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %50, i32 0, i32 0
	%52 = load %..rawptr, %..rawptr* %51, align 8
	%53 = bitcast %..rawptr %52 to %..rawptr*
	store %..rawptr* %53, %..rawptr** %5
	%54 = load %..rawptr*, %..rawptr** %5, align 8
	%55 = icmp ne %..rawptr* %54, zeroinitializer
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c4, i32 0, i32 0), i64 62}, i64 510, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1c5, i32 0, i32 0), i64 11}, i64 7995656186675467875}, %runtime.Source_Code_Location* %6
	%58 = call i8 @runtime.assert(i1 %57, %..string zeroinitializer, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; val
	%59 = load %..rawptr, %..rawptr* %1, align 8
	store %..rawptr %59, %..rawptr* %7
	; SelectorExpr
	; SelectorExpr
	%60 = load %..rawptr*, %..rawptr** %5, align 8
	; SelectorExpr
	%61 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%62 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %61, i32 0, i32 1
	%63 = load i64, i64* %62, align 8
	%64 = call %..rawptr* @mem.ptr_offset-9787(%..rawptr* %60, i64 %63)
	%65 = bitcast %..rawptr* %64 to %..rawptr
	%66 = bitcast %..rawptr* %7 to %..rawptr
	%67 = call %..rawptr @mem.copy(%..rawptr %65, %..rawptr %66, i64 8)
	; AssignStmt
	; SelectorExpr
	%68 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i32 0, i32 1
	%70 = load i64, i64* %2, align 8
	%71 = load i64, i64* %69, align 8
	%72 = add i64 %71, %70
	store i64 %72, i64* %69
	br label %if.done-6

if.done-6:
	ret void
}

define void @runtime.clear_dynamic_array-7013({%..rawptr*, i64, i64, %mem.Allocator}* %_.0) alwaysinline #1 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca %mem.Raw_Dynamic_Array*, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %_.0, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%2 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%3 = icmp ne {%..rawptr*, i64, i64, %mem.Allocator}* %2, zeroinitializer
	%4 = zext i1 %3 to i8
	%5 = trunc i8 %4 to i1
	br i1 %5, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	; SelectorExpr
	%6 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %6 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %7, %mem.Raw_Dynamic_Array** %1
	%8 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %1, align 8
	%9 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %8, i32 0, i32 1
	store i64 0, i64* %9
	br label %if.done-2

if.done-2:
	ret void
}

define i64 @runtime.copy-7722({i8*, i64}* %_.0, {i8*, i64}* %_.1) #0 {
decls-0:
	%0 = alloca i64, align 16
	; n
	; max
	; min
	%1 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%2 = extractvalue {i8*, i64} %1, 1
	%3 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%4 = extractvalue {i8*, i64} %3, 1
	%5 = icmp slt i64 %4, %2
	%6 = select i1 %5, i64 %4, i64 %2
	%7 = icmp sgt i64 0, %6
	%8 = select i1 %7, i64 0, i64 %6
	store i64 %8, i64* %0
	; IfStmt
	%9 = load i64, i64* %0, align 8
	%10 = icmp sgt i64 %9, 0
	%11 = zext i1 %10 to i8
	%12 = trunc i8 %11 to i1
	br i1 %12, label %if.then-1, label %if.done-2

if.then-1:
	; SelectorExpr
	; IndexExpr
	%13 = load {i8*, i64}, {i8*, i64}* %_.0, align 8
	%14 = extractvalue {i8*, i64} %13, 0
	%15 = extractvalue {i8*, i64} %13, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c6, i32 0, i32 0), i64 62}, i64 395, i64 28, i64 0, i64 %15)
	%16 = getelementptr inbounds i8, i8* %14, i64 0
	; IndexExpr
	%17 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%18 = extractvalue {i8*, i64} %17, 0
	%19 = extractvalue {i8*, i64} %17, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c7, i32 0, i32 0), i64 62}, i64 395, i64 37, i64 0, i64 %19)
	%20 = getelementptr inbounds i8, i8* %18, i64 0
	%21 = load i64, i64* %0, align 8
	%22 = mul i64 %21, 1
	%23 = bitcast i8* %16 to %..rawptr
	%24 = bitcast i8* %20 to %..rawptr
	%25 = call %..rawptr @mem.copy(%..rawptr %23, %..rawptr %24, i64 %22)
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%26 = load i64, i64* %0, align 8
	ret i64 %26
}

define i8 @runtime.reserve_dynamic_array-8248({i8*, i64, i64, %mem.Allocator}* %_.0, i64 %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	store {i8*, i64, i64, %mem.Allocator}* %_.0, {i8*, i64, i64, %mem.Allocator}** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%8 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = icmp eq {i8*, i64, i64, %mem.Allocator}* %8, zeroinitializer
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%12 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%13 = bitcast {i8*, i64, i64, %mem.Allocator}* %12 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %13, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%14 = load i64, i64* %1, align 8
	; SelectorExpr
	%15 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %15, i32 0, i32 2
	%17 = load i64, i64* %16, align 8
	%18 = icmp sle i64 %14, %17
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%21 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%22 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %21, i32 0, i32 3
	%23 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %22, i32 0, i32 0
	%24 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %23, align 8
	%25 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %24, zeroinitializer
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%28 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %28, i32 0, i32 3
	; SelectorExpr
	%30 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 0
	%31 = load %mem.Allocator, %mem.Allocator* %30, align 8
	store %mem.Allocator %31, %mem.Allocator* %29
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i32 0, i32 3
	%34 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %33, i32 0, i32 0
	%35 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %34, align 8
	%36 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %35, zeroinitializer
	%37 = zext i1 %36 to i8
	%38 = trunc i8 %37 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1c8, i32 0, i32 0), i64 62}, i64 563, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$1c9, i32 0, i32 0), i64 21}, i64 7995449478489493039}, %runtime.Source_Code_Location* %3
	%39 = call i8 @runtime.assert(i1 %38, %..string zeroinitializer, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; old_size
	; SelectorExpr
	%40 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%41 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %40, i32 0, i32 2
	%42 = load i64, i64* %41, align 8
	%43 = mul i64 %42, 1
	store i64 %43, i64* %4
	; new_size
	%44 = load i64, i64* %1, align 8
	%45 = mul i64 %44, 1
	store i64 %45, i64* %5
	; allocator
	; SelectorExpr
	%46 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%47 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %46, i32 0, i32 3
	%48 = load %mem.Allocator, %mem.Allocator* %47, align 8
	store %mem.Allocator %48, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%49 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i32 0, i32 0
	%50 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %49, align 8
	; SelectorExpr
	%51 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i32 0, i32 1
	%52 = load %..rawptr, %..rawptr* %51, align 8
	%53 = load i64, i64* %5, align 8
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i32 0, i32 0
	%56 = load %..rawptr, %..rawptr* %55, align 8
	%57 = load i64, i64* %4, align 8
	%58 = call %..rawptr %50(%..rawptr %52, i8 3, i64 %53, i64 1, %..rawptr %56, i64 %57, i64 0, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %..rawptr %58, %..rawptr* %7
	; IfStmt
	%59 = load %..rawptr, %..rawptr* %7, align 8
	%60 = icmp eq %..rawptr %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%63 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%64 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %63, i32 0, i32 0
	%65 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %65, %..rawptr* %64
	; AssignStmt
	; SelectorExpr
	%66 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%67 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %66, i32 0, i32 2
	%68 = load i64, i64* %1, align 8
	store i64 %68, i64* %67
	; ReturnStmt
	ret i8 1
}

define void @runtime.append_elem-8299({i8*, i64, i64, %mem.Allocator}* %_.0, i8 %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i8, align 16
	%2 = alloca i64, align 16
	%3 = alloca i64, align 16
	%4 = alloca %mem.Raw_Dynamic_Array*, align 16
	%5 = alloca i8*, align 16
	%6 = alloca %runtime.Source_Code_Location, align 16
	%7 = alloca i8, align 16
	store {i8*, i64, i64, %mem.Allocator}* %_.0, {i8*, i64, i64, %mem.Allocator}** %0
	store i8 %_.1, i8* %1
	; IfStmt
	%8 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = icmp eq {i8*, i64, i64, %mem.Allocator}* %8, zeroinitializer
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; arg_len
	store i64 1, i64* %2
	; IfStmt
	%12 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%13 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %12, align 8
	%14 = extractvalue {i8*, i64, i64, %mem.Allocator} %13, 2
	%15 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%16 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %15, align 8
	%17 = extractvalue {i8*, i64, i64, %mem.Allocator} %16, 1
	%18 = load i64, i64* %2, align 8
	%19 = add i64 %17, %18
	%20 = icmp sle i64 %14, %19
	%21 = zext i1 %20 to i8
	%22 = trunc i8 %21 to i1
	br i1 %22, label %if.then-3, label %if.done-4

if.then-3:
	; cap
	%23 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%24 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %23, align 8
	%25 = extractvalue {i8*, i64, i64, %mem.Allocator} %24, 2
	%26 = mul i64 2, %25
	; max
	%27 = load i64, i64* %2, align 8
	%28 = icmp sgt i64 8, %27
	%29 = select i1 %28, i64 8, i64 %27
	%30 = add i64 %26, %29
	store i64 %30, i64* %3
	; AssignStmt
	%31 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%32 = load i64, i64* %3, align 8
	%33 = call i8 @runtime.reserve_dynamic_array-8248({i8*, i64, i64, %mem.Allocator}* %31, i64 %32, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-4

if.done-4:
	; AssignStmt
	; min
	%34 = load i64, i64* %2, align 8
	%35 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%36 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %35, align 8
	%37 = extractvalue {i8*, i64, i64, %mem.Allocator} %36, 2
	%38 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%39 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %38, align 8
	%40 = extractvalue {i8*, i64, i64, %mem.Allocator} %39, 1
	%41 = sub i64 %37, %40
	%42 = icmp slt i64 %41, %34
	%43 = select i1 %42, i64 %41, i64 %34
	store i64 %43, i64* %2
	; IfStmt
	%44 = load i64, i64* %2, align 8
	%45 = icmp sgt i64 %44, 0
	%46 = zext i1 %45 to i8
	%47 = trunc i8 %46 to i1
	br i1 %47, label %if.then-5, label %if.done-6

if.then-5:
	; a
	%48 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%49 = bitcast {i8*, i64, i64, %mem.Allocator}* %48 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %49, %mem.Raw_Dynamic_Array** %4
	; data
	; SelectorExpr
	%50 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%51 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %50, i32 0, i32 0
	%52 = load %..rawptr, %..rawptr* %51, align 8
	%53 = bitcast %..rawptr %52 to i8*
	store i8* %53, i8** %5
	%54 = load i8*, i8** %5, align 8
	%55 = icmp ne i8* %54, zeroinitializer
	%56 = zext i1 %55 to i8
	%57 = trunc i8 %56 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1ca, i32 0, i32 0), i64 62}, i64 510, i64 3, %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1cb, i32 0, i32 0), i64 11}, i64 7995656186675467875}, %runtime.Source_Code_Location* %6
	%58 = call i8 @runtime.assert(i1 %57, %..string zeroinitializer, %runtime.Source_Code_Location* %6, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; val
	%59 = load i8, i8* %1, align 1
	store i8 %59, i8* %7
	; SelectorExpr
	; SelectorExpr
	%60 = load i8*, i8** %5, align 8
	; SelectorExpr
	%61 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%62 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %61, i32 0, i32 1
	%63 = load i64, i64* %62, align 8
	%64 = call i8* @mem.ptr_offset-5849(i8* %60, i64 %63)
	%65 = bitcast i8* %64 to %..rawptr
	%66 = bitcast i8* %7 to %..rawptr
	%67 = call %..rawptr @mem.copy(%..rawptr %65, %..rawptr %66, i64 1)
	; AssignStmt
	; SelectorExpr
	%68 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %4, align 8
	%69 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %68, i32 0, i32 1
	%70 = load i64, i64* %2, align 8
	%71 = load i64, i64* %69, align 8
	%72 = add i64 %71, %70
	store i64 %72, i64* %69
	br label %if.done-6

if.done-6:
	ret void
}

define void @runtime.append_elems-8310({i8*, i64, i64, %mem.Allocator}* %_.0, {i8*, i64}* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {i8*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	%3 = alloca %mem.Raw_Dynamic_Array*, align 16
	%4 = alloca i8*, align 16
	%5 = alloca %runtime.Source_Code_Location, align 16
	store {i8*, i64, i64, %mem.Allocator}* %_.0, {i8*, i64, i64, %mem.Allocator}** %0
	; IfStmt
	%6 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%7 = icmp eq {i8*, i64, i64, %mem.Allocator}* %6, zeroinitializer
	%8 = zext i1 %7 to i8
	%9 = trunc i8 %8 to i1
	br i1 %9, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret void

if.done-2:
	; arg_len
	%10 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%11 = extractvalue {i8*, i64} %10, 1
	store i64 %11, i64* %1
	; IfStmt
	%12 = load i64, i64* %1, align 8
	%13 = icmp sle i64 %12, 0
	%14 = zext i1 %13 to i8
	%15 = trunc i8 %14 to i1
	br i1 %15, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret void

if.done-4:
	; IfStmt
	%16 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%17 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %16, align 8
	%18 = extractvalue {i8*, i64, i64, %mem.Allocator} %17, 2
	%19 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%20 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %19, align 8
	%21 = extractvalue {i8*, i64, i64, %mem.Allocator} %20, 1
	%22 = load i64, i64* %1, align 8
	%23 = add i64 %21, %22
	%24 = icmp sle i64 %18, %23
	%25 = zext i1 %24 to i8
	%26 = trunc i8 %25 to i1
	br i1 %26, label %if.then-5, label %if.done-6

if.then-5:
	; cap
	%27 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%28 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %27, align 8
	%29 = extractvalue {i8*, i64, i64, %mem.Allocator} %28, 2
	%30 = mul i64 2, %29
	; max
	%31 = load i64, i64* %1, align 8
	%32 = icmp sgt i64 8, %31
	%33 = select i1 %32, i64 8, i64 %31
	%34 = add i64 %30, %33
	store i64 %34, i64* %2
	; AssignStmt
	%35 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%36 = load i64, i64* %2, align 8
	%37 = call i8 @runtime.reserve_dynamic_array-8248({i8*, i64, i64, %mem.Allocator}* %35, i64 %36, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	br label %if.done-6

if.done-6:
	; AssignStmt
	; min
	%38 = load i64, i64* %1, align 8
	%39 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%40 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %39, align 8
	%41 = extractvalue {i8*, i64, i64, %mem.Allocator} %40, 2
	%42 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%43 = load {i8*, i64, i64, %mem.Allocator}, {i8*, i64, i64, %mem.Allocator}* %42, align 8
	%44 = extractvalue {i8*, i64, i64, %mem.Allocator} %43, 1
	%45 = sub i64 %41, %44
	%46 = icmp slt i64 %45, %38
	%47 = select i1 %46, i64 %45, i64 %38
	store i64 %47, i64* %1
	; IfStmt
	%48 = load i64, i64* %1, align 8
	%49 = icmp sgt i64 %48, 0
	%50 = zext i1 %49 to i8
	%51 = trunc i8 %50 to i1
	br i1 %51, label %if.then-7, label %if.done-8

if.then-7:
	; a
	%52 = load {i8*, i64, i64, %mem.Allocator}*, {i8*, i64, i64, %mem.Allocator}** %0, align 8
	%53 = bitcast {i8*, i64, i64, %mem.Allocator}* %52 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %53, %mem.Raw_Dynamic_Array** %3
	; data
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i32 0, i32 0
	%56 = load %..rawptr, %..rawptr* %55, align 8
	%57 = bitcast %..rawptr %56 to i8*
	store i8* %57, i8** %4
	%58 = load i8*, i8** %4, align 8
	%59 = icmp ne i8* %58, zeroinitializer
	%60 = zext i1 %59 to i8
	%61 = trunc i8 %60 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1cc, i32 0, i32 0), i64 62}, i64 532, i64 3, %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$1cd, i32 0, i32 0), i64 12}, i64 7995486861884846853}, %runtime.Source_Code_Location* %5
	%62 = call i8 @runtime.assert(i1 %61, %..string zeroinitializer, %runtime.Source_Code_Location* %5, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; SelectorExpr
	; SelectorExpr
	%63 = load i8*, i8** %4, align 8
	; SelectorExpr
	%64 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%65 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %64, i32 0, i32 1
	%66 = load i64, i64* %65, align 8
	%67 = call i8* @mem.ptr_offset-5849(i8* %63, i64 %66)
	; IndexExpr
	%68 = load {i8*, i64}, {i8*, i64}* %_.1, align 8
	%69 = extractvalue {i8*, i64} %68, 0
	%70 = extractvalue {i8*, i64} %68, 1
	call void @runtime.bounds_check_error(%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1ce, i32 0, i32 0), i64 62}, i64 533, i64 47, i64 0, i64 %70)
	%71 = getelementptr inbounds i8, i8* %69, i64 0
	%72 = load i64, i64* %1, align 8
	%73 = mul i64 1, %72
	%74 = bitcast i8* %67 to %..rawptr
	%75 = bitcast i8* %71 to %..rawptr
	%76 = call %..rawptr @mem.copy(%..rawptr %74, %..rawptr %75, i64 %73)
	; AssignStmt
	; SelectorExpr
	%77 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %3, align 8
	%78 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %77, i32 0, i32 1
	%79 = load i64, i64* %1, align 8
	%80 = load i64, i64* %78, align 8
	%81 = add i64 %80, %79
	store i64 %81, i64* %78
	br label %if.done-8

if.done-8:
	ret void
}

define %"LinkedList.Node-386.Node\28T\29-6193"* @mem.new-9572(%mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline #1 {
decls-0:
	%0 = alloca %"LinkedList.Node-386.Node\28T\29-6193"*, align 16
	; ptr
	%1 = call %..rawptr @mem.alloc(i64 16, i64 8, %mem.Allocator* %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) alwaysinline
	%2 = bitcast %..rawptr %1 to %"LinkedList.Node-386.Node\28T\29-6193"*
	store %"LinkedList.Node-386.Node\28T\29-6193"* %2, %"LinkedList.Node-386.Node\28T\29-6193"** %0
	; IfStmt
	%3 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %0, align 8
	%4 = icmp ne %"LinkedList.Node-386.Node\28T\29-6193"* %3, zeroinitializer
	%5 = zext i1 %4 to i8
	%6 = trunc i8 %5 to i1
	br i1 %6, label %if.then-1, label %if.done-2

if.then-1:
	; AssignStmt
	%7 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %0, align 8
	%8 = getelementptr inbounds %"LinkedList.Node-386.Node\28T\29-6193", %"LinkedList.Node-386.Node\28T\29-6193"* %7, i64 0
	store %"LinkedList.Node-386.Node\28T\29-6193" zeroinitializer, %"LinkedList.Node-386.Node\28T\29-6193"* %8
	br label %if.done-2

if.done-2:
	; ReturnStmt
	%9 = load %"LinkedList.Node-386.Node\28T\29-6193"*, %"LinkedList.Node-386.Node\28T\29-6193"** %0, align 8
	ret %"LinkedList.Node-386.Node\28T\29-6193"* %9
}

define void @mem.make_dynamic_array_len_cap-9752({%..rawptr*, i64, i64, %mem.Allocator}* sret noalias %agg.result, i64 %_.1, i64 %_.2, %mem.Allocator* %_.3, %runtime.Source_Code_Location* %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca i64, align 16
	%1 = alloca i64, align 16
	%2 = alloca %..rawptr, align 16
	%3 = alloca %mem.Raw_Dynamic_Array, align 16
	%4 = alloca %mem.Raw_Dynamic_Array, align 16
	store i64 %_.1, i64* %0
	store i64 %_.2, i64* %1
	; SelectorExpr
	%5 = load i64, i64* %0, align 8
	%6 = load i64, i64* %1, align 8
	call void @runtime.make_dynamic_array_error_loc(%runtime.Source_Code_Location* %_.4, i64 %5, i64 %6)
	; data
	%7 = load i64, i64* %1, align 8
	%8 = mul i64 8, %7
	%9 = call %..rawptr @mem.alloc(i64 %8, i64 8, %mem.Allocator* %_.3, %runtime.Source_Code_Location* %_.4, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %..rawptr %9, %..rawptr* %2
	; s
	; CompoundLit
	%10 = bitcast %mem.Raw_Dynamic_Array* %4 to %..rawptr
	; ZeroInit
	store %mem.Raw_Dynamic_Array zeroinitializer, %mem.Raw_Dynamic_Array* %4, align 1
	store %mem.Raw_Dynamic_Array {%..rawptr zeroinitializer, i64 zeroinitializer, i64 zeroinitializer, %mem.Allocator zeroinitializer}, %mem.Raw_Dynamic_Array* %4
	%11 = load %..rawptr, %..rawptr* %2, align 8
	%12 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %4, i32 0, i32 0
	store %..rawptr %11, %..rawptr* %12
	%13 = load i64, i64* %0, align 8
	%14 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %4, i32 0, i32 1
	store i64 %13, i64* %14
	%15 = load i64, i64* %1, align 8
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %4, i32 0, i32 2
	store i64 %15, i64* %16
	%17 = load %mem.Allocator, %mem.Allocator* %_.3, align 8
	%18 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %4, i32 0, i32 3
	store %mem.Allocator %17, %mem.Allocator* %18
	%19 = load %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %4, align 8
	store %mem.Raw_Dynamic_Array %19, %mem.Raw_Dynamic_Array* %3
	; ReturnStmt
	%20 = bitcast %mem.Raw_Dynamic_Array* %3 to {%..rawptr*, i64, i64, %mem.Allocator}*
	%21 = load {%..rawptr*, i64, i64, %mem.Allocator}, {%..rawptr*, i64, i64, %mem.Allocator}* %20, align 8
	store {%..rawptr*, i64, i64, %mem.Allocator} %21, {%..rawptr*, i64, i64, %mem.Allocator}* %agg.result
	ret void
}

define i8 @runtime.reserve_dynamic_array-9767({%..rawptr*, i64, i64, %mem.Allocator}* %_.0, i64 %_.1, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr) #0 {
decls-0:
	%0 = alloca {%..rawptr*, i64, i64, %mem.Allocator}*, align 16
	%1 = alloca i64, align 16
	%2 = alloca %mem.Raw_Dynamic_Array*, align 16
	%3 = alloca %runtime.Source_Code_Location, align 16
	%4 = alloca i64, align 16
	%5 = alloca i64, align 16
	%6 = alloca %mem.Allocator, align 16
	%7 = alloca %..rawptr, align 16
	store {%..rawptr*, i64, i64, %mem.Allocator}* %_.0, {%..rawptr*, i64, i64, %mem.Allocator}** %0
	store i64 %_.1, i64* %1
	; IfStmt
	%8 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%9 = icmp eq {%..rawptr*, i64, i64, %mem.Allocator}* %8, zeroinitializer
	%10 = zext i1 %9 to i8
	%11 = trunc i8 %10 to i1
	br i1 %11, label %if.then-1, label %if.done-2

if.then-1:
	; ReturnStmt
	ret i8 0

if.done-2:
	; a
	%12 = load {%..rawptr*, i64, i64, %mem.Allocator}*, {%..rawptr*, i64, i64, %mem.Allocator}** %0, align 8
	%13 = bitcast {%..rawptr*, i64, i64, %mem.Allocator}* %12 to %mem.Raw_Dynamic_Array*
	store %mem.Raw_Dynamic_Array* %13, %mem.Raw_Dynamic_Array** %2
	; IfStmt
	%14 = load i64, i64* %1, align 8
	; SelectorExpr
	%15 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%16 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %15, i32 0, i32 2
	%17 = load i64, i64* %16, align 8
	%18 = icmp sle i64 %14, %17
	%19 = zext i1 %18 to i8
	%20 = trunc i8 %19 to i1
	br i1 %20, label %if.then-3, label %if.done-4

if.then-3:
	; ReturnStmt
	ret i8 1

if.done-4:
	; IfStmt
	; SelectorExpr
	; SelectorExpr
	%21 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%22 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %21, i32 0, i32 3
	%23 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %22, i32 0, i32 0
	%24 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %23, align 8
	%25 = icmp eq %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %24, zeroinitializer
	%26 = zext i1 %25 to i8
	%27 = trunc i8 %26 to i1
	br i1 %27, label %if.then-5, label %if.done-6

if.then-5:
	; AssignStmt
	; SelectorExpr
	%28 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%29 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %28, i32 0, i32 3
	; SelectorExpr
	%30 = getelementptr inbounds %runtime.Context, %runtime.Context* %__.context_ptr, i32 0, i32 0
	%31 = load %mem.Allocator, %mem.Allocator* %30, align 8
	store %mem.Allocator %31, %mem.Allocator* %29
	br label %if.done-6

if.done-6:
	; SelectorExpr
	; SelectorExpr
	%32 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%33 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %32, i32 0, i32 3
	%34 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %33, i32 0, i32 0
	%35 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %34, align 8
	%36 = icmp ne %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)* %35, zeroinitializer
	%37 = zext i1 %36 to i8
	%38 = trunc i8 %37 to i1
	store %runtime.Source_Code_Location {%..string {i8* getelementptr inbounds ([63 x i8], [63 x i8]* @str$1cf, i32 0, i32 0), i64 62}, i64 563, i64 2, %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$1d0, i32 0, i32 0), i64 21}, i64 7995449478489493039}, %runtime.Source_Code_Location* %3
	%39 = call i8 @runtime.assert(i1 %38, %..string zeroinitializer, %runtime.Source_Code_Location* %3, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	; old_size
	; SelectorExpr
	%40 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%41 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %40, i32 0, i32 2
	%42 = load i64, i64* %41, align 8
	%43 = mul i64 %42, 8
	store i64 %43, i64* %4
	; new_size
	%44 = load i64, i64* %1, align 8
	%45 = mul i64 %44, 8
	store i64 %45, i64* %5
	; allocator
	; SelectorExpr
	%46 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%47 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %46, i32 0, i32 3
	%48 = load %mem.Allocator, %mem.Allocator* %47, align 8
	store %mem.Allocator %48, %mem.Allocator* %6
	; new_data
	; SelectorExpr
	%49 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i32 0, i32 0
	%50 = load %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)*, %..rawptr (%..rawptr, i8, i64, i64, %..rawptr, i64, i64, %runtime.Source_Code_Location*, %runtime.Context*)** %49, align 8
	; SelectorExpr
	%51 = getelementptr inbounds %mem.Allocator, %mem.Allocator* %6, i32 0, i32 1
	%52 = load %..rawptr, %..rawptr* %51, align 8
	%53 = load i64, i64* %5, align 8
	; SelectorExpr
	%54 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%55 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %54, i32 0, i32 0
	%56 = load %..rawptr, %..rawptr* %55, align 8
	%57 = load i64, i64* %4, align 8
	%58 = call %..rawptr %50(%..rawptr %52, i8 3, i64 %53, i64 8, %..rawptr %56, i64 %57, i64 0, %runtime.Source_Code_Location* %_.2, %runtime.Context* noalias nonnull nocapture %__.context_ptr)
	store %..rawptr %58, %..rawptr* %7
	; IfStmt
	%59 = load %..rawptr, %..rawptr* %7, align 8
	%60 = icmp eq %..rawptr %59, zeroinitializer
	%61 = zext i1 %60 to i8
	%62 = trunc i8 %61 to i1
	br i1 %62, label %if.then-7, label %if.done-8

if.then-7:
	; ReturnStmt
	ret i8 0

if.done-8:
	; AssignStmt
	; SelectorExpr
	%63 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%64 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %63, i32 0, i32 0
	%65 = load %..rawptr, %..rawptr* %7, align 8
	store %..rawptr %65, %..rawptr* %64
	; AssignStmt
	; SelectorExpr
	%66 = load %mem.Raw_Dynamic_Array*, %mem.Raw_Dynamic_Array** %2, align 8
	%67 = getelementptr inbounds %mem.Raw_Dynamic_Array, %mem.Raw_Dynamic_Array* %66, i32 0, i32 2
	%68 = load i64, i64* %1, align 8
	store i64 %68, i64* %67
	; ReturnStmt
	ret i8 1
}

define %..rawptr* @mem.ptr_offset-9787(%..rawptr* %_.0, i64 %_.1) alwaysinline #1 {
decls-0:
	%0 = alloca %..rawptr*, align 16
	%1 = alloca i64, align 16
	%2 = alloca i64, align 16
	store %..rawptr* %_.0, %..rawptr** %0
	store i64 %_.1, i64* %1
	; new
	%3 = load %..rawptr*, %..rawptr** %0, align 8
	%4 = ptrtoint %..rawptr* %3 to i64
	%5 = bitcast i64 %4 to i64
	%6 = load i64, i64* %1, align 8
	%7 = mul i64 8, %6
	%8 = add i64 %5, %7
	store i64 %8, i64* %2
	; ReturnStmt
	%9 = load i64, i64* %2, align 8
	%10 = bitcast i64 %9 to i64
	%11 = inttoptr i64 %10 to %..rawptr*
	ret %..rawptr* %11
}

define i32 @main(i32 %_.0, i8** %_.1) noinline #2 {
decls-0:
	%0 = alloca i32, align 16
	%1 = alloca i8**, align 16
	store i32 %_.0, i32* %0
	store i8** %_.1, i8*** %1
	%2 = load i32, i32* %0, align 4
	%3 = load i8**, i8*** %1, align 8
	%4 = sext i32 %2 to i64
	%5 = getelementptr inbounds {i8**, i64}, {i8**, i64}* @runtime.args__, i32 0, i32 0
	store i8** %3, i8*** %5
	%6 = getelementptr inbounds {i8**, i64}, {i8**, i64}* @runtime.args__, i32 0, i32 1
	store i64 %4, i64* %6
	call void @__$startup_runtime()
	call void @LinkedList.main() noinline
	ret i32 0
}

define void @__$startup_runtime() noinline #2 {
decls-0:
	%0 = alloca %runtime.Context, align 16
	%1 = bitcast %runtime.Context* %0 to %..rawptr
	; ZeroInit
	%2 = call %..rawptr @mem.zero(%..rawptr %1, i64 144) noinline
	%3 = load %runtime.Context, %runtime.Context* @ggv$0, align 8
	store %runtime.Context %3, %runtime.Context* %0
	call void @runtime.__init_context(%runtime.Context* %0) noinline
	call void @runtime.__init_context(%runtime.Context* @ggv$0) noinline
	%4 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 0
	%5 = getelementptr inbounds {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, i32 0, i32 0
	store %runtime.Type_Info* %4, %runtime.Type_Info** %5
	%6 = getelementptr inbounds {%runtime.Type_Info*, i64}, {%runtime.Type_Info*, i64}* @runtime.type_table, i32 0, i32 1
	store i64 116, i64* %6
	%7 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%8 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %7, i32 0, i32 3
	%9 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %7, i32 0, i32 0
	store i64 8, i64* %9
	%10 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %7, i32 0, i32 1
	store i64 8, i64* %10
	%11 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %7, i32 0, i32 2
	store %..typeid 4683743612465315844, %..typeid* %11
	; Type_Info_Basic
	%12 = bitcast {[0 x i64], [88 x i8], i64}* %8 to %runtime.Type_Info_Integer*
	%13 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %12, i32 0, i32 0
	store i8 1, i8* %13
	%14 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %12, i32 0, i32 1
	store i8 0, i8* %14
	%15 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %12, align 1
	%16 = bitcast {[0 x i64], [88 x i8], i64}* %8 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %15, %runtime.Type_Info_Integer* %16
	%17 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %8, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %17
	%18 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 8
	%19 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %18, i32 0, i32 3
	%20 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %18, i32 0, i32 0
	store i64 8, i64* %20
	%21 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %18, i32 0, i32 1
	store i64 8, i64* %21
	%22 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %18, i32 0, i32 2
	store %..typeid 8, %..typeid* %22
	; Type_Info_Basic
	%23 = bitcast {[0 x i64], [88 x i8], i64}* %19 to %runtime.Type_Info_Type_Id*
	%24 = load %runtime.Type_Info_Type_Id, %runtime.Type_Info_Type_Id* %23, align 1
	%25 = bitcast {[0 x i64], [88 x i8], i64}* %19 to %runtime.Type_Info_Type_Id*
	store %runtime.Type_Info_Type_Id %24, %runtime.Type_Info_Type_Id* %25
	%26 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %19, i64 0, i32 2 ; UnionTagPtr
	store i64 10, i64* %26
	%27 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 10
	%28 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i32 0, i32 3
	%29 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i32 0, i32 0
	store i64 96, i64* %29
	%30 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i32 0, i32 1
	store i64 8, i64* %30
	%31 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %27, i32 0, i32 2
	store %..typeid 1224979098644774922, %..typeid* %31
	; Type_Info_Union
	%32 = bitcast {[0 x i64], [88 x i8], i64}* %28 to %runtime.Type_Info_Union*
	%33 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %32, i32 0, i32 0
	%34 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %32, i32 0, i32 1
	%35 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %32, i32 0, i32 2
	%36 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %32, i32 0, i32 3
	%37 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %32, i32 0, i32 4
	%38 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 0
	%39 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 14
	%40 = bitcast %runtime.Type_Info* %39 to %runtime.Type_Info*
	%41 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 0
	%42 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 14
	store %runtime.Type_Info* %42, %runtime.Type_Info** %41
	%43 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 18
	%44 = bitcast %runtime.Type_Info* %43 to %runtime.Type_Info*
	%45 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 1
	%46 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 18
	store %runtime.Type_Info* %46, %runtime.Type_Info** %45
	%47 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 23
	%48 = bitcast %runtime.Type_Info* %47 to %runtime.Type_Info*
	%49 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 2
	%50 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 23
	store %runtime.Type_Info* %50, %runtime.Type_Info** %49
	%51 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 25
	%52 = bitcast %runtime.Type_Info* %51 to %runtime.Type_Info*
	%53 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 3
	%54 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 25
	store %runtime.Type_Info* %54, %runtime.Type_Info** %53
	%55 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 26
	%56 = bitcast %runtime.Type_Info* %55 to %runtime.Type_Info*
	%57 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 4
	%58 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 26
	store %runtime.Type_Info* %58, %runtime.Type_Info** %57
	%59 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 27
	%60 = bitcast %runtime.Type_Info* %59 to %runtime.Type_Info*
	%61 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 5
	%62 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 27
	store %runtime.Type_Info* %62, %runtime.Type_Info** %61
	%63 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 28
	%64 = bitcast %runtime.Type_Info* %63 to %runtime.Type_Info*
	%65 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 6
	%66 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 28
	store %runtime.Type_Info* %66, %runtime.Type_Info** %65
	%67 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 30
	%68 = bitcast %runtime.Type_Info* %67 to %runtime.Type_Info*
	%69 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 7
	%70 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 30
	store %runtime.Type_Info* %70, %runtime.Type_Info** %69
	%71 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 31
	%72 = bitcast %runtime.Type_Info* %71 to %runtime.Type_Info*
	%73 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 8
	%74 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 31
	store %runtime.Type_Info* %74, %runtime.Type_Info** %73
	%75 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 32
	%76 = bitcast %runtime.Type_Info* %75 to %runtime.Type_Info*
	%77 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 9
	%78 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 32
	store %runtime.Type_Info* %78, %runtime.Type_Info** %77
	%79 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 33
	%80 = bitcast %runtime.Type_Info* %79 to %runtime.Type_Info*
	%81 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 10
	%82 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 33
	store %runtime.Type_Info* %82, %runtime.Type_Info** %81
	%83 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 35
	%84 = bitcast %runtime.Type_Info* %83 to %runtime.Type_Info*
	%85 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 11
	%86 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 35
	store %runtime.Type_Info* %86, %runtime.Type_Info** %85
	%87 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 39
	%88 = bitcast %runtime.Type_Info* %87 to %runtime.Type_Info*
	%89 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 12
	%90 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 39
	store %runtime.Type_Info* %90, %runtime.Type_Info** %89
	%91 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 41
	%92 = bitcast %runtime.Type_Info* %91 to %runtime.Type_Info*
	%93 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 13
	%94 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 41
	store %runtime.Type_Info* %94, %runtime.Type_Info** %93
	%95 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 43
	%96 = bitcast %runtime.Type_Info* %95 to %runtime.Type_Info*
	%97 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 14
	%98 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 43
	store %runtime.Type_Info* %98, %runtime.Type_Info** %97
	%99 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 44
	%100 = bitcast %runtime.Type_Info* %99 to %runtime.Type_Info*
	%101 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 15
	%102 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 44
	store %runtime.Type_Info* %102, %runtime.Type_Info** %101
	%103 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 50
	%104 = bitcast %runtime.Type_Info* %103 to %runtime.Type_Info*
	%105 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 16
	%106 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 50
	store %runtime.Type_Info* %106, %runtime.Type_Info** %105
	%107 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 57
	%108 = bitcast %runtime.Type_Info* %107 to %runtime.Type_Info*
	%109 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 17
	%110 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 57
	store %runtime.Type_Info* %110, %runtime.Type_Info** %109
	%111 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 59
	%112 = bitcast %runtime.Type_Info* %111 to %runtime.Type_Info*
	%113 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 18
	%114 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 59
	store %runtime.Type_Info* %114, %runtime.Type_Info** %113
	%115 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 74
	%116 = bitcast %runtime.Type_Info* %115 to %runtime.Type_Info*
	%117 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 19
	%118 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 74
	store %runtime.Type_Info* %118, %runtime.Type_Info** %117
	%119 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 76
	%120 = bitcast %runtime.Type_Info* %119 to %runtime.Type_Info*
	%121 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 20
	%122 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 76
	store %runtime.Type_Info* %122, %runtime.Type_Info** %121
	%123 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 80
	%124 = bitcast %runtime.Type_Info* %123 to %runtime.Type_Info*
	%125 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 21
	%126 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 80
	store %runtime.Type_Info* %126, %runtime.Type_Info** %125
	%127 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 82
	%128 = bitcast %runtime.Type_Info* %127 to %runtime.Type_Info*
	%129 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 22
	%130 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 82
	store %runtime.Type_Info* %130, %runtime.Type_Info** %129
	%131 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 83
	%132 = bitcast %runtime.Type_Info* %131 to %runtime.Type_Info*
	%133 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %38, i64 23
	%134 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 83
	store %runtime.Type_Info* %134, %runtime.Type_Info** %133
	%135 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %33, i32 0, i32 0
	store %runtime.Type_Info** %38, %runtime.Type_Info*** %135
	%136 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %33, i32 0, i32 1
	store i64 24, i64* %136
	store i64 88, i64* %34
	%137 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	store %runtime.Type_Info* %137, %runtime.Type_Info** %35
	store i8 0, i8* %36
	store i8 0, i8* %37
	%138 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %32, align 8
	%139 = bitcast {[0 x i64], [88 x i8], i64}* %28 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %138, %runtime.Type_Info_Union* %139
	%140 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %28, i64 0, i32 2 ; UnionTagPtr
	store i64 18, i64* %140
	%141 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%142 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i32 0, i32 3
	%143 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i32 0, i32 0
	store i64 8, i64* %143
	%144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i32 0, i32 1
	store i64 8, i64* %144
	%145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %141, i32 0, i32 2
	store %..typeid 720575940379279371, %..typeid* %145
	; Type_Info_Pointer
	%146 = bitcast {[0 x i64], [88 x i8], i64}* %142 to %runtime.Type_Info_Pointer*
	%147 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 12
	%148 = bitcast %runtime.Type_Info* %147 to %runtime.Type_Info*
	%149 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %146, i32 0, i32 0
	store %runtime.Type_Info* %148, %runtime.Type_Info** %149
	%150 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %146, align 8
	%151 = bitcast {[0 x i64], [88 x i8], i64}* %142 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %150, %runtime.Type_Info_Pointer* %151
	%152 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %142, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %152
	%153 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 12
	%154 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %153, i32 0, i32 3
	%155 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %153, i32 0, i32 0
	store i64 120, i64* %155
	%156 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %153, i32 0, i32 1
	store i64 8, i64* %156
	%157 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %153, i32 0, i32 2
	store %..typeid 3458764513820540940, %..typeid* %157
	; Type_Info_Named
	%158 = bitcast {[0 x i64], [88 x i8], i64}* %154 to %runtime.Type_Info_Named*
	%159 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 13
	%160 = bitcast %runtime.Type_Info* %159 to %runtime.Type_Info*
	%161 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %158, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$1d1, i32 0, i32 0), i64 9}, %..string* %161
	%162 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %158, i32 0, i32 1
	store %runtime.Type_Info* %160, %runtime.Type_Info** %162
	%163 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %158, align 8
	%164 = bitcast {[0 x i64], [88 x i8], i64}* %154 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %163, %runtime.Type_Info_Named* %164
	%165 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %154, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %165
	%166 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 13
	%167 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %166, i32 0, i32 3
	%168 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %166, i32 0, i32 0
	store i64 120, i64* %168
	%169 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %166, i32 0, i32 1
	store i64 8, i64* %169
	%170 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %166, i32 0, i32 2
	store %..typeid 1152921504606846989, %..typeid* %170
	; Type_Info_Struct
	%171 = bitcast {[0 x i64], [88 x i8], i64}* %167 to %runtime.Type_Info_Struct*
	%172 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 5
	store i8 0, i8* %172
	%173 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 6
	store i8 0, i8* %173
	%174 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 7
	store i8 0, i8* %174
	%175 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 24
	%176 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 0
	%177 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 0
	%178 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 0
	%179 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 0
	%180 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%181 = bitcast %runtime.Type_Info* %180 to %runtime.Type_Info*
	%182 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %175, i64 0
	%183 = getelementptr inbounds i64, i64* %177, i64 0
	%184 = getelementptr inbounds i8, i8* %178, i64 0
	%185 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %185, %runtime.Type_Info** %182
	%186 = getelementptr inbounds %..string, %..string* %176, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1d2, i32 0, i32 0), i64 4}, %..string* %186
	store i64 0, i64* %183
	store i8 0, i8* %184
	%187 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%188 = bitcast %runtime.Type_Info* %187 to %runtime.Type_Info*
	%189 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %175, i64 1
	%190 = getelementptr inbounds i64, i64* %177, i64 1
	%191 = getelementptr inbounds i8, i8* %178, i64 1
	%192 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %192, %runtime.Type_Info** %189
	%193 = getelementptr inbounds %..string, %..string* %176, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$1d3, i32 0, i32 0), i64 5}, %..string* %193
	store i64 8, i64* %190
	store i8 0, i8* %191
	%194 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 8
	%195 = bitcast %runtime.Type_Info* %194 to %runtime.Type_Info*
	%196 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %175, i64 2
	%197 = getelementptr inbounds i64, i64* %177, i64 2
	%198 = getelementptr inbounds i8, i8* %178, i64 2
	%199 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 8
	store %runtime.Type_Info* %199, %runtime.Type_Info** %196
	%200 = getelementptr inbounds %..string, %..string* %176, i64 2
	store %..string {i8* getelementptr inbounds ([3 x i8], [3 x i8]* @str$1d4, i32 0, i32 0), i64 2}, %..string* %200
	store i64 16, i64* %197
	store i8 0, i8* %198
	%201 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 10
	%202 = bitcast %runtime.Type_Info* %201 to %runtime.Type_Info*
	%203 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %175, i64 3
	%204 = getelementptr inbounds i64, i64* %177, i64 3
	%205 = getelementptr inbounds i8, i8* %178, i64 3
	%206 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 10
	store %runtime.Type_Info* %206, %runtime.Type_Info** %203
	%207 = getelementptr inbounds %..string, %..string* %176, i64 3
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1d5, i32 0, i32 0), i64 7}, %..string* %207
	store i64 24, i64* %204
	store i8 0, i8* %205
	%208 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 0
	%209 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %208, i32 0, i32 0
	store %runtime.Type_Info** %175, %runtime.Type_Info*** %209
	%210 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %208, i32 0, i32 1
	store i64 4, i64* %210
	%211 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 1
	%212 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %211, i32 0, i32 0
	store %..string* %176, %..string** %212
	%213 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %211, i32 0, i32 1
	store i64 4, i64* %213
	%214 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 2
	%215 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %214, i32 0, i32 0
	store i64* %177, i64** %215
	%216 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %214, i32 0, i32 1
	store i64 4, i64* %216
	%217 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 3
	%218 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %217, i32 0, i32 0
	store i8* %178, i8** %218
	%219 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %217, i32 0, i32 1
	store i64 4, i64* %219
	%220 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, i32 0, i32 4
	%221 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %220, i32 0, i32 0
	store %..string* %179, %..string** %221
	%222 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %220, i32 0, i32 1
	store i64 4, i64* %222
	%223 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %171, align 8
	%224 = bitcast {[0 x i64], [88 x i8], i64}* %167 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %223, %runtime.Type_Info_Struct* %224
	%225 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %167, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %225
	%226 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 14
	%227 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %226, i32 0, i32 3
	%228 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %226, i32 0, i32 0
	store i64 24, i64* %228
	%229 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %226, i32 0, i32 1
	store i64 8, i64* %229
	%230 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %226, i32 0, i32 2
	store %..typeid 3458764513820540942, %..typeid* %230
	; Type_Info_Named
	%231 = bitcast {[0 x i64], [88 x i8], i64}* %227 to %runtime.Type_Info_Named*
	%232 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 15
	%233 = bitcast %runtime.Type_Info* %232 to %runtime.Type_Info*
	%234 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %231, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$1d6, i32 0, i32 0), i64 15}, %..string* %234
	%235 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %231, i32 0, i32 1
	store %runtime.Type_Info* %233, %runtime.Type_Info** %235
	%236 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %231, align 8
	%237 = bitcast {[0 x i64], [88 x i8], i64}* %227 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %236, %runtime.Type_Info_Named* %237
	%238 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %227, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %238
	%239 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 15
	%240 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %239, i32 0, i32 3
	%241 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %239, i32 0, i32 0
	store i64 24, i64* %241
	%242 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %239, i32 0, i32 1
	store i64 8, i64* %242
	%243 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %239, i32 0, i32 2
	store %..typeid 1152921504606846991, %..typeid* %243
	; Type_Info_Struct
	%244 = bitcast {[0 x i64], [88 x i8], i64}* %240 to %runtime.Type_Info_Struct*
	%245 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 5
	store i8 0, i8* %245
	%246 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 6
	store i8 0, i8* %246
	%247 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 7
	store i8 0, i8* %247
	%248 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 28
	%249 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 4
	%250 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 4
	%251 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 4
	%252 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 4
	%253 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	%254 = bitcast %runtime.Type_Info* %253 to %runtime.Type_Info*
	%255 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %248, i64 0
	%256 = getelementptr inbounds i64, i64* %250, i64 0
	%257 = getelementptr inbounds i8, i8* %251, i64 0
	%258 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	store %runtime.Type_Info* %258, %runtime.Type_Info** %255
	%259 = getelementptr inbounds %..string, %..string* %249, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1d7, i32 0, i32 0), i64 4}, %..string* %259
	store i64 0, i64* %256
	store i8 0, i8* %257
	%260 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%261 = bitcast %runtime.Type_Info* %260 to %runtime.Type_Info*
	%262 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %248, i64 1
	%263 = getelementptr inbounds i64, i64* %250, i64 1
	%264 = getelementptr inbounds i8, i8* %251, i64 1
	%265 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %265, %runtime.Type_Info** %262
	%266 = getelementptr inbounds %..string, %..string* %249, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1d8, i32 0, i32 0), i64 4}, %..string* %266
	store i64 16, i64* %263
	store i8 0, i8* %264
	%267 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 0
	%268 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %267, i32 0, i32 0
	store %runtime.Type_Info** %248, %runtime.Type_Info*** %268
	%269 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %267, i32 0, i32 1
	store i64 2, i64* %269
	%270 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 1
	%271 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %270, i32 0, i32 0
	store %..string* %249, %..string** %271
	%272 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %270, i32 0, i32 1
	store i64 2, i64* %272
	%273 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 2
	%274 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %273, i32 0, i32 0
	store i64* %250, i64** %274
	%275 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %273, i32 0, i32 1
	store i64 2, i64* %275
	%276 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 3
	%277 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %276, i32 0, i32 0
	store i8* %251, i8** %277
	%278 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %276, i32 0, i32 1
	store i64 2, i64* %278
	%279 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, i32 0, i32 4
	%280 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %279, i32 0, i32 0
	store %..string* %252, %..string** %280
	%281 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %279, i32 0, i32 1
	store i64 2, i64* %281
	%282 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %244, align 8
	%283 = bitcast {[0 x i64], [88 x i8], i64}* %240 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %282, %runtime.Type_Info_Struct* %283
	%284 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %240, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %284
	%285 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	%286 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %285, i32 0, i32 3
	%287 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %285, i32 0, i32 0
	store i64 16, i64* %287
	%288 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %285, i32 0, i32 1
	store i64 8, i64* %288
	%289 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %285, i32 0, i32 2
	store %..typeid 432345564227567632, %..typeid* %289
	; Type_Info_Basic
	%290 = bitcast {[0 x i64], [88 x i8], i64}* %286 to %runtime.Type_Info_String*
	%291 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %290, align 1
	%292 = bitcast {[0 x i64], [88 x i8], i64}* %286 to %runtime.Type_Info_String*
	store %runtime.Type_Info_String %291, %runtime.Type_Info_String* %292
	%293 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %286, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %293
	%294 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 17
	%295 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %294, i32 0, i32 3
	%296 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %294, i32 0, i32 0
	store i64 8, i64* %296
	%297 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %294, i32 0, i32 1
	store i64 8, i64* %297
	%298 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %294, i32 0, i32 2
	store %..typeid 720575940379279377, %..typeid* %298
	; Type_Info_Pointer
	%299 = bitcast {[0 x i64], [88 x i8], i64}* %295 to %runtime.Type_Info_Pointer*
	%300 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 3
	%301 = bitcast %runtime.Type_Info* %300 to %runtime.Type_Info*
	%302 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %299, i32 0, i32 0
	store %runtime.Type_Info* %301, %runtime.Type_Info** %302
	%303 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %299, align 8
	%304 = bitcast {[0 x i64], [88 x i8], i64}* %295 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %303, %runtime.Type_Info_Pointer* %304
	%305 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %295, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %305
	%306 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 3
	%307 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %306, i32 0, i32 3
	%308 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %306, i32 0, i32 0
	store i64 1, i64* %308
	%309 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %306, i32 0, i32 1
	store i64 1, i64* %309
	%310 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %306, i32 0, i32 2
	store %..typeid 72057594037927939, %..typeid* %310
	; Type_Info_Basic
	%311 = bitcast {[0 x i64], [88 x i8], i64}* %307 to %runtime.Type_Info_Integer*
	%312 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %311, i32 0, i32 0
	store i8 0, i8* %312
	%313 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %311, i32 0, i32 1
	store i8 0, i8* %313
	%314 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %311, align 1
	%315 = bitcast {[0 x i64], [88 x i8], i64}* %307 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %314, %runtime.Type_Info_Integer* %315
	%316 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %307, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %316
	%317 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 18
	%318 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %317, i32 0, i32 3
	%319 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %317, i32 0, i32 0
	store i64 2, i64* %319
	%320 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %317, i32 0, i32 1
	store i64 1, i64* %320
	%321 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %317, i32 0, i32 2
	store %..typeid 3458764513820540946, %..typeid* %321
	; Type_Info_Named
	%322 = bitcast {[0 x i64], [88 x i8], i64}* %318 to %runtime.Type_Info_Named*
	%323 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 19
	%324 = bitcast %runtime.Type_Info* %323 to %runtime.Type_Info*
	%325 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %322, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$1d9, i32 0, i32 0), i64 17}, %..string* %325
	%326 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %322, i32 0, i32 1
	store %runtime.Type_Info* %324, %runtime.Type_Info** %326
	%327 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %322, align 8
	%328 = bitcast {[0 x i64], [88 x i8], i64}* %318 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %327, %runtime.Type_Info_Named* %328
	%329 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %318, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %329
	%330 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 19
	%331 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %330, i32 0, i32 3
	%332 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %330, i32 0, i32 0
	store i64 2, i64* %332
	%333 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %330, i32 0, i32 1
	store i64 1, i64* %333
	%334 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %330, i32 0, i32 2
	store %..typeid 1152921504606846995, %..typeid* %334
	; Type_Info_Struct
	%335 = bitcast {[0 x i64], [88 x i8], i64}* %331 to %runtime.Type_Info_Struct*
	%336 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 5
	store i8 0, i8* %336
	%337 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 6
	store i8 0, i8* %337
	%338 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 7
	store i8 0, i8* %338
	%339 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 30
	%340 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 6
	%341 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 6
	%342 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 6
	%343 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 6
	%344 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%345 = bitcast %runtime.Type_Info* %344 to %runtime.Type_Info*
	%346 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %339, i64 0
	%347 = getelementptr inbounds i64, i64* %341, i64 0
	%348 = getelementptr inbounds i8, i8* %342, i64 0
	%349 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %349, %runtime.Type_Info** %346
	%350 = getelementptr inbounds %..string, %..string* %340, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$1da, i32 0, i32 0), i64 6}, %..string* %350
	store i64 0, i64* %347
	store i8 0, i8* %348
	%351 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 21
	%352 = bitcast %runtime.Type_Info* %351 to %runtime.Type_Info*
	%353 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %339, i64 1
	%354 = getelementptr inbounds i64, i64* %341, i64 1
	%355 = getelementptr inbounds i8, i8* %342, i64 1
	%356 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 21
	store %runtime.Type_Info* %356, %runtime.Type_Info** %353
	%357 = getelementptr inbounds %..string, %..string* %340, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1db, i32 0, i32 0), i64 10}, %..string* %357
	store i64 1, i64* %354
	store i8 0, i8* %355
	%358 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 0
	%359 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %358, i32 0, i32 0
	store %runtime.Type_Info** %339, %runtime.Type_Info*** %359
	%360 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %358, i32 0, i32 1
	store i64 2, i64* %360
	%361 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 1
	%362 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %361, i32 0, i32 0
	store %..string* %340, %..string** %362
	%363 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %361, i32 0, i32 1
	store i64 2, i64* %363
	%364 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 2
	%365 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %364, i32 0, i32 0
	store i64* %341, i64** %365
	%366 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %364, i32 0, i32 1
	store i64 2, i64* %366
	%367 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 3
	%368 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %367, i32 0, i32 0
	store i8* %342, i8** %368
	%369 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %367, i32 0, i32 1
	store i64 2, i64* %369
	%370 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, i32 0, i32 4
	%371 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %370, i32 0, i32 0
	store %..string* %343, %..string** %371
	%372 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %370, i32 0, i32 1
	store i64 2, i64* %372
	%373 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %335, align 8
	%374 = bitcast {[0 x i64], [88 x i8], i64}* %331 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %373, %runtime.Type_Info_Struct* %374
	%375 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %331, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %375
	%376 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%377 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %376, i32 0, i32 3
	%378 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %376, i32 0, i32 0
	store i64 1, i64* %378
	%379 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %376, i32 0, i32 1
	store i64 1, i64* %379
	%380 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %376, i32 0, i32 2
	store %..typeid 504403158265495572, %..typeid* %380
	; Type_Info_Basic
	%381 = bitcast {[0 x i64], [88 x i8], i64}* %377 to %runtime.Type_Info_Boolean*
	%382 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %381, align 1
	%383 = bitcast {[0 x i64], [88 x i8], i64}* %377 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %382, %runtime.Type_Info_Boolean* %383
	%384 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %377, i64 0, i32 2 ; UnionTagPtr
	store i64 8, i64* %384
	%385 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 21
	%386 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %385, i32 0, i32 3
	%387 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %385, i32 0, i32 0
	store i64 1, i64* %387
	%388 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %385, i32 0, i32 1
	store i64 1, i64* %388
	%389 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %385, i32 0, i32 2
	store %..typeid 3602879701896396821, %..typeid* %389
	; Type_Info_Named
	%390 = bitcast {[0 x i64], [88 x i8], i64}* %386 to %runtime.Type_Info_Named*
	%391 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 22
	%392 = bitcast %runtime.Type_Info* %391 to %runtime.Type_Info*
	%393 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %390, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$1dc, i32 0, i32 0), i64 19}, %..string* %393
	%394 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %390, i32 0, i32 1
	store %runtime.Type_Info* %392, %runtime.Type_Info** %394
	%395 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %390, align 8
	%396 = bitcast {[0 x i64], [88 x i8], i64}* %386 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %395, %runtime.Type_Info_Named* %396
	%397 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %386, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %397
	%398 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 22
	%399 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %398, i32 0, i32 3
	%400 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %398, i32 0, i32 0
	store i64 1, i64* %400
	%401 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %398, i32 0, i32 1
	store i64 1, i64* %401
	%402 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %398, i32 0, i32 2
	store %..typeid 1297036692682702870, %..typeid* %402
	; Type_Info_Enum
	%403 = bitcast {[0 x i64], [88 x i8], i64}* %399 to %runtime.Type_Info_Enum*
	%404 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 3
	%405 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %403, i32 0, i32 0
	store %runtime.Type_Info* %404, %runtime.Type_Info** %405
	%406 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-22, i32 0, i32 0
	%407 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-22, i32 0, i32 0
	%408 = bitcast %runtime.Type_Info_Enum_Value* %407 to i8*
	store i8 0, i8* %408
	%409 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %407, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %409
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$1dd, i32 0, i32 0), i64 8}, %..string* %406
	%410 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-22, i32 0, i32 1
	%411 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-22, i32 0, i32 1
	%412 = bitcast %runtime.Type_Info_Enum_Value* %411 to i8*
	store i8 1, i8* %412
	%413 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %411, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %413
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$1de, i32 0, i32 0), i64 6}, %..string* %410
	%414 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-22, i32 0, i32 2
	%415 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-22, i32 0, i32 2
	%416 = bitcast %runtime.Type_Info_Enum_Value* %415 to i8*
	store i8 2, i8* %416
	%417 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %415, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %417
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$1df, i32 0, i32 0), i64 3}, %..string* %414
	%418 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %403, i32 0, i32 1
	%419 = getelementptr inbounds [3 x %..string], [3 x %..string]* @$enum_names-22, i32 0, i32 0
	%420 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %418, i32 0, i32 0
	store %..string* %419, %..string** %420
	%421 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %418, i32 0, i32 1
	store i64 3, i64* %421
	%422 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %403, i32 0, i32 2
	%423 = getelementptr inbounds [3 x %runtime.Type_Info_Enum_Value], [3 x %runtime.Type_Info_Enum_Value]* @$enum_values-22, i32 0, i32 0
	%424 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %422, i32 0, i32 0
	store %runtime.Type_Info_Enum_Value* %423, %runtime.Type_Info_Enum_Value** %424
	%425 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %422, i32 0, i32 1
	store i64 3, i64* %425
	%426 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %403, align 8
	%427 = bitcast {[0 x i64], [88 x i8], i64}* %399 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %426, %runtime.Type_Info_Enum* %427
	%428 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %399, i64 0, i32 2 ; UnionTagPtr
	store i64 19, i64* %428
	%429 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 23
	%430 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %429, i32 0, i32 3
	%431 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %429, i32 0, i32 0
	store i64 0, i64* %431
	%432 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %429, i32 0, i32 1
	store i64 1, i64* %432
	%433 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %429, i32 0, i32 2
	store %..typeid 3458764513820540951, %..typeid* %433
	; Type_Info_Named
	%434 = bitcast {[0 x i64], [88 x i8], i64}* %430 to %runtime.Type_Info_Named*
	%435 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%436 = bitcast %runtime.Type_Info* %435 to %runtime.Type_Info*
	%437 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %434, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$1e0, i32 0, i32 0), i64 14}, %..string* %437
	%438 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %434, i32 0, i32 1
	store %runtime.Type_Info* %436, %runtime.Type_Info** %438
	%439 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %434, align 8
	%440 = bitcast {[0 x i64], [88 x i8], i64}* %430 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %439, %runtime.Type_Info_Named* %440
	%441 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %430, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %441
	%442 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%443 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %442, i32 0, i32 3
	%444 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %442, i32 0, i32 0
	store i64 0, i64* %444
	%445 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %442, i32 0, i32 1
	store i64 1, i64* %445
	%446 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %442, i32 0, i32 2
	store %..typeid 1152921504606847000, %..typeid* %446
	; Type_Info_Struct
	%447 = bitcast {[0 x i64], [88 x i8], i64}* %443 to %runtime.Type_Info_Struct*
	%448 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %447, i32 0, i32 5
	store i8 0, i8* %448
	%449 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %447, i32 0, i32 6
	store i8 0, i8* %449
	%450 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %447, i32 0, i32 7
	store i8 0, i8* %450
	%451 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %447, align 8
	%452 = bitcast {[0 x i64], [88 x i8], i64}* %443 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %451, %runtime.Type_Info_Struct* %452
	%453 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %443, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %453
	%454 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 25
	%455 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %454, i32 0, i32 3
	%456 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %454, i32 0, i32 0
	store i64 0, i64* %456
	%457 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %454, i32 0, i32 1
	store i64 1, i64* %457
	%458 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %454, i32 0, i32 2
	store %..typeid 3458764513820540953, %..typeid* %458
	; Type_Info_Named
	%459 = bitcast {[0 x i64], [88 x i8], i64}* %455 to %runtime.Type_Info_Named*
	%460 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%461 = bitcast %runtime.Type_Info* %460 to %runtime.Type_Info*
	%462 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %459, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$1e1, i32 0, i32 0), i64 15}, %..string* %462
	%463 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %459, i32 0, i32 1
	store %runtime.Type_Info* %461, %runtime.Type_Info** %463
	%464 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %459, align 8
	%465 = bitcast {[0 x i64], [88 x i8], i64}* %455 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %464, %runtime.Type_Info_Named* %465
	%466 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %455, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %466
	%467 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 26
	%468 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %467, i32 0, i32 3
	%469 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %467, i32 0, i32 0
	store i64 0, i64* %469
	%470 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %467, i32 0, i32 1
	store i64 1, i64* %470
	%471 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %467, i32 0, i32 2
	store %..typeid 3458764513820540954, %..typeid* %471
	; Type_Info_Named
	%472 = bitcast {[0 x i64], [88 x i8], i64}* %468 to %runtime.Type_Info_Named*
	%473 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%474 = bitcast %runtime.Type_Info* %473 to %runtime.Type_Info*
	%475 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %472, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$1e2, i32 0, i32 0), i64 17}, %..string* %475
	%476 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %472, i32 0, i32 1
	store %runtime.Type_Info* %474, %runtime.Type_Info** %476
	%477 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %472, align 8
	%478 = bitcast {[0 x i64], [88 x i8], i64}* %468 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %477, %runtime.Type_Info_Named* %478
	%479 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %468, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %479
	%480 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 27
	%481 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %480, i32 0, i32 3
	%482 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %480, i32 0, i32 0
	store i64 0, i64* %482
	%483 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %480, i32 0, i32 1
	store i64 1, i64* %483
	%484 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %480, i32 0, i32 2
	store %..typeid 3458764513820540955, %..typeid* %484
	; Type_Info_Named
	%485 = bitcast {[0 x i64], [88 x i8], i64}* %481 to %runtime.Type_Info_Named*
	%486 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%487 = bitcast %runtime.Type_Info* %486 to %runtime.Type_Info*
	%488 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %485, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$1e3, i32 0, i32 0), i64 20}, %..string* %488
	%489 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %485, i32 0, i32 1
	store %runtime.Type_Info* %487, %runtime.Type_Info** %489
	%490 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %485, align 8
	%491 = bitcast {[0 x i64], [88 x i8], i64}* %481 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %490, %runtime.Type_Info_Named* %491
	%492 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %481, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %492
	%493 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 28
	%494 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %493, i32 0, i32 3
	%495 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %493, i32 0, i32 0
	store i64 1, i64* %495
	%496 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %493, i32 0, i32 1
	store i64 1, i64* %496
	%497 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %493, i32 0, i32 2
	store %..typeid 3458764513820540956, %..typeid* %497
	; Type_Info_Named
	%498 = bitcast {[0 x i64], [88 x i8], i64}* %494 to %runtime.Type_Info_Named*
	%499 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 29
	%500 = bitcast %runtime.Type_Info* %499 to %runtime.Type_Info*
	%501 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %498, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$1e4, i32 0, i32 0), i64 16}, %..string* %501
	%502 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %498, i32 0, i32 1
	store %runtime.Type_Info* %500, %runtime.Type_Info** %502
	%503 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %498, align 8
	%504 = bitcast {[0 x i64], [88 x i8], i64}* %494 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %503, %runtime.Type_Info_Named* %504
	%505 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %494, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %505
	%506 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 29
	%507 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %506, i32 0, i32 3
	%508 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %506, i32 0, i32 0
	store i64 1, i64* %508
	%509 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %506, i32 0, i32 1
	store i64 1, i64* %509
	%510 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %506, i32 0, i32 2
	store %..typeid 1152921504606847005, %..typeid* %510
	; Type_Info_Struct
	%511 = bitcast {[0 x i64], [88 x i8], i64}* %507 to %runtime.Type_Info_Struct*
	%512 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 5
	store i8 0, i8* %512
	%513 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 6
	store i8 0, i8* %513
	%514 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 7
	store i8 0, i8* %514
	%515 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 32
	%516 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 8
	%517 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 8
	%518 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 8
	%519 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 8
	%520 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%521 = bitcast %runtime.Type_Info* %520 to %runtime.Type_Info*
	%522 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %515, i64 0
	%523 = getelementptr inbounds i64, i64* %517, i64 0
	%524 = getelementptr inbounds i8, i8* %518, i64 0
	%525 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %525, %runtime.Type_Info** %522
	%526 = getelementptr inbounds %..string, %..string* %516, i64 0
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1e5, i32 0, i32 0), i64 10}, %..string* %526
	store i64 0, i64* %523
	store i8 0, i8* %524
	%527 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 0
	%528 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %527, i32 0, i32 0
	store %runtime.Type_Info** %515, %runtime.Type_Info*** %528
	%529 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %527, i32 0, i32 1
	store i64 1, i64* %529
	%530 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 1
	%531 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %530, i32 0, i32 0
	store %..string* %516, %..string** %531
	%532 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %530, i32 0, i32 1
	store i64 1, i64* %532
	%533 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 2
	%534 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %533, i32 0, i32 0
	store i64* %517, i64** %534
	%535 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %533, i32 0, i32 1
	store i64 1, i64* %535
	%536 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 3
	%537 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %536, i32 0, i32 0
	store i8* %518, i8** %537
	%538 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %536, i32 0, i32 1
	store i64 1, i64* %538
	%539 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, i32 0, i32 4
	%540 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %539, i32 0, i32 0
	store %..string* %519, %..string** %540
	%541 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %539, i32 0, i32 1
	store i64 1, i64* %541
	%542 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %511, align 8
	%543 = bitcast {[0 x i64], [88 x i8], i64}* %507 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %542, %runtime.Type_Info_Struct* %543
	%544 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %507, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %544
	%545 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 30
	%546 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i32 0, i32 3
	%547 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i32 0, i32 0
	store i64 0, i64* %547
	%548 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i32 0, i32 1
	store i64 1, i64* %548
	%549 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %545, i32 0, i32 2
	store %..typeid 3458764513820540958, %..typeid* %549
	; Type_Info_Named
	%550 = bitcast {[0 x i64], [88 x i8], i64}* %546 to %runtime.Type_Info_Named*
	%551 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%552 = bitcast %runtime.Type_Info* %551 to %runtime.Type_Info*
	%553 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %550, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$1e6, i32 0, i32 0), i64 17}, %..string* %553
	%554 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %550, i32 0, i32 1
	store %runtime.Type_Info* %552, %runtime.Type_Info** %554
	%555 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %550, align 8
	%556 = bitcast {[0 x i64], [88 x i8], i64}* %546 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %555, %runtime.Type_Info_Named* %556
	%557 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %546, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %557
	%558 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 31
	%559 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %558, i32 0, i32 3
	%560 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %558, i32 0, i32 0
	store i64 0, i64* %560
	%561 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %558, i32 0, i32 1
	store i64 1, i64* %561
	%562 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %558, i32 0, i32 2
	store %..typeid 3458764513820540959, %..typeid* %562
	; Type_Info_Named
	%563 = bitcast {[0 x i64], [88 x i8], i64}* %559 to %runtime.Type_Info_Named*
	%564 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%565 = bitcast %runtime.Type_Info* %564 to %runtime.Type_Info*
	%566 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %563, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$1e7, i32 0, i32 0), i64 13}, %..string* %566
	%567 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %563, i32 0, i32 1
	store %runtime.Type_Info* %565, %runtime.Type_Info** %567
	%568 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %563, align 8
	%569 = bitcast {[0 x i64], [88 x i8], i64}* %559 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %568, %runtime.Type_Info_Named* %569
	%570 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %559, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %570
	%571 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 32
	%572 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %571, i32 0, i32 3
	%573 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %571, i32 0, i32 0
	store i64 0, i64* %573
	%574 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %571, i32 0, i32 1
	store i64 1, i64* %574
	%575 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %571, i32 0, i32 2
	store %..typeid 3458764513820540960, %..typeid* %575
	; Type_Info_Named
	%576 = bitcast {[0 x i64], [88 x i8], i64}* %572 to %runtime.Type_Info_Named*
	%577 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 24
	%578 = bitcast %runtime.Type_Info* %577 to %runtime.Type_Info*
	%579 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %576, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$1e8, i32 0, i32 0), i64 17}, %..string* %579
	%580 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %576, i32 0, i32 1
	store %runtime.Type_Info* %578, %runtime.Type_Info** %580
	%581 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %576, align 8
	%582 = bitcast {[0 x i64], [88 x i8], i64}* %572 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %581, %runtime.Type_Info_Named* %582
	%583 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %572, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %583
	%584 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 33
	%585 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %584, i32 0, i32 3
	%586 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %584, i32 0, i32 0
	store i64 8, i64* %586
	%587 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %584, i32 0, i32 1
	store i64 8, i64* %587
	%588 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %584, i32 0, i32 2
	store %..typeid 3458764513820540961, %..typeid* %588
	; Type_Info_Named
	%589 = bitcast {[0 x i64], [88 x i8], i64}* %585 to %runtime.Type_Info_Named*
	%590 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 34
	%591 = bitcast %runtime.Type_Info* %590 to %runtime.Type_Info*
	%592 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %589, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$1e9, i32 0, i32 0), i64 17}, %..string* %592
	%593 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %589, i32 0, i32 1
	store %runtime.Type_Info* %591, %runtime.Type_Info** %593
	%594 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %589, align 8
	%595 = bitcast {[0 x i64], [88 x i8], i64}* %585 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %594, %runtime.Type_Info_Named* %595
	%596 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %585, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %596
	%597 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 34
	%598 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %597, i32 0, i32 3
	%599 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %597, i32 0, i32 0
	store i64 8, i64* %599
	%600 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %597, i32 0, i32 1
	store i64 8, i64* %600
	%601 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %597, i32 0, i32 2
	store %..typeid 1152921504606847010, %..typeid* %601
	; Type_Info_Struct
	%602 = bitcast {[0 x i64], [88 x i8], i64}* %598 to %runtime.Type_Info_Struct*
	%603 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 5
	store i8 0, i8* %603
	%604 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 6
	store i8 0, i8* %604
	%605 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 7
	store i8 0, i8* %605
	%606 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 33
	%607 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 9
	%608 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 9
	%609 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 9
	%610 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 9
	%611 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%612 = bitcast %runtime.Type_Info* %611 to %runtime.Type_Info*
	%613 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %606, i64 0
	%614 = getelementptr inbounds i64, i64* %608, i64 0
	%615 = getelementptr inbounds i8, i8* %609, i64 0
	%616 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %616, %runtime.Type_Info** %613
	%617 = getelementptr inbounds %..string, %..string* %607, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1ea, i32 0, i32 0), i64 4}, %..string* %617
	store i64 0, i64* %614
	store i8 0, i8* %615
	%618 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 0
	%619 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %618, i32 0, i32 0
	store %runtime.Type_Info** %606, %runtime.Type_Info*** %619
	%620 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %618, i32 0, i32 1
	store i64 1, i64* %620
	%621 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 1
	%622 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %621, i32 0, i32 0
	store %..string* %607, %..string** %622
	%623 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %621, i32 0, i32 1
	store i64 1, i64* %623
	%624 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 2
	%625 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %624, i32 0, i32 0
	store i64* %608, i64** %625
	%626 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %624, i32 0, i32 1
	store i64 1, i64* %626
	%627 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 3
	%628 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %627, i32 0, i32 0
	store i8* %609, i8** %628
	%629 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %627, i32 0, i32 1
	store i64 1, i64* %629
	%630 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, i32 0, i32 4
	%631 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %630, i32 0, i32 0
	store %..string* %610, %..string** %631
	%632 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %630, i32 0, i32 1
	store i64 1, i64* %632
	%633 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %602, align 8
	%634 = bitcast {[0 x i64], [88 x i8], i64}* %598 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %633, %runtime.Type_Info_Struct* %634
	%635 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %598, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %635
	%636 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 35
	%637 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %636, i32 0, i32 3
	%638 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %636, i32 0, i32 0
	store i64 32, i64* %638
	%639 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %636, i32 0, i32 1
	store i64 8, i64* %639
	%640 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %636, i32 0, i32 2
	store %..typeid 3458764513820540963, %..typeid* %640
	; Type_Info_Named
	%641 = bitcast {[0 x i64], [88 x i8], i64}* %637 to %runtime.Type_Info_Named*
	%642 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 36
	%643 = bitcast %runtime.Type_Info* %642 to %runtime.Type_Info*
	%644 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %641, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$1eb, i32 0, i32 0), i64 19}, %..string* %644
	%645 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %641, i32 0, i32 1
	store %runtime.Type_Info* %643, %runtime.Type_Info** %645
	%646 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %641, align 8
	%647 = bitcast {[0 x i64], [88 x i8], i64}* %637 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %646, %runtime.Type_Info_Named* %647
	%648 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %637, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %648
	%649 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 36
	%650 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %649, i32 0, i32 3
	%651 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %649, i32 0, i32 0
	store i64 32, i64* %651
	%652 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %649, i32 0, i32 1
	store i64 8, i64* %652
	%653 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %649, i32 0, i32 2
	store %..typeid 1152921504606847012, %..typeid* %653
	; Type_Info_Struct
	%654 = bitcast {[0 x i64], [88 x i8], i64}* %650 to %runtime.Type_Info_Struct*
	%655 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 5
	store i8 0, i8* %655
	%656 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 6
	store i8 0, i8* %656
	%657 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 7
	store i8 0, i8* %657
	%658 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 34
	%659 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 10
	%660 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 10
	%661 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 10
	%662 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 10
	%663 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%664 = bitcast %runtime.Type_Info* %663 to %runtime.Type_Info*
	%665 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %658, i64 0
	%666 = getelementptr inbounds i64, i64* %660, i64 0
	%667 = getelementptr inbounds i8, i8* %661, i64 0
	%668 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %668, %runtime.Type_Info** %665
	%669 = getelementptr inbounds %..string, %..string* %659, i64 0
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$1ec, i32 0, i32 0), i64 6}, %..string* %669
	store i64 0, i64* %666
	store i8 0, i8* %667
	%670 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%671 = bitcast %runtime.Type_Info* %670 to %runtime.Type_Info*
	%672 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %658, i64 1
	%673 = getelementptr inbounds i64, i64* %660, i64 1
	%674 = getelementptr inbounds i8, i8* %661, i64 1
	%675 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %675, %runtime.Type_Info** %672
	%676 = getelementptr inbounds %..string, %..string* %659, i64 1
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1ed, i32 0, i32 0), i64 7}, %..string* %676
	store i64 8, i64* %673
	store i8 0, i8* %674
	%677 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%678 = bitcast %runtime.Type_Info* %677 to %runtime.Type_Info*
	%679 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %658, i64 2
	%680 = getelementptr inbounds i64, i64* %660, i64 2
	%681 = getelementptr inbounds i8, i8* %661, i64 2
	%682 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %682, %runtime.Type_Info** %679
	%683 = getelementptr inbounds %..string, %..string* %659, i64 2
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$1ee, i32 0, i32 0), i64 8}, %..string* %683
	store i64 16, i64* %680
	store i8 0, i8* %681
	%684 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 37
	%685 = bitcast %runtime.Type_Info* %684 to %runtime.Type_Info*
	%686 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %658, i64 3
	%687 = getelementptr inbounds i64, i64* %660, i64 3
	%688 = getelementptr inbounds i8, i8* %661, i64 3
	%689 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 37
	store %runtime.Type_Info* %689, %runtime.Type_Info** %686
	%690 = getelementptr inbounds %..string, %..string* %659, i64 3
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$1ef, i32 0, i32 0), i64 10}, %..string* %690
	store i64 24, i64* %687
	store i8 0, i8* %688
	%691 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 0
	%692 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %691, i32 0, i32 0
	store %runtime.Type_Info** %658, %runtime.Type_Info*** %692
	%693 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %691, i32 0, i32 1
	store i64 4, i64* %693
	%694 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 1
	%695 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %694, i32 0, i32 0
	store %..string* %659, %..string** %695
	%696 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %694, i32 0, i32 1
	store i64 4, i64* %696
	%697 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 2
	%698 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %697, i32 0, i32 0
	store i64* %660, i64** %698
	%699 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %697, i32 0, i32 1
	store i64 4, i64* %699
	%700 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 3
	%701 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %700, i32 0, i32 0
	store i8* %661, i8** %701
	%702 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %700, i32 0, i32 1
	store i64 4, i64* %702
	%703 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, i32 0, i32 4
	%704 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %703, i32 0, i32 0
	store %..string* %662, %..string** %704
	%705 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %703, i32 0, i32 1
	store i64 4, i64* %705
	%706 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %654, align 8
	%707 = bitcast {[0 x i64], [88 x i8], i64}* %650 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %706, %runtime.Type_Info_Struct* %707
	%708 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %650, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %708
	%709 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 37
	%710 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %709, i32 0, i32 3
	%711 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %709, i32 0, i32 0
	store i64 8, i64* %711
	%712 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %709, i32 0, i32 1
	store i64 8, i64* %712
	%713 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %709, i32 0, i32 2
	store %..typeid 3602879701896396837, %..typeid* %713
	; Type_Info_Named
	%714 = bitcast {[0 x i64], [88 x i8], i64}* %710 to %runtime.Type_Info_Named*
	%715 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 38
	%716 = bitcast %runtime.Type_Info* %715 to %runtime.Type_Info*
	%717 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %714, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([19 x i8], [19 x i8]* @str$1f0, i32 0, i32 0), i64 18}, %..string* %717
	%718 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %714, i32 0, i32 1
	store %runtime.Type_Info* %716, %runtime.Type_Info** %718
	%719 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %714, align 8
	%720 = bitcast {[0 x i64], [88 x i8], i64}* %710 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %719, %runtime.Type_Info_Named* %720
	%721 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %710, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %721
	%722 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 38
	%723 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %722, i32 0, i32 3
	%724 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %722, i32 0, i32 0
	store i64 8, i64* %724
	%725 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %722, i32 0, i32 1
	store i64 8, i64* %725
	%726 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %722, i32 0, i32 2
	store %..typeid 1297036692682702886, %..typeid* %726
	; Type_Info_Enum
	%727 = bitcast {[0 x i64], [88 x i8], i64}* %723 to %runtime.Type_Info_Enum*
	%728 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%729 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %727, i32 0, i32 0
	store %runtime.Type_Info* %728, %runtime.Type_Info** %729
	%730 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 0
	%731 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 0
	%732 = bitcast %runtime.Type_Info_Enum_Value* %731 to i64*
	store i64 0, i64* %732
	%733 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %731, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %733
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$1f1, i32 0, i32 0), i64 7}, %..string* %730
	%734 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 1
	%735 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 1
	%736 = bitcast %runtime.Type_Info_Enum_Value* %735 to i64*
	store i64 1, i64* %736
	%737 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %735, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %737
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1f2, i32 0, i32 0), i64 4}, %..string* %734
	%738 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 2
	%739 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 2
	%740 = bitcast %runtime.Type_Info_Enum_Value* %739 to i64*
	store i64 2, i64* %740
	%741 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %739, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %741
	store %..string {i8* getelementptr inbounds ([12 x i8], [12 x i8]* @str$1f3, i32 0, i32 0), i64 11}, %..string* %738
	%742 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 3
	%743 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 3
	%744 = bitcast %runtime.Type_Info_Enum_Value* %743 to i64*
	store i64 3, i64* %744
	%745 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %743, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %745
	store %..string {i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str$1f4, i32 0, i32 0), i64 1}, %..string* %742
	%746 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 4
	%747 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 4
	%748 = bitcast %runtime.Type_Info_Enum_Value* %747 to i64*
	store i64 4, i64* %748
	%749 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %747, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %749
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$1f5, i32 0, i32 0), i64 3}, %..string* %746
	%750 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 5
	%751 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 5
	%752 = bitcast %runtime.Type_Info_Enum_Value* %751 to i64*
	store i64 5, i64* %752
	%753 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %751, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %753
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1f6, i32 0, i32 0), i64 4}, %..string* %750
	%754 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %727, i32 0, i32 1
	%755 = getelementptr inbounds [6 x %..string], [6 x %..string]* @$enum_names-38, i32 0, i32 0
	%756 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %754, i32 0, i32 0
	store %..string* %755, %..string** %756
	%757 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %754, i32 0, i32 1
	store i64 6, i64* %757
	%758 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %727, i32 0, i32 2
	%759 = getelementptr inbounds [6 x %runtime.Type_Info_Enum_Value], [6 x %runtime.Type_Info_Enum_Value]* @$enum_values-38, i32 0, i32 0
	%760 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %758, i32 0, i32 0
	store %runtime.Type_Info_Enum_Value* %759, %runtime.Type_Info_Enum_Value** %760
	%761 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %758, i32 0, i32 1
	store i64 6, i64* %761
	%762 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %727, align 8
	%763 = bitcast {[0 x i64], [88 x i8], i64}* %723 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %762, %runtime.Type_Info_Enum* %763
	%764 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %723, i64 0, i32 2 ; UnionTagPtr
	store i64 19, i64* %764
	%765 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 39
	%766 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %765, i32 0, i32 3
	%767 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %765, i32 0, i32 0
	store i64 24, i64* %767
	%768 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %765, i32 0, i32 1
	store i64 8, i64* %768
	%769 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %765, i32 0, i32 2
	store %..typeid 3458764513820540967, %..typeid* %769
	; Type_Info_Named
	%770 = bitcast {[0 x i64], [88 x i8], i64}* %766 to %runtime.Type_Info_Named*
	%771 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 40
	%772 = bitcast %runtime.Type_Info* %771 to %runtime.Type_Info*
	%773 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %770, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$1f7, i32 0, i32 0), i64 15}, %..string* %773
	%774 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %770, i32 0, i32 1
	store %runtime.Type_Info* %772, %runtime.Type_Info** %774
	%775 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %770, align 8
	%776 = bitcast {[0 x i64], [88 x i8], i64}* %766 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %775, %runtime.Type_Info_Named* %776
	%777 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %766, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %777
	%778 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 40
	%779 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %778, i32 0, i32 3
	%780 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %778, i32 0, i32 0
	store i64 24, i64* %780
	%781 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %778, i32 0, i32 1
	store i64 8, i64* %781
	%782 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %778, i32 0, i32 2
	store %..typeid 1152921504606847016, %..typeid* %782
	; Type_Info_Struct
	%783 = bitcast {[0 x i64], [88 x i8], i64}* %779 to %runtime.Type_Info_Struct*
	%784 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 5
	store i8 0, i8* %784
	%785 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 6
	store i8 0, i8* %785
	%786 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 7
	store i8 0, i8* %786
	%787 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 38
	%788 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 14
	%789 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 14
	%790 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 14
	%791 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 14
	%792 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%793 = bitcast %runtime.Type_Info* %792 to %runtime.Type_Info*
	%794 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %787, i64 0
	%795 = getelementptr inbounds i64, i64* %789, i64 0
	%796 = getelementptr inbounds i8, i8* %790, i64 0
	%797 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %797, %runtime.Type_Info** %794
	%798 = getelementptr inbounds %..string, %..string* %788, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1f8, i32 0, i32 0), i64 4}, %..string* %798
	store i64 0, i64* %795
	store i8 0, i8* %796
	%799 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%800 = bitcast %runtime.Type_Info* %799 to %runtime.Type_Info*
	%801 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %787, i64 1
	%802 = getelementptr inbounds i64, i64* %789, i64 1
	%803 = getelementptr inbounds i8, i8* %790, i64 1
	%804 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %804, %runtime.Type_Info** %801
	%805 = getelementptr inbounds %..string, %..string* %788, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$1f9, i32 0, i32 0), i64 9}, %..string* %805
	store i64 8, i64* %802
	store i8 0, i8* %803
	%806 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%807 = bitcast %runtime.Type_Info* %806 to %runtime.Type_Info*
	%808 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %787, i64 2
	%809 = getelementptr inbounds i64, i64* %789, i64 2
	%810 = getelementptr inbounds i8, i8* %790, i64 2
	%811 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %811, %runtime.Type_Info** %808
	%812 = getelementptr inbounds %..string, %..string* %788, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$1fa, i32 0, i32 0), i64 5}, %..string* %812
	store i64 16, i64* %809
	store i8 0, i8* %810
	%813 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 0
	%814 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %813, i32 0, i32 0
	store %runtime.Type_Info** %787, %runtime.Type_Info*** %814
	%815 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %813, i32 0, i32 1
	store i64 3, i64* %815
	%816 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 1
	%817 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %816, i32 0, i32 0
	store %..string* %788, %..string** %817
	%818 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %816, i32 0, i32 1
	store i64 3, i64* %818
	%819 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 2
	%820 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %819, i32 0, i32 0
	store i64* %789, i64** %820
	%821 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %819, i32 0, i32 1
	store i64 3, i64* %821
	%822 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 3
	%823 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %822, i32 0, i32 0
	store i8* %790, i8** %823
	%824 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %822, i32 0, i32 1
	store i64 3, i64* %824
	%825 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, i32 0, i32 4
	%826 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %825, i32 0, i32 0
	store %..string* %791, %..string** %826
	%827 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %825, i32 0, i32 1
	store i64 3, i64* %827
	%828 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %783, align 8
	%829 = bitcast {[0 x i64], [88 x i8], i64}* %779 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %828, %runtime.Type_Info_Struct* %829
	%830 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %779, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %830
	%831 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 41
	%832 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %831, i32 0, i32 3
	%833 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %831, i32 0, i32 0
	store i64 16, i64* %833
	%834 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %831, i32 0, i32 1
	store i64 8, i64* %834
	%835 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %831, i32 0, i32 2
	store %..typeid 3458764513820540969, %..typeid* %835
	; Type_Info_Named
	%836 = bitcast {[0 x i64], [88 x i8], i64}* %832 to %runtime.Type_Info_Named*
	%837 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 42
	%838 = bitcast %runtime.Type_Info* %837 to %runtime.Type_Info*
	%839 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %836, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([24 x i8], [24 x i8]* @str$1fb, i32 0, i32 0), i64 23}, %..string* %839
	%840 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %836, i32 0, i32 1
	store %runtime.Type_Info* %838, %runtime.Type_Info** %840
	%841 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %836, align 8
	%842 = bitcast {[0 x i64], [88 x i8], i64}* %832 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %841, %runtime.Type_Info_Named* %842
	%843 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %832, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %843
	%844 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 42
	%845 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %844, i32 0, i32 3
	%846 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %844, i32 0, i32 0
	store i64 16, i64* %846
	%847 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %844, i32 0, i32 1
	store i64 8, i64* %847
	%848 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %844, i32 0, i32 2
	store %..typeid 1152921504606847018, %..typeid* %848
	; Type_Info_Struct
	%849 = bitcast {[0 x i64], [88 x i8], i64}* %845 to %runtime.Type_Info_Struct*
	%850 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 5
	store i8 0, i8* %850
	%851 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 6
	store i8 0, i8* %851
	%852 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 7
	store i8 0, i8* %852
	%853 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 41
	%854 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 17
	%855 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 17
	%856 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 17
	%857 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 17
	%858 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%859 = bitcast %runtime.Type_Info* %858 to %runtime.Type_Info*
	%860 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %853, i64 0
	%861 = getelementptr inbounds i64, i64* %855, i64 0
	%862 = getelementptr inbounds i8, i8* %856, i64 0
	%863 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %863, %runtime.Type_Info** %860
	%864 = getelementptr inbounds %..string, %..string* %854, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$1fc, i32 0, i32 0), i64 4}, %..string* %864
	store i64 0, i64* %861
	store i8 0, i8* %862
	%865 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%866 = bitcast %runtime.Type_Info* %865 to %runtime.Type_Info*
	%867 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %853, i64 1
	%868 = getelementptr inbounds i64, i64* %855, i64 1
	%869 = getelementptr inbounds i8, i8* %856, i64 1
	%870 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %870, %runtime.Type_Info** %867
	%871 = getelementptr inbounds %..string, %..string* %854, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$1fd, i32 0, i32 0), i64 9}, %..string* %871
	store i64 8, i64* %868
	store i8 0, i8* %869
	%872 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 0
	%873 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %872, i32 0, i32 0
	store %runtime.Type_Info** %853, %runtime.Type_Info*** %873
	%874 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %872, i32 0, i32 1
	store i64 2, i64* %874
	%875 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 1
	%876 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %875, i32 0, i32 0
	store %..string* %854, %..string** %876
	%877 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %875, i32 0, i32 1
	store i64 2, i64* %877
	%878 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 2
	%879 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %878, i32 0, i32 0
	store i64* %855, i64** %879
	%880 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %878, i32 0, i32 1
	store i64 2, i64* %880
	%881 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 3
	%882 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %881, i32 0, i32 0
	store i8* %856, i8** %882
	%883 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %881, i32 0, i32 1
	store i64 2, i64* %883
	%884 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, i32 0, i32 4
	%885 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %884, i32 0, i32 0
	store %..string* %857, %..string** %885
	%886 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %884, i32 0, i32 1
	store i64 2, i64* %886
	%887 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %849, align 8
	%888 = bitcast {[0 x i64], [88 x i8], i64}* %845 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %887, %runtime.Type_Info_Struct* %888
	%889 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %845, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %889
	%890 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 43
	%891 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %890, i32 0, i32 3
	%892 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %890, i32 0, i32 0
	store i64 16, i64* %892
	%893 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %890, i32 0, i32 1
	store i64 8, i64* %893
	%894 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %890, i32 0, i32 2
	store %..typeid 3458764513820540971, %..typeid* %894
	; Type_Info_Named
	%895 = bitcast {[0 x i64], [88 x i8], i64}* %891 to %runtime.Type_Info_Named*
	%896 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 42
	%897 = bitcast %runtime.Type_Info* %896 to %runtime.Type_Info*
	%898 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %895, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$1fe, i32 0, i32 0), i64 15}, %..string* %898
	%899 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %895, i32 0, i32 1
	store %runtime.Type_Info* %897, %runtime.Type_Info** %899
	%900 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %895, align 8
	%901 = bitcast {[0 x i64], [88 x i8], i64}* %891 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %900, %runtime.Type_Info_Named* %901
	%902 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %891, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %902
	%903 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 44
	%904 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i32 0, i32 3
	%905 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i32 0, i32 0
	store i64 32, i64* %905
	%906 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i32 0, i32 1
	store i64 8, i64* %906
	%907 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %903, i32 0, i32 2
	store %..typeid 3458764513820540972, %..typeid* %907
	; Type_Info_Named
	%908 = bitcast {[0 x i64], [88 x i8], i64}* %904 to %runtime.Type_Info_Named*
	%909 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 45
	%910 = bitcast %runtime.Type_Info* %909 to %runtime.Type_Info*
	%911 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %908, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$1ff, i32 0, i32 0), i64 15}, %..string* %911
	%912 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %908, i32 0, i32 1
	store %runtime.Type_Info* %910, %runtime.Type_Info** %912
	%913 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %908, align 8
	%914 = bitcast {[0 x i64], [88 x i8], i64}* %904 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %913, %runtime.Type_Info_Named* %914
	%915 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %904, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %915
	%916 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 45
	%917 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i32 0, i32 3
	%918 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i32 0, i32 0
	store i64 32, i64* %918
	%919 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i32 0, i32 1
	store i64 8, i64* %919
	%920 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %916, i32 0, i32 2
	store %..typeid 1152921504606847021, %..typeid* %920
	; Type_Info_Struct
	%921 = bitcast {[0 x i64], [88 x i8], i64}* %917 to %runtime.Type_Info_Struct*
	%922 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 5
	store i8 0, i8* %922
	%923 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 6
	store i8 0, i8* %923
	%924 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 7
	store i8 0, i8* %924
	%925 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 43
	%926 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 19
	%927 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 19
	%928 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 19
	%929 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 19
	%930 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	%931 = bitcast %runtime.Type_Info* %930 to %runtime.Type_Info*
	%932 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 0
	%933 = getelementptr inbounds i64, i64* %927, i64 0
	%934 = getelementptr inbounds i8, i8* %928, i64 0
	%935 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	store %runtime.Type_Info* %935, %runtime.Type_Info** %932
	%936 = getelementptr inbounds %..string, %..string* %926, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$200, i32 0, i32 0), i64 5}, %..string* %936
	store i64 0, i64* %933
	store i8 0, i8* %934
	%937 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	%938 = bitcast %runtime.Type_Info* %937 to %runtime.Type_Info*
	%939 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %925, i64 1
	%940 = getelementptr inbounds i64, i64* %927, i64 1
	%941 = getelementptr inbounds i8, i8* %928, i64 1
	%942 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	store %runtime.Type_Info* %942, %runtime.Type_Info** %939
	%943 = getelementptr inbounds %..string, %..string* %926, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$201, i32 0, i32 0), i64 5}, %..string* %943
	store i64 16, i64* %940
	store i8 0, i8* %941
	%944 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 0
	%945 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %944, i32 0, i32 0
	store %runtime.Type_Info** %925, %runtime.Type_Info*** %945
	%946 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %944, i32 0, i32 1
	store i64 2, i64* %946
	%947 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 1
	%948 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %947, i32 0, i32 0
	store %..string* %926, %..string** %948
	%949 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %947, i32 0, i32 1
	store i64 2, i64* %949
	%950 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 2
	%951 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %950, i32 0, i32 0
	store i64* %927, i64** %951
	%952 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %950, i32 0, i32 1
	store i64 2, i64* %952
	%953 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 3
	%954 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %953, i32 0, i32 0
	store i8* %928, i8** %954
	%955 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %953, i32 0, i32 1
	store i64 2, i64* %955
	%956 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, i32 0, i32 4
	%957 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %956, i32 0, i32 0
	store %..string* %929, %..string** %957
	%958 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %956, i32 0, i32 1
	store i64 2, i64* %958
	%959 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %921, align 8
	%960 = bitcast {[0 x i64], [88 x i8], i64}* %917 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %959, %runtime.Type_Info_Struct* %960
	%961 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %917, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %961
	%962 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	%963 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %962, i32 0, i32 3
	%964 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %962, i32 0, i32 0
	store i64 16, i64* %964
	%965 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %962, i32 0, i32 1
	store i64 8, i64* %965
	%966 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %962, i32 0, i32 2
	store %..typeid 1008806316530991150, %..typeid* %966
	; Type_Info_Slice
	%967 = bitcast {[0 x i64], [88 x i8], i64}* %963 to %runtime.Type_Info_Slice*
	%968 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%969 = bitcast %runtime.Type_Info* %968 to %runtime.Type_Info*
	%970 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %967, i32 0, i32 0
	store %runtime.Type_Info* %969, %runtime.Type_Info** %970
	%971 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %967, i32 0, i32 1
	store i64 8, i64* %971
	%972 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %967, align 8
	%973 = bitcast {[0 x i64], [88 x i8], i64}* %963 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %972, %runtime.Type_Info_Slice* %973
	%974 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %963, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %974
	%975 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 47
	%976 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %975, i32 0, i32 3
	%977 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %975, i32 0, i32 0
	store i64 8, i64* %977
	%978 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %975, i32 0, i32 1
	store i64 8, i64* %978
	%979 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %975, i32 0, i32 2
	store %..typeid 720575940379279407, %..typeid* %979
	; Type_Info_Pointer
	%980 = bitcast {[0 x i64], [88 x i8], i64}* %976 to %runtime.Type_Info_Pointer*
	%981 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%982 = bitcast %runtime.Type_Info* %981 to %runtime.Type_Info*
	%983 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %980, i32 0, i32 0
	store %runtime.Type_Info* %982, %runtime.Type_Info** %983
	%984 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %980, align 8
	%985 = bitcast {[0 x i64], [88 x i8], i64}* %976 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %984, %runtime.Type_Info_Pointer* %985
	%986 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %976, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %986
	%987 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	%988 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %987, i32 0, i32 3
	%989 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %987, i32 0, i32 0
	store i64 16, i64* %989
	%990 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %987, i32 0, i32 1
	store i64 8, i64* %990
	%991 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %987, i32 0, i32 2
	store %..typeid 1008806316530991152, %..typeid* %991
	; Type_Info_Slice
	%992 = bitcast {[0 x i64], [88 x i8], i64}* %988 to %runtime.Type_Info_Slice*
	%993 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	%994 = bitcast %runtime.Type_Info* %993 to %runtime.Type_Info*
	%995 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %992, i32 0, i32 0
	store %runtime.Type_Info* %994, %runtime.Type_Info** %995
	%996 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %992, i32 0, i32 1
	store i64 16, i64* %996
	%997 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %992, align 8
	%998 = bitcast {[0 x i64], [88 x i8], i64}* %988 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %997, %runtime.Type_Info_Slice* %998
	%999 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %988, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %999
	%1000 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 49
	%1001 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1000, i32 0, i32 3
	%1002 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1000, i32 0, i32 0
	store i64 8, i64* %1002
	%1003 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1000, i32 0, i32 1
	store i64 8, i64* %1003
	%1004 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1000, i32 0, i32 2
	store %..typeid 720575940379279409, %..typeid* %1004
	; Type_Info_Pointer
	%1005 = bitcast {[0 x i64], [88 x i8], i64}* %1001 to %runtime.Type_Info_Pointer*
	%1006 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	%1007 = bitcast %runtime.Type_Info* %1006 to %runtime.Type_Info*
	%1008 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1005, i32 0, i32 0
	store %runtime.Type_Info* %1007, %runtime.Type_Info** %1008
	%1009 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1005, align 8
	%1010 = bitcast {[0 x i64], [88 x i8], i64}* %1001 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1009, %runtime.Type_Info_Pointer* %1010
	%1011 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1001, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1011
	%1012 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 50
	%1013 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1012, i32 0, i32 3
	%1014 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1012, i32 0, i32 0
	store i64 88, i64* %1014
	%1015 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1012, i32 0, i32 1
	store i64 8, i64* %1015
	%1016 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1012, i32 0, i32 2
	store %..typeid 3458764513820540978, %..typeid* %1016
	; Type_Info_Named
	%1017 = bitcast {[0 x i64], [88 x i8], i64}* %1013 to %runtime.Type_Info_Named*
	%1018 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 51
	%1019 = bitcast %runtime.Type_Info* %1018 to %runtime.Type_Info*
	%1020 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1017, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$202, i32 0, i32 0), i64 16}, %..string* %1020
	%1021 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1017, i32 0, i32 1
	store %runtime.Type_Info* %1019, %runtime.Type_Info** %1021
	%1022 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1017, align 8
	%1023 = bitcast {[0 x i64], [88 x i8], i64}* %1013 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1022, %runtime.Type_Info_Named* %1023
	%1024 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1013, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1024
	%1025 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 51
	%1026 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1025, i32 0, i32 3
	%1027 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1025, i32 0, i32 0
	store i64 88, i64* %1027
	%1028 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1025, i32 0, i32 1
	store i64 8, i64* %1028
	%1029 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1025, i32 0, i32 2
	store %..typeid 1152921504606847027, %..typeid* %1029
	; Type_Info_Struct
	%1030 = bitcast {[0 x i64], [88 x i8], i64}* %1026 to %runtime.Type_Info_Struct*
	%1031 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 5
	store i8 0, i8* %1031
	%1032 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 6
	store i8 0, i8* %1032
	%1033 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 7
	store i8 0, i8* %1033
	%1034 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 45
	%1035 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 21
	%1036 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 21
	%1037 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 21
	%1038 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 21
	%1039 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	%1040 = bitcast %runtime.Type_Info* %1039 to %runtime.Type_Info*
	%1041 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 0
	%1042 = getelementptr inbounds i64, i64* %1036, i64 0
	%1043 = getelementptr inbounds i8, i8* %1037, i64 0
	%1044 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	store %runtime.Type_Info* %1044, %runtime.Type_Info** %1041
	%1045 = getelementptr inbounds %..string, %..string* %1035, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$203, i32 0, i32 0), i64 5}, %..string* %1045
	store i64 0, i64* %1042
	store i8 0, i8* %1043
	%1046 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	%1047 = bitcast %runtime.Type_Info* %1046 to %runtime.Type_Info*
	%1048 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 1
	%1049 = getelementptr inbounds i64, i64* %1036, i64 1
	%1050 = getelementptr inbounds i8, i8* %1037, i64 1
	%1051 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	store %runtime.Type_Info* %1051, %runtime.Type_Info** %1048
	%1052 = getelementptr inbounds %..string, %..string* %1035, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$204, i32 0, i32 0), i64 5}, %..string* %1052
	store i64 16, i64* %1049
	store i8 0, i8* %1050
	%1053 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 52
	%1054 = bitcast %runtime.Type_Info* %1053 to %runtime.Type_Info*
	%1055 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 2
	%1056 = getelementptr inbounds i64, i64* %1036, i64 2
	%1057 = getelementptr inbounds i8, i8* %1037, i64 2
	%1058 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 52
	store %runtime.Type_Info* %1058, %runtime.Type_Info** %1055
	%1059 = getelementptr inbounds %..string, %..string* %1035, i64 2
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$205, i32 0, i32 0), i64 7}, %..string* %1059
	store i64 32, i64* %1056
	store i8 0, i8* %1057
	%1060 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 55
	%1061 = bitcast %runtime.Type_Info* %1060 to %runtime.Type_Info*
	%1062 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 3
	%1063 = getelementptr inbounds i64, i64* %1036, i64 3
	%1064 = getelementptr inbounds i8, i8* %1037, i64 3
	%1065 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 55
	store %runtime.Type_Info* %1065, %runtime.Type_Info** %1062
	%1066 = getelementptr inbounds %..string, %..string* %1035, i64 3
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$206, i32 0, i32 0), i64 6}, %..string* %1066
	store i64 48, i64* %1063
	store i8 0, i8* %1064
	%1067 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	%1068 = bitcast %runtime.Type_Info* %1067 to %runtime.Type_Info*
	%1069 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 4
	%1070 = getelementptr inbounds i64, i64* %1036, i64 4
	%1071 = getelementptr inbounds i8, i8* %1037, i64 4
	%1072 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	store %runtime.Type_Info* %1072, %runtime.Type_Info** %1069
	%1073 = getelementptr inbounds %..string, %..string* %1035, i64 4
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$207, i32 0, i32 0), i64 4}, %..string* %1073
	store i64 64, i64* %1070
	store i8 0, i8* %1071
	%1074 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1075 = bitcast %runtime.Type_Info* %1074 to %runtime.Type_Info*
	%1076 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 5
	%1077 = getelementptr inbounds i64, i64* %1036, i64 5
	%1078 = getelementptr inbounds i8, i8* %1037, i64 5
	%1079 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %1079, %runtime.Type_Info** %1076
	%1080 = getelementptr inbounds %..string, %..string* %1035, i64 5
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$208, i32 0, i32 0), i64 9}, %..string* %1080
	store i64 80, i64* %1077
	store i8 0, i8* %1078
	%1081 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1082 = bitcast %runtime.Type_Info* %1081 to %runtime.Type_Info*
	%1083 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 6
	%1084 = getelementptr inbounds i64, i64* %1036, i64 6
	%1085 = getelementptr inbounds i8, i8* %1037, i64 6
	%1086 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %1086, %runtime.Type_Info** %1083
	%1087 = getelementptr inbounds %..string, %..string* %1035, i64 6
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$209, i32 0, i32 0), i64 12}, %..string* %1087
	store i64 81, i64* %1084
	store i8 0, i8* %1085
	%1088 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1089 = bitcast %runtime.Type_Info* %1088 to %runtime.Type_Info*
	%1090 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1034, i64 7
	%1091 = getelementptr inbounds i64, i64* %1036, i64 7
	%1092 = getelementptr inbounds i8, i8* %1037, i64 7
	%1093 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %1093, %runtime.Type_Info** %1090
	%1094 = getelementptr inbounds %..string, %..string* %1035, i64 7
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$20a, i32 0, i32 0), i64 12}, %..string* %1094
	store i64 82, i64* %1091
	store i8 0, i8* %1092
	%1095 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 0
	%1096 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1095, i32 0, i32 0
	store %runtime.Type_Info** %1034, %runtime.Type_Info*** %1096
	%1097 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1095, i32 0, i32 1
	store i64 8, i64* %1097
	%1098 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 1
	%1099 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1098, i32 0, i32 0
	store %..string* %1035, %..string** %1099
	%1100 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1098, i32 0, i32 1
	store i64 8, i64* %1100
	%1101 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 2
	%1102 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1101, i32 0, i32 0
	store i64* %1036, i64** %1102
	%1103 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1101, i32 0, i32 1
	store i64 8, i64* %1103
	%1104 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 3
	%1105 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1104, i32 0, i32 0
	store i8* %1037, i8** %1105
	%1106 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1104, i32 0, i32 1
	store i64 8, i64* %1106
	%1107 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, i32 0, i32 4
	%1108 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1107, i32 0, i32 0
	store %..string* %1038, %..string** %1108
	%1109 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1107, i32 0, i32 1
	store i64 8, i64* %1109
	%1110 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1030, align 8
	%1111 = bitcast {[0 x i64], [88 x i8], i64}* %1026 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1110, %runtime.Type_Info_Struct* %1111
	%1112 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1026, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1112
	%1113 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 52
	%1114 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1113, i32 0, i32 3
	%1115 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1113, i32 0, i32 0
	store i64 16, i64* %1115
	%1116 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1113, i32 0, i32 1
	store i64 8, i64* %1116
	%1117 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1113, i32 0, i32 2
	store %..typeid 1008806316530991156, %..typeid* %1117
	; Type_Info_Slice
	%1118 = bitcast {[0 x i64], [88 x i8], i64}* %1114 to %runtime.Type_Info_Slice*
	%1119 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	%1120 = bitcast %runtime.Type_Info* %1119 to %runtime.Type_Info*
	%1121 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1118, i32 0, i32 0
	store %runtime.Type_Info* %1120, %runtime.Type_Info** %1121
	%1122 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1118, i32 0, i32 1
	store i64 8, i64* %1122
	%1123 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1118, align 8
	%1124 = bitcast {[0 x i64], [88 x i8], i64}* %1114 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1123, %runtime.Type_Info_Slice* %1124
	%1125 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1114, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %1125
	%1126 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	%1127 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1126, i32 0, i32 3
	%1128 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1126, i32 0, i32 0
	store i64 8, i64* %1128
	%1129 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1126, i32 0, i32 1
	store i64 8, i64* %1129
	%1130 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1126, i32 0, i32 2
	store %..typeid 72057594037927989, %..typeid* %1130
	; Type_Info_Basic
	%1131 = bitcast {[0 x i64], [88 x i8], i64}* %1127 to %runtime.Type_Info_Integer*
	%1132 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1131, i32 0, i32 0
	store i8 0, i8* %1132
	%1133 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1131, i32 0, i32 1
	store i8 0, i8* %1133
	%1134 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1131, align 1
	%1135 = bitcast {[0 x i64], [88 x i8], i64}* %1127 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1134, %runtime.Type_Info_Integer* %1135
	%1136 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1127, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1136
	%1137 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 54
	%1138 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1137, i32 0, i32 3
	%1139 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1137, i32 0, i32 0
	store i64 8, i64* %1139
	%1140 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1137, i32 0, i32 1
	store i64 8, i64* %1140
	%1141 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1137, i32 0, i32 2
	store %..typeid 720575940379279414, %..typeid* %1141
	; Type_Info_Pointer
	%1142 = bitcast {[0 x i64], [88 x i8], i64}* %1138 to %runtime.Type_Info_Pointer*
	%1143 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	%1144 = bitcast %runtime.Type_Info* %1143 to %runtime.Type_Info*
	%1145 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1142, i32 0, i32 0
	store %runtime.Type_Info* %1144, %runtime.Type_Info** %1145
	%1146 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1142, align 8
	%1147 = bitcast {[0 x i64], [88 x i8], i64}* %1138 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1146, %runtime.Type_Info_Pointer* %1147
	%1148 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1138, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1148
	%1149 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 55
	%1150 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1149, i32 0, i32 3
	%1151 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1149, i32 0, i32 0
	store i64 16, i64* %1151
	%1152 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1149, i32 0, i32 1
	store i64 8, i64* %1152
	%1153 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1149, i32 0, i32 2
	store %..typeid 1008806316530991159, %..typeid* %1153
	; Type_Info_Slice
	%1154 = bitcast {[0 x i64], [88 x i8], i64}* %1150 to %runtime.Type_Info_Slice*
	%1155 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1156 = bitcast %runtime.Type_Info* %1155 to %runtime.Type_Info*
	%1157 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1154, i32 0, i32 0
	store %runtime.Type_Info* %1156, %runtime.Type_Info** %1157
	%1158 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1154, i32 0, i32 1
	store i64 1, i64* %1158
	%1159 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1154, align 8
	%1160 = bitcast {[0 x i64], [88 x i8], i64}* %1150 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1159, %runtime.Type_Info_Slice* %1160
	%1161 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1150, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %1161
	%1162 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 56
	%1163 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1162, i32 0, i32 3
	%1164 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1162, i32 0, i32 0
	store i64 8, i64* %1164
	%1165 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1162, i32 0, i32 1
	store i64 8, i64* %1165
	%1166 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1162, i32 0, i32 2
	store %..typeid 720575940379279416, %..typeid* %1166
	; Type_Info_Pointer
	%1167 = bitcast {[0 x i64], [88 x i8], i64}* %1163 to %runtime.Type_Info_Pointer*
	%1168 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1169 = bitcast %runtime.Type_Info* %1168 to %runtime.Type_Info*
	%1170 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1167, i32 0, i32 0
	store %runtime.Type_Info* %1169, %runtime.Type_Info** %1170
	%1171 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1167, align 8
	%1172 = bitcast {[0 x i64], [88 x i8], i64}* %1163 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1171, %runtime.Type_Info_Pointer* %1172
	%1173 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1163, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1173
	%1174 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 57
	%1175 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1174, i32 0, i32 3
	%1176 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1174, i32 0, i32 0
	store i64 40, i64* %1176
	%1177 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1174, i32 0, i32 1
	store i64 8, i64* %1177
	%1178 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1174, i32 0, i32 2
	store %..typeid 3458764513820540985, %..typeid* %1178
	; Type_Info_Named
	%1179 = bitcast {[0 x i64], [88 x i8], i64}* %1175 to %runtime.Type_Info_Named*
	%1180 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 58
	%1181 = bitcast %runtime.Type_Info* %1180 to %runtime.Type_Info*
	%1182 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1179, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([16 x i8], [16 x i8]* @str$20b, i32 0, i32 0), i64 15}, %..string* %1182
	%1183 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1179, i32 0, i32 1
	store %runtime.Type_Info* %1181, %runtime.Type_Info** %1183
	%1184 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1179, align 8
	%1185 = bitcast {[0 x i64], [88 x i8], i64}* %1175 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1184, %runtime.Type_Info_Named* %1185
	%1186 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1175, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1186
	%1187 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 58
	%1188 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1187, i32 0, i32 3
	%1189 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1187, i32 0, i32 0
	store i64 40, i64* %1189
	%1190 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1187, i32 0, i32 1
	store i64 8, i64* %1190
	%1191 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1187, i32 0, i32 2
	store %..typeid 1152921504606847034, %..typeid* %1191
	; Type_Info_Struct
	%1192 = bitcast {[0 x i64], [88 x i8], i64}* %1188 to %runtime.Type_Info_Struct*
	%1193 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 5
	store i8 0, i8* %1193
	%1194 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 6
	store i8 0, i8* %1194
	%1195 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 7
	store i8 0, i8* %1195
	%1196 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 53
	%1197 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 29
	%1198 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 29
	%1199 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 29
	%1200 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 29
	%1201 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	%1202 = bitcast %runtime.Type_Info* %1201 to %runtime.Type_Info*
	%1203 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1196, i64 0
	%1204 = getelementptr inbounds i64, i64* %1198, i64 0
	%1205 = getelementptr inbounds i8, i8* %1199, i64 0
	%1206 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 46
	store %runtime.Type_Info* %1206, %runtime.Type_Info** %1203
	%1207 = getelementptr inbounds %..string, %..string* %1197, i64 0
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$20c, i32 0, i32 0), i64 8}, %..string* %1207
	store i64 0, i64* %1204
	store i8 0, i8* %1205
	%1208 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	%1209 = bitcast %runtime.Type_Info* %1208 to %runtime.Type_Info*
	%1210 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1196, i64 1
	%1211 = getelementptr inbounds i64, i64* %1198, i64 1
	%1212 = getelementptr inbounds i8, i8* %1199, i64 1
	%1213 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	store %runtime.Type_Info* %1213, %runtime.Type_Info** %1210
	%1214 = getelementptr inbounds %..string, %..string* %1197, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$20d, i32 0, i32 0), i64 10}, %..string* %1214
	store i64 16, i64* %1211
	store i8 0, i8* %1212
	%1215 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1216 = bitcast %runtime.Type_Info* %1215 to %runtime.Type_Info*
	%1217 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1196, i64 2
	%1218 = getelementptr inbounds i64, i64* %1198, i64 2
	%1219 = getelementptr inbounds i8, i8* %1199, i64 2
	%1220 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1220, %runtime.Type_Info** %1217
	%1221 = getelementptr inbounds %..string, %..string* %1197, i64 2
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$20e, i32 0, i32 0), i64 8}, %..string* %1221
	store i64 24, i64* %1218
	store i8 0, i8* %1219
	%1222 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1223 = bitcast %runtime.Type_Info* %1222 to %runtime.Type_Info*
	%1224 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1196, i64 3
	%1225 = getelementptr inbounds i64, i64* %1198, i64 3
	%1226 = getelementptr inbounds i8, i8* %1199, i64 3
	%1227 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %1227, %runtime.Type_Info** %1224
	%1228 = getelementptr inbounds %..string, %..string* %1197, i64 3
	store %..string {i8* getelementptr inbounds ([13 x i8], [13 x i8]* @str$20f, i32 0, i32 0), i64 12}, %..string* %1228
	store i64 32, i64* %1225
	store i8 0, i8* %1226
	%1229 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1230 = bitcast %runtime.Type_Info* %1229 to %runtime.Type_Info*
	%1231 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1196, i64 4
	%1232 = getelementptr inbounds i64, i64* %1198, i64 4
	%1233 = getelementptr inbounds i8, i8* %1199, i64 4
	%1234 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %1234, %runtime.Type_Info** %1231
	%1235 = getelementptr inbounds %..string, %..string* %1197, i64 4
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$210, i32 0, i32 0), i64 6}, %..string* %1235
	store i64 33, i64* %1232
	store i8 0, i8* %1233
	%1236 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 0
	%1237 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1236, i32 0, i32 0
	store %runtime.Type_Info** %1196, %runtime.Type_Info*** %1237
	%1238 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1236, i32 0, i32 1
	store i64 5, i64* %1238
	%1239 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 1
	%1240 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1239, i32 0, i32 0
	store %..string* %1197, %..string** %1240
	%1241 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1239, i32 0, i32 1
	store i64 5, i64* %1241
	%1242 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 2
	%1243 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1242, i32 0, i32 0
	store i64* %1198, i64** %1243
	%1244 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1242, i32 0, i32 1
	store i64 5, i64* %1244
	%1245 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 3
	%1246 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1245, i32 0, i32 0
	store i8* %1199, i8** %1246
	%1247 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1245, i32 0, i32 1
	store i64 5, i64* %1247
	%1248 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, i32 0, i32 4
	%1249 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1248, i32 0, i32 0
	store %..string* %1200, %..string** %1249
	%1250 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1248, i32 0, i32 1
	store i64 5, i64* %1250
	%1251 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1192, align 8
	%1252 = bitcast {[0 x i64], [88 x i8], i64}* %1188 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1251, %runtime.Type_Info_Struct* %1252
	%1253 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1188, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1253
	%1254 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 59
	%1255 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1254, i32 0, i32 3
	%1256 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1254, i32 0, i32 0
	store i64 40, i64* %1256
	%1257 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1254, i32 0, i32 1
	store i64 8, i64* %1257
	%1258 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1254, i32 0, i32 2
	store %..typeid 3458764513820540987, %..typeid* %1258
	; Type_Info_Named
	%1259 = bitcast {[0 x i64], [88 x i8], i64}* %1255 to %runtime.Type_Info_Named*
	%1260 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 60
	%1261 = bitcast %runtime.Type_Info* %1260 to %runtime.Type_Info*
	%1262 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1259, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$211, i32 0, i32 0), i64 14}, %..string* %1262
	%1263 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1259, i32 0, i32 1
	store %runtime.Type_Info* %1261, %runtime.Type_Info** %1263
	%1264 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1259, align 8
	%1265 = bitcast {[0 x i64], [88 x i8], i64}* %1255 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1264, %runtime.Type_Info_Named* %1265
	%1266 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1255, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1266
	%1267 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 60
	%1268 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1267, i32 0, i32 3
	%1269 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1267, i32 0, i32 0
	store i64 40, i64* %1269
	%1270 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1267, i32 0, i32 1
	store i64 8, i64* %1270
	%1271 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1267, i32 0, i32 2
	store %..typeid 1152921504606847036, %..typeid* %1271
	; Type_Info_Struct
	%1272 = bitcast {[0 x i64], [88 x i8], i64}* %1268 to %runtime.Type_Info_Struct*
	%1273 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 5
	store i8 0, i8* %1273
	%1274 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 6
	store i8 0, i8* %1274
	%1275 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 7
	store i8 0, i8* %1275
	%1276 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 58
	%1277 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 34
	%1278 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 34
	%1279 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 34
	%1280 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 34
	%1281 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1282 = bitcast %runtime.Type_Info* %1281 to %runtime.Type_Info*
	%1283 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1276, i64 0
	%1284 = getelementptr inbounds i64, i64* %1278, i64 0
	%1285 = getelementptr inbounds i8, i8* %1279, i64 0
	%1286 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1286, %runtime.Type_Info** %1283
	%1287 = getelementptr inbounds %..string, %..string* %1277, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$212, i32 0, i32 0), i64 4}, %..string* %1287
	store i64 0, i64* %1284
	store i8 0, i8* %1285
	%1288 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	%1289 = bitcast %runtime.Type_Info* %1288 to %runtime.Type_Info*
	%1290 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1276, i64 1
	%1291 = getelementptr inbounds i64, i64* %1278, i64 1
	%1292 = getelementptr inbounds i8, i8* %1279, i64 1
	%1293 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	store %runtime.Type_Info* %1293, %runtime.Type_Info** %1290
	%1294 = getelementptr inbounds %..string, %..string* %1277, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$213, i32 0, i32 0), i64 5}, %..string* %1294
	store i64 8, i64* %1291
	store i8 0, i8* %1292
	%1295 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 61
	%1296 = bitcast %runtime.Type_Info* %1295 to %runtime.Type_Info*
	%1297 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1276, i64 2
	%1298 = getelementptr inbounds i64, i64* %1278, i64 2
	%1299 = getelementptr inbounds i8, i8* %1279, i64 2
	%1300 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 61
	store %runtime.Type_Info* %1300, %runtime.Type_Info** %1297
	%1301 = getelementptr inbounds %..string, %..string* %1277, i64 2
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$214, i32 0, i32 0), i64 6}, %..string* %1301
	store i64 24, i64* %1298
	store i8 0, i8* %1299
	%1302 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 0
	%1303 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1302, i32 0, i32 0
	store %runtime.Type_Info** %1276, %runtime.Type_Info*** %1303
	%1304 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1302, i32 0, i32 1
	store i64 3, i64* %1304
	%1305 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 1
	%1306 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1305, i32 0, i32 0
	store %..string* %1277, %..string** %1306
	%1307 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1305, i32 0, i32 1
	store i64 3, i64* %1307
	%1308 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 2
	%1309 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1308, i32 0, i32 0
	store i64* %1278, i64** %1309
	%1310 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1308, i32 0, i32 1
	store i64 3, i64* %1310
	%1311 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 3
	%1312 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1311, i32 0, i32 0
	store i8* %1279, i8** %1312
	%1313 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1311, i32 0, i32 1
	store i64 3, i64* %1313
	%1314 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, i32 0, i32 4
	%1315 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1314, i32 0, i32 0
	store %..string* %1280, %..string** %1315
	%1316 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1314, i32 0, i32 1
	store i64 3, i64* %1316
	%1317 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1272, align 8
	%1318 = bitcast {[0 x i64], [88 x i8], i64}* %1268 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1317, %runtime.Type_Info_Struct* %1318
	%1319 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1268, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1319
	%1320 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 61
	%1321 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1320, i32 0, i32 3
	%1322 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1320, i32 0, i32 0
	store i64 16, i64* %1322
	%1323 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1320, i32 0, i32 1
	store i64 8, i64* %1323
	%1324 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1320, i32 0, i32 2
	store %..typeid 1008806316530991165, %..typeid* %1324
	; Type_Info_Slice
	%1325 = bitcast {[0 x i64], [88 x i8], i64}* %1321 to %runtime.Type_Info_Slice*
	%1326 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 62
	%1327 = bitcast %runtime.Type_Info* %1326 to %runtime.Type_Info*
	%1328 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1325, i32 0, i32 0
	store %runtime.Type_Info* %1327, %runtime.Type_Info** %1328
	%1329 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1325, i32 0, i32 1
	store i64 16, i64* %1329
	%1330 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1325, align 8
	%1331 = bitcast {[0 x i64], [88 x i8], i64}* %1321 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1330, %runtime.Type_Info_Slice* %1331
	%1332 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1321, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %1332
	%1333 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 62
	%1334 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1333, i32 0, i32 3
	%1335 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1333, i32 0, i32 0
	store i64 16, i64* %1335
	%1336 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1333, i32 0, i32 1
	store i64 8, i64* %1336
	%1337 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1333, i32 0, i32 2
	store %..typeid 3530822107858468926, %..typeid* %1337
	; Type_Info_Named
	%1338 = bitcast {[0 x i64], [88 x i8], i64}* %1334 to %runtime.Type_Info_Named*
	%1339 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 63
	%1340 = bitcast %runtime.Type_Info* %1339 to %runtime.Type_Info*
	%1341 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1338, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$215, i32 0, i32 0), i64 20}, %..string* %1341
	%1342 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1338, i32 0, i32 1
	store %runtime.Type_Info* %1340, %runtime.Type_Info** %1342
	%1343 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1338, align 8
	%1344 = bitcast {[0 x i64], [88 x i8], i64}* %1334 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1343, %runtime.Type_Info_Named* %1344
	%1345 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1334, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1345
	%1346 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 63
	%1347 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1346, i32 0, i32 3
	%1348 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1346, i32 0, i32 0
	store i64 16, i64* %1348
	%1349 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1346, i32 0, i32 1
	store i64 8, i64* %1349
	%1350 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1346, i32 0, i32 2
	store %..typeid 1224979098644774975, %..typeid* %1350
	; Type_Info_Union
	%1351 = bitcast {[0 x i64], [88 x i8], i64}* %1347 to %runtime.Type_Info_Union*
	%1352 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1351, i32 0, i32 0
	%1353 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1351, i32 0, i32 1
	%1354 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1351, i32 0, i32 2
	%1355 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1351, i32 0, i32 3
	%1356 = getelementptr inbounds %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1351, i32 0, i32 4
	%1357 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 61
	%1358 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 64
	%1359 = bitcast %runtime.Type_Info* %1358 to %runtime.Type_Info*
	%1360 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 0
	%1361 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 64
	store %runtime.Type_Info* %1361, %runtime.Type_Info** %1360
	%1362 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 65
	%1363 = bitcast %runtime.Type_Info* %1362 to %runtime.Type_Info*
	%1364 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 1
	%1365 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 65
	store %runtime.Type_Info* %1365, %runtime.Type_Info** %1364
	%1366 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 66
	%1367 = bitcast %runtime.Type_Info* %1366 to %runtime.Type_Info*
	%1368 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 2
	%1369 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 66
	store %runtime.Type_Info* %1369, %runtime.Type_Info** %1368
	%1370 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 67
	%1371 = bitcast %runtime.Type_Info* %1370 to %runtime.Type_Info*
	%1372 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 3
	%1373 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 67
	store %runtime.Type_Info* %1373, %runtime.Type_Info** %1372
	%1374 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	%1375 = bitcast %runtime.Type_Info* %1374 to %runtime.Type_Info*
	%1376 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 4
	%1377 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	store %runtime.Type_Info* %1377, %runtime.Type_Info** %1376
	%1378 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%1379 = bitcast %runtime.Type_Info* %1378 to %runtime.Type_Info*
	%1380 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 5
	%1381 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %1381, %runtime.Type_Info** %1380
	%1382 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 3
	%1383 = bitcast %runtime.Type_Info* %1382 to %runtime.Type_Info*
	%1384 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 6
	%1385 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 3
	store %runtime.Type_Info* %1385, %runtime.Type_Info** %1384
	%1386 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 69
	%1387 = bitcast %runtime.Type_Info* %1386 to %runtime.Type_Info*
	%1388 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 7
	%1389 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 69
	store %runtime.Type_Info* %1389, %runtime.Type_Info** %1388
	%1390 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 70
	%1391 = bitcast %runtime.Type_Info* %1390 to %runtime.Type_Info*
	%1392 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 8
	%1393 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 70
	store %runtime.Type_Info* %1393, %runtime.Type_Info** %1392
	%1394 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	%1395 = bitcast %runtime.Type_Info* %1394 to %runtime.Type_Info*
	%1396 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 9
	%1397 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	store %runtime.Type_Info* %1397, %runtime.Type_Info** %1396
	%1398 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 72
	%1399 = bitcast %runtime.Type_Info* %1398 to %runtime.Type_Info*
	%1400 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 10
	%1401 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 72
	store %runtime.Type_Info* %1401, %runtime.Type_Info** %1400
	%1402 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	%1403 = bitcast %runtime.Type_Info* %1402 to %runtime.Type_Info*
	%1404 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1357, i64 11
	%1405 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 53
	store %runtime.Type_Info* %1405, %runtime.Type_Info** %1404
	%1406 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1352, i32 0, i32 0
	store %runtime.Type_Info** %1357, %runtime.Type_Info*** %1406
	%1407 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1352, i32 0, i32 1
	store i64 12, i64* %1407
	store i64 8, i64* %1353
	%1408 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	store %runtime.Type_Info* %1408, %runtime.Type_Info** %1354
	store i8 0, i8* %1355
	store i8 0, i8* %1356
	%1409 = load %runtime.Type_Info_Union, %runtime.Type_Info_Union* %1351, align 8
	%1410 = bitcast {[0 x i64], [88 x i8], i64}* %1347 to %runtime.Type_Info_Union*
	store %runtime.Type_Info_Union %1409, %runtime.Type_Info_Union* %1410
	%1411 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1347, i64 0, i32 2 ; UnionTagPtr
	store i64 18, i64* %1411
	%1412 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 64
	%1413 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1412, i32 0, i32 3
	%1414 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1412, i32 0, i32 0
	store i64 4, i64* %1414
	%1415 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1412, i32 0, i32 1
	store i64 4, i64* %1415
	%1416 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1412, i32 0, i32 2
	store %..typeid 4755801206503243840, %..typeid* %1416
	; Type_Info_Basic
	%1417 = bitcast {[0 x i64], [88 x i8], i64}* %1413 to %runtime.Type_Info_Rune*
	%1418 = load %runtime.Type_Info_Rune, %runtime.Type_Info_Rune* %1417, align 1
	%1419 = bitcast {[0 x i64], [88 x i8], i64}* %1413 to %runtime.Type_Info_Rune*
	store %runtime.Type_Info_Rune %1418, %runtime.Type_Info_Rune* %1419
	%1420 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1413, i64 0, i32 2 ; UnionTagPtr
	store i64 3, i64* %1420
	%1421 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 65
	%1422 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1421, i32 0, i32 3
	%1423 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1421, i32 0, i32 0
	store i64 1, i64* %1423
	%1424 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1421, i32 0, i32 1
	store i64 1, i64* %1424
	%1425 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1421, i32 0, i32 2
	store %..typeid 4683743612465315905, %..typeid* %1425
	; Type_Info_Basic
	%1426 = bitcast {[0 x i64], [88 x i8], i64}* %1422 to %runtime.Type_Info_Integer*
	%1427 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1426, i32 0, i32 0
	store i8 1, i8* %1427
	%1428 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1426, i32 0, i32 1
	store i8 0, i8* %1428
	%1429 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1426, align 1
	%1430 = bitcast {[0 x i64], [88 x i8], i64}* %1422 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1429, %runtime.Type_Info_Integer* %1430
	%1431 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1422, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1431
	%1432 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 66
	%1433 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1432, i32 0, i32 3
	%1434 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1432, i32 0, i32 0
	store i64 2, i64* %1434
	%1435 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1432, i32 0, i32 1
	store i64 2, i64* %1435
	%1436 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1432, i32 0, i32 2
	store %..typeid 4683743612465315906, %..typeid* %1436
	; Type_Info_Basic
	%1437 = bitcast {[0 x i64], [88 x i8], i64}* %1433 to %runtime.Type_Info_Integer*
	%1438 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1437, i32 0, i32 0
	store i8 1, i8* %1438
	%1439 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1437, i32 0, i32 1
	store i8 0, i8* %1439
	%1440 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1437, align 1
	%1441 = bitcast {[0 x i64], [88 x i8], i64}* %1433 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1440, %runtime.Type_Info_Integer* %1441
	%1442 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1433, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1442
	%1443 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 67
	%1444 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1443, i32 0, i32 3
	%1445 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1443, i32 0, i32 0
	store i64 4, i64* %1445
	%1446 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1443, i32 0, i32 1
	store i64 4, i64* %1446
	%1447 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1443, i32 0, i32 2
	store %..typeid 4683743612465315907, %..typeid* %1447
	; Type_Info_Basic
	%1448 = bitcast {[0 x i64], [88 x i8], i64}* %1444 to %runtime.Type_Info_Integer*
	%1449 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1448, i32 0, i32 0
	store i8 1, i8* %1449
	%1450 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1448, i32 0, i32 1
	store i8 0, i8* %1450
	%1451 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1448, align 1
	%1452 = bitcast {[0 x i64], [88 x i8], i64}* %1444 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1451, %runtime.Type_Info_Integer* %1452
	%1453 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1444, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1453
	%1454 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	%1455 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1454, i32 0, i32 3
	%1456 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1454, i32 0, i32 0
	store i64 8, i64* %1456
	%1457 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1454, i32 0, i32 1
	store i64 8, i64* %1457
	%1458 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1454, i32 0, i32 2
	store %..typeid 4683743612465315908, %..typeid* %1458
	; Type_Info_Basic
	%1459 = bitcast {[0 x i64], [88 x i8], i64}* %1455 to %runtime.Type_Info_Integer*
	%1460 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1459, i32 0, i32 0
	store i8 1, i8* %1460
	%1461 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1459, i32 0, i32 1
	store i8 0, i8* %1461
	%1462 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1459, align 1
	%1463 = bitcast {[0 x i64], [88 x i8], i64}* %1455 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1462, %runtime.Type_Info_Integer* %1463
	%1464 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1455, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1464
	%1465 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 69
	%1466 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i32 0, i32 3
	%1467 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i32 0, i32 0
	store i64 2, i64* %1467
	%1468 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i32 0, i32 1
	store i64 2, i64* %1468
	%1469 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1465, i32 0, i32 2
	store %..typeid 72057594037928005, %..typeid* %1469
	; Type_Info_Basic
	%1470 = bitcast {[0 x i64], [88 x i8], i64}* %1466 to %runtime.Type_Info_Integer*
	%1471 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1470, i32 0, i32 0
	store i8 0, i8* %1471
	%1472 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1470, i32 0, i32 1
	store i8 0, i8* %1472
	%1473 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1470, align 1
	%1474 = bitcast {[0 x i64], [88 x i8], i64}* %1466 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1473, %runtime.Type_Info_Integer* %1474
	%1475 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1466, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1475
	%1476 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 70
	%1477 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1476, i32 0, i32 3
	%1478 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1476, i32 0, i32 0
	store i64 4, i64* %1478
	%1479 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1476, i32 0, i32 1
	store i64 4, i64* %1479
	%1480 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1476, i32 0, i32 2
	store %..typeid 72057594037928006, %..typeid* %1480
	; Type_Info_Basic
	%1481 = bitcast {[0 x i64], [88 x i8], i64}* %1477 to %runtime.Type_Info_Integer*
	%1482 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1481, i32 0, i32 0
	store i8 0, i8* %1482
	%1483 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1481, i32 0, i32 1
	store i8 0, i8* %1483
	%1484 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1481, align 1
	%1485 = bitcast {[0 x i64], [88 x i8], i64}* %1477 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1484, %runtime.Type_Info_Integer* %1485
	%1486 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1477, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1486
	%1487 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	%1488 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1487, i32 0, i32 3
	%1489 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1487, i32 0, i32 0
	store i64 8, i64* %1489
	%1490 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1487, i32 0, i32 1
	store i64 8, i64* %1490
	%1491 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1487, i32 0, i32 2
	store %..typeid 72057594037928007, %..typeid* %1491
	; Type_Info_Basic
	%1492 = bitcast {[0 x i64], [88 x i8], i64}* %1488 to %runtime.Type_Info_Integer*
	%1493 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1492, i32 0, i32 0
	store i8 0, i8* %1493
	%1494 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1492, i32 0, i32 1
	store i8 0, i8* %1494
	%1495 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1492, align 1
	%1496 = bitcast {[0 x i64], [88 x i8], i64}* %1488 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1495, %runtime.Type_Info_Integer* %1496
	%1497 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1488, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1497
	%1498 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 72
	%1499 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1498, i32 0, i32 3
	%1500 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1498, i32 0, i32 0
	store i64 8, i64* %1500
	%1501 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1498, i32 0, i32 1
	store i64 8, i64* %1501
	%1502 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1498, i32 0, i32 2
	store %..typeid 72057594037928008, %..typeid* %1502
	; Type_Info_Basic
	%1503 = bitcast {[0 x i64], [88 x i8], i64}* %1499 to %runtime.Type_Info_Integer*
	%1504 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1503, i32 0, i32 0
	store i8 0, i8* %1504
	%1505 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1503, i32 0, i32 1
	store i8 0, i8* %1505
	%1506 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %1503, align 1
	%1507 = bitcast {[0 x i64], [88 x i8], i64}* %1499 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %1506, %runtime.Type_Info_Integer* %1507
	%1508 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1499, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %1508
	%1509 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 73
	%1510 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1509, i32 0, i32 3
	%1511 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1509, i32 0, i32 0
	store i64 8, i64* %1511
	%1512 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1509, i32 0, i32 1
	store i64 8, i64* %1512
	%1513 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1509, i32 0, i32 2
	store %..typeid 720575940379279433, %..typeid* %1513
	; Type_Info_Pointer
	%1514 = bitcast {[0 x i64], [88 x i8], i64}* %1510 to %runtime.Type_Info_Pointer*
	%1515 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 62
	%1516 = bitcast %runtime.Type_Info* %1515 to %runtime.Type_Info*
	%1517 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1514, i32 0, i32 0
	store %runtime.Type_Info* %1516, %runtime.Type_Info** %1517
	%1518 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1514, align 8
	%1519 = bitcast {[0 x i64], [88 x i8], i64}* %1510 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1518, %runtime.Type_Info_Pointer* %1519
	%1520 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1510, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1520
	%1521 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 74
	%1522 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1521, i32 0, i32 3
	%1523 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1521, i32 0, i32 0
	store i64 24, i64* %1523
	%1524 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1521, i32 0, i32 1
	store i64 8, i64* %1524
	%1525 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1521, i32 0, i32 2
	store %..typeid 3458764513820541002, %..typeid* %1525
	; Type_Info_Named
	%1526 = bitcast {[0 x i64], [88 x i8], i64}* %1522 to %runtime.Type_Info_Named*
	%1527 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 75
	%1528 = bitcast %runtime.Type_Info* %1527 to %runtime.Type_Info*
	%1529 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1526, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([14 x i8], [14 x i8]* @str$216, i32 0, i32 0), i64 13}, %..string* %1529
	%1530 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1526, i32 0, i32 1
	store %runtime.Type_Info* %1528, %runtime.Type_Info** %1530
	%1531 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1526, align 8
	%1532 = bitcast {[0 x i64], [88 x i8], i64}* %1522 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1531, %runtime.Type_Info_Named* %1532
	%1533 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1522, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1533
	%1534 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 75
	%1535 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i32 0, i32 3
	%1536 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i32 0, i32 0
	store i64 24, i64* %1536
	%1537 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i32 0, i32 1
	store i64 8, i64* %1537
	%1538 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1534, i32 0, i32 2
	store %..typeid 1152921504606847051, %..typeid* %1538
	; Type_Info_Struct
	%1539 = bitcast {[0 x i64], [88 x i8], i64}* %1535 to %runtime.Type_Info_Struct*
	%1540 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 5
	store i8 0, i8* %1540
	%1541 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 6
	store i8 0, i8* %1541
	%1542 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 7
	store i8 0, i8* %1542
	%1543 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 73
	%1544 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 37
	%1545 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 37
	%1546 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 37
	%1547 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 37
	%1548 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1549 = bitcast %runtime.Type_Info* %1548 to %runtime.Type_Info*
	%1550 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1543, i64 0
	%1551 = getelementptr inbounds i64, i64* %1545, i64 0
	%1552 = getelementptr inbounds i8, i8* %1546, i64 0
	%1553 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1553, %runtime.Type_Info** %1550
	%1554 = getelementptr inbounds %..string, %..string* %1544, i64 0
	store %..string {i8* getelementptr inbounds ([4 x i8], [4 x i8]* @str$217, i32 0, i32 0), i64 3}, %..string* %1554
	store i64 0, i64* %1551
	store i8 0, i8* %1552
	%1555 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1556 = bitcast %runtime.Type_Info* %1555 to %runtime.Type_Info*
	%1557 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1543, i64 1
	%1558 = getelementptr inbounds i64, i64* %1545, i64 1
	%1559 = getelementptr inbounds i8, i8* %1546, i64 1
	%1560 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1560, %runtime.Type_Info** %1557
	%1561 = getelementptr inbounds %..string, %..string* %1544, i64 1
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$218, i32 0, i32 0), i64 5}, %..string* %1561
	store i64 8, i64* %1558
	store i8 0, i8* %1559
	%1562 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1563 = bitcast %runtime.Type_Info* %1562 to %runtime.Type_Info*
	%1564 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1543, i64 2
	%1565 = getelementptr inbounds i64, i64* %1545, i64 2
	%1566 = getelementptr inbounds i8, i8* %1546, i64 2
	%1567 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1567, %runtime.Type_Info** %1564
	%1568 = getelementptr inbounds %..string, %..string* %1544, i64 2
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$219, i32 0, i32 0), i64 16}, %..string* %1568
	store i64 16, i64* %1565
	store i8 0, i8* %1566
	%1569 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 0
	%1570 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1569, i32 0, i32 0
	store %runtime.Type_Info** %1543, %runtime.Type_Info*** %1570
	%1571 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1569, i32 0, i32 1
	store i64 3, i64* %1571
	%1572 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 1
	%1573 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1572, i32 0, i32 0
	store %..string* %1544, %..string** %1573
	%1574 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1572, i32 0, i32 1
	store i64 3, i64* %1574
	%1575 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 2
	%1576 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1575, i32 0, i32 0
	store i64* %1545, i64** %1576
	%1577 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1575, i32 0, i32 1
	store i64 3, i64* %1577
	%1578 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 3
	%1579 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1578, i32 0, i32 0
	store i8* %1546, i8** %1579
	%1580 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1578, i32 0, i32 1
	store i64 3, i64* %1580
	%1581 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, i32 0, i32 4
	%1582 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1581, i32 0, i32 0
	store %..string* %1547, %..string** %1582
	%1583 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1581, i32 0, i32 1
	store i64 3, i64* %1583
	%1584 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1539, align 8
	%1585 = bitcast {[0 x i64], [88 x i8], i64}* %1535 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1584, %runtime.Type_Info_Struct* %1585
	%1586 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1535, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1586
	%1587 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 76
	%1588 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1587, i32 0, i32 3
	%1589 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1587, i32 0, i32 0
	store i64 48, i64* %1589
	%1590 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1587, i32 0, i32 1
	store i64 8, i64* %1590
	%1591 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1587, i32 0, i32 2
	store %..typeid 3458764513820541004, %..typeid* %1591
	; Type_Info_Named
	%1592 = bitcast {[0 x i64], [88 x i8], i64}* %1588 to %runtime.Type_Info_Named*
	%1593 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 77
	%1594 = bitcast %runtime.Type_Info* %1593 to %runtime.Type_Info*
	%1595 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1592, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([20 x i8], [20 x i8]* @str$21a, i32 0, i32 0), i64 19}, %..string* %1595
	%1596 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1592, i32 0, i32 1
	store %runtime.Type_Info* %1594, %runtime.Type_Info** %1596
	%1597 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1592, align 8
	%1598 = bitcast {[0 x i64], [88 x i8], i64}* %1588 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1597, %runtime.Type_Info_Named* %1598
	%1599 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1588, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1599
	%1600 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 77
	%1601 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1600, i32 0, i32 3
	%1602 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1600, i32 0, i32 0
	store i64 48, i64* %1602
	%1603 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1600, i32 0, i32 1
	store i64 8, i64* %1603
	%1604 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1600, i32 0, i32 2
	store %..typeid 1152921504606847053, %..typeid* %1604
	; Type_Info_Struct
	%1605 = bitcast {[0 x i64], [88 x i8], i64}* %1601 to %runtime.Type_Info_Struct*
	%1606 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 5
	store i8 0, i8* %1606
	%1607 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 6
	store i8 0, i8* %1607
	%1608 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 7
	store i8 0, i8* %1608
	%1609 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 76
	%1610 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 40
	%1611 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 40
	%1612 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 40
	%1613 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 40
	%1614 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	%1615 = bitcast %runtime.Type_Info* %1614 to %runtime.Type_Info*
	%1616 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1609, i64 0
	%1617 = getelementptr inbounds i64, i64* %1611, i64 0
	%1618 = getelementptr inbounds i8, i8* %1612, i64 0
	%1619 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 48
	store %runtime.Type_Info* %1619, %runtime.Type_Info** %1616
	%1620 = getelementptr inbounds %..string, %..string* %1610, i64 0
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$21b, i32 0, i32 0), i64 5}, %..string* %1620
	store i64 0, i64* %1617
	store i8 0, i8* %1618
	%1621 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 78
	%1622 = bitcast %runtime.Type_Info* %1621 to %runtime.Type_Info*
	%1623 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1609, i64 1
	%1624 = getelementptr inbounds i64, i64* %1611, i64 1
	%1625 = getelementptr inbounds i8, i8* %1612, i64 1
	%1626 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 78
	store %runtime.Type_Info* %1626, %runtime.Type_Info** %1623
	%1627 = getelementptr inbounds %..string, %..string* %1610, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$21c, i32 0, i32 0), i64 4}, %..string* %1627
	store i64 16, i64* %1624
	store i8 0, i8* %1625
	%1628 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 78
	%1629 = bitcast %runtime.Type_Info* %1628 to %runtime.Type_Info*
	%1630 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1609, i64 2
	%1631 = getelementptr inbounds i64, i64* %1611, i64 2
	%1632 = getelementptr inbounds i8, i8* %1612, i64 2
	%1633 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 78
	store %runtime.Type_Info* %1633, %runtime.Type_Info** %1630
	%1634 = getelementptr inbounds %..string, %..string* %1610, i64 2
	store %..string {i8* getelementptr inbounds ([8 x i8], [8 x i8]* @str$21d, i32 0, i32 0), i64 7}, %..string* %1634
	store i64 32, i64* %1631
	store i8 0, i8* %1632
	%1635 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 0
	%1636 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1635, i32 0, i32 0
	store %runtime.Type_Info** %1609, %runtime.Type_Info*** %1636
	%1637 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1635, i32 0, i32 1
	store i64 3, i64* %1637
	%1638 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 1
	%1639 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1638, i32 0, i32 0
	store %..string* %1610, %..string** %1639
	%1640 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1638, i32 0, i32 1
	store i64 3, i64* %1640
	%1641 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 2
	%1642 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1641, i32 0, i32 0
	store i64* %1611, i64** %1642
	%1643 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1641, i32 0, i32 1
	store i64 3, i64* %1643
	%1644 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 3
	%1645 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1644, i32 0, i32 0
	store i8* %1612, i8** %1645
	%1646 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1644, i32 0, i32 1
	store i64 3, i64* %1646
	%1647 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, i32 0, i32 4
	%1648 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1647, i32 0, i32 0
	store %..string* %1613, %..string** %1648
	%1649 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1647, i32 0, i32 1
	store i64 3, i64* %1649
	%1650 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1605, align 8
	%1651 = bitcast {[0 x i64], [88 x i8], i64}* %1601 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1650, %runtime.Type_Info_Struct* %1651
	%1652 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1601, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1652
	%1653 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 78
	%1654 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1653, i32 0, i32 3
	%1655 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1653, i32 0, i32 0
	store i64 16, i64* %1655
	%1656 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1653, i32 0, i32 1
	store i64 8, i64* %1656
	%1657 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1653, i32 0, i32 2
	store %..typeid 1008806316530991182, %..typeid* %1657
	; Type_Info_Slice
	%1658 = bitcast {[0 x i64], [88 x i8], i64}* %1654 to %runtime.Type_Info_Slice*
	%1659 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 67
	%1660 = bitcast %runtime.Type_Info* %1659 to %runtime.Type_Info*
	%1661 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1658, i32 0, i32 0
	store %runtime.Type_Info* %1660, %runtime.Type_Info** %1661
	%1662 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1658, i32 0, i32 1
	store i64 4, i64* %1662
	%1663 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1658, align 8
	%1664 = bitcast {[0 x i64], [88 x i8], i64}* %1654 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1663, %runtime.Type_Info_Slice* %1664
	%1665 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1654, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %1665
	%1666 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 79
	%1667 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1666, i32 0, i32 3
	%1668 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1666, i32 0, i32 0
	store i64 8, i64* %1668
	%1669 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1666, i32 0, i32 1
	store i64 8, i64* %1669
	%1670 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1666, i32 0, i32 2
	store %..typeid 720575940379279439, %..typeid* %1670
	; Type_Info_Pointer
	%1671 = bitcast {[0 x i64], [88 x i8], i64}* %1667 to %runtime.Type_Info_Pointer*
	%1672 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 67
	%1673 = bitcast %runtime.Type_Info* %1672 to %runtime.Type_Info*
	%1674 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1671, i32 0, i32 0
	store %runtime.Type_Info* %1673, %runtime.Type_Info** %1674
	%1675 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1671, align 8
	%1676 = bitcast {[0 x i64], [88 x i8], i64}* %1667 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1675, %runtime.Type_Info_Pointer* %1676
	%1677 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1667, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1677
	%1678 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 80
	%1679 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1678, i32 0, i32 3
	%1680 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1678, i32 0, i32 0
	store i64 32, i64* %1680
	%1681 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1678, i32 0, i32 1
	store i64 8, i64* %1681
	%1682 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1678, i32 0, i32 2
	store %..typeid 3458764513820541008, %..typeid* %1682
	; Type_Info_Named
	%1683 = bitcast {[0 x i64], [88 x i8], i64}* %1679 to %runtime.Type_Info_Named*
	%1684 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 81
	%1685 = bitcast %runtime.Type_Info* %1684 to %runtime.Type_Info*
	%1686 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1683, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$21e, i32 0, i32 0), i64 17}, %..string* %1686
	%1687 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1683, i32 0, i32 1
	store %runtime.Type_Info* %1685, %runtime.Type_Info** %1687
	%1688 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1683, align 8
	%1689 = bitcast {[0 x i64], [88 x i8], i64}* %1679 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1688, %runtime.Type_Info_Named* %1689
	%1690 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1679, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1690
	%1691 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 81
	%1692 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1691, i32 0, i32 3
	%1693 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1691, i32 0, i32 0
	store i64 32, i64* %1693
	%1694 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1691, i32 0, i32 1
	store i64 8, i64* %1694
	%1695 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1691, i32 0, i32 2
	store %..typeid 1152921504606847057, %..typeid* %1695
	; Type_Info_Struct
	%1696 = bitcast {[0 x i64], [88 x i8], i64}* %1692 to %runtime.Type_Info_Struct*
	%1697 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 5
	store i8 0, i8* %1697
	%1698 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 6
	store i8 0, i8* %1698
	%1699 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 7
	store i8 0, i8* %1699
	%1700 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 79
	%1701 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 43
	%1702 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 43
	%1703 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 43
	%1704 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 43
	%1705 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1706 = bitcast %runtime.Type_Info* %1705 to %runtime.Type_Info*
	%1707 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1700, i64 0
	%1708 = getelementptr inbounds i64, i64* %1702, i64 0
	%1709 = getelementptr inbounds i8, i8* %1703, i64 0
	%1710 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1710, %runtime.Type_Info** %1707
	%1711 = getelementptr inbounds %..string, %..string* %1701, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$21f, i32 0, i32 0), i64 4}, %..string* %1711
	store i64 0, i64* %1708
	store i8 0, i8* %1709
	%1712 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1713 = bitcast %runtime.Type_Info* %1712 to %runtime.Type_Info*
	%1714 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1700, i64 1
	%1715 = getelementptr inbounds i64, i64* %1702, i64 1
	%1716 = getelementptr inbounds i8, i8* %1703, i64 1
	%1717 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1717, %runtime.Type_Info** %1714
	%1718 = getelementptr inbounds %..string, %..string* %1701, i64 1
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$220, i32 0, i32 0), i64 10}, %..string* %1718
	store i64 8, i64* %1715
	store i8 0, i8* %1716
	%1719 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	%1720 = bitcast %runtime.Type_Info* %1719 to %runtime.Type_Info*
	%1721 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1700, i64 2
	%1722 = getelementptr inbounds i64, i64* %1702, i64 2
	%1723 = getelementptr inbounds i8, i8* %1703, i64 2
	%1724 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	store %runtime.Type_Info* %1724, %runtime.Type_Info** %1721
	%1725 = getelementptr inbounds %..string, %..string* %1701, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$221, i32 0, i32 0), i64 5}, %..string* %1725
	store i64 16, i64* %1722
	store i8 0, i8* %1723
	%1726 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	%1727 = bitcast %runtime.Type_Info* %1726 to %runtime.Type_Info*
	%1728 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1700, i64 3
	%1729 = getelementptr inbounds i64, i64* %1702, i64 3
	%1730 = getelementptr inbounds i8, i8* %1703, i64 3
	%1731 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 68
	store %runtime.Type_Info* %1731, %runtime.Type_Info** %1728
	%1732 = getelementptr inbounds %..string, %..string* %1701, i64 3
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$222, i32 0, i32 0), i64 5}, %..string* %1732
	store i64 24, i64* %1729
	store i8 0, i8* %1730
	%1733 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 0
	%1734 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1733, i32 0, i32 0
	store %runtime.Type_Info** %1700, %runtime.Type_Info*** %1734
	%1735 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1733, i32 0, i32 1
	store i64 4, i64* %1735
	%1736 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 1
	%1737 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1736, i32 0, i32 0
	store %..string* %1701, %..string** %1737
	%1738 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1736, i32 0, i32 1
	store i64 4, i64* %1738
	%1739 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 2
	%1740 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1739, i32 0, i32 0
	store i64* %1702, i64** %1740
	%1741 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1739, i32 0, i32 1
	store i64 4, i64* %1741
	%1742 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 3
	%1743 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1742, i32 0, i32 0
	store i8* %1703, i8** %1743
	%1744 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1742, i32 0, i32 1
	store i64 4, i64* %1744
	%1745 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, i32 0, i32 4
	%1746 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1745, i32 0, i32 0
	store %..string* %1704, %..string** %1746
	%1747 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1745, i32 0, i32 1
	store i64 4, i64* %1747
	%1748 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1696, align 8
	%1749 = bitcast {[0 x i64], [88 x i8], i64}* %1692 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1748, %runtime.Type_Info_Struct* %1749
	%1750 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1692, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1750
	%1751 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 82
	%1752 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1751, i32 0, i32 3
	%1753 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1751, i32 0, i32 0
	store i64 8, i64* %1753
	%1754 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1751, i32 0, i32 1
	store i64 8, i64* %1754
	%1755 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1751, i32 0, i32 2
	store %..typeid 3458764513820541010, %..typeid* %1755
	; Type_Info_Named
	%1756 = bitcast {[0 x i64], [88 x i8], i64}* %1752 to %runtime.Type_Info_Named*
	%1757 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 34
	%1758 = bitcast %runtime.Type_Info* %1757 to %runtime.Type_Info*
	%1759 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1756, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([17 x i8], [17 x i8]* @str$223, i32 0, i32 0), i64 16}, %..string* %1759
	%1760 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1756, i32 0, i32 1
	store %runtime.Type_Info* %1758, %runtime.Type_Info** %1760
	%1761 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1756, align 8
	%1762 = bitcast {[0 x i64], [88 x i8], i64}* %1752 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1761, %runtime.Type_Info_Named* %1762
	%1763 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1752, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1763
	%1764 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 83
	%1765 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1764, i32 0, i32 3
	%1766 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1764, i32 0, i32 0
	store i64 32, i64* %1766
	%1767 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1764, i32 0, i32 1
	store i64 8, i64* %1767
	%1768 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1764, i32 0, i32 2
	store %..typeid 3458764513820541011, %..typeid* %1768
	; Type_Info_Named
	%1769 = bitcast {[0 x i64], [88 x i8], i64}* %1765 to %runtime.Type_Info_Named*
	%1770 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 84
	%1771 = bitcast %runtime.Type_Info* %1770 to %runtime.Type_Info*
	%1772 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1769, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([22 x i8], [22 x i8]* @str$224, i32 0, i32 0), i64 21}, %..string* %1772
	%1773 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1769, i32 0, i32 1
	store %runtime.Type_Info* %1771, %runtime.Type_Info** %1773
	%1774 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1769, align 8
	%1775 = bitcast {[0 x i64], [88 x i8], i64}* %1765 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1774, %runtime.Type_Info_Named* %1775
	%1776 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1765, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1776
	%1777 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 84
	%1778 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1777, i32 0, i32 3
	%1779 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1777, i32 0, i32 0
	store i64 32, i64* %1779
	%1780 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1777, i32 0, i32 1
	store i64 8, i64* %1780
	%1781 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1777, i32 0, i32 2
	store %..typeid 1152921504606847060, %..typeid* %1781
	; Type_Info_Struct
	%1782 = bitcast {[0 x i64], [88 x i8], i64}* %1778 to %runtime.Type_Info_Struct*
	%1783 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 5
	store i8 0, i8* %1783
	%1784 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 6
	store i8 0, i8* %1784
	%1785 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 7
	store i8 0, i8* %1785
	%1786 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 83
	%1787 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 47
	%1788 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 47
	%1789 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 47
	%1790 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 47
	%1791 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	%1792 = bitcast %runtime.Type_Info* %1791 to %runtime.Type_Info*
	%1793 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1786, i64 0
	%1794 = getelementptr inbounds i64, i64* %1788, i64 0
	%1795 = getelementptr inbounds i8, i8* %1789, i64 0
	%1796 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 11
	store %runtime.Type_Info* %1796, %runtime.Type_Info** %1793
	%1797 = getelementptr inbounds %..string, %..string* %1787, i64 0
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$225, i32 0, i32 0), i64 4}, %..string* %1797
	store i64 0, i64* %1794
	store i8 0, i8* %1795
	%1798 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%1799 = bitcast %runtime.Type_Info* %1798 to %runtime.Type_Info*
	%1800 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1786, i64 1
	%1801 = getelementptr inbounds i64, i64* %1788, i64 1
	%1802 = getelementptr inbounds i8, i8* %1789, i64 1
	%1803 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %1803, %runtime.Type_Info** %1800
	%1804 = getelementptr inbounds %..string, %..string* %1787, i64 1
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$226, i32 0, i32 0), i64 9}, %..string* %1804
	store i64 8, i64* %1801
	store i8 0, i8* %1802
	%1805 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%1806 = bitcast %runtime.Type_Info* %1805 to %runtime.Type_Info*
	%1807 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1786, i64 2
	%1808 = getelementptr inbounds i64, i64* %1788, i64 2
	%1809 = getelementptr inbounds i8, i8* %1789, i64 2
	%1810 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %1810, %runtime.Type_Info** %1807
	%1811 = getelementptr inbounds %..string, %..string* %1787, i64 2
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$227, i32 0, i32 0), i64 5}, %..string* %1811
	store i64 16, i64* %1808
	store i8 0, i8* %1809
	%1812 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	%1813 = bitcast %runtime.Type_Info* %1812 to %runtime.Type_Info*
	%1814 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1786, i64 3
	%1815 = getelementptr inbounds i64, i64* %1788, i64 3
	%1816 = getelementptr inbounds i8, i8* %1789, i64 3
	%1817 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 20
	store %runtime.Type_Info* %1817, %runtime.Type_Info** %1814
	%1818 = getelementptr inbounds %..string, %..string* %1787, i64 3
	store %..string {i8* getelementptr inbounds ([11 x i8], [11 x i8]* @str$228, i32 0, i32 0), i64 10}, %..string* %1818
	store i64 24, i64* %1815
	store i8 0, i8* %1816
	%1819 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 0
	%1820 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1819, i32 0, i32 0
	store %runtime.Type_Info** %1786, %runtime.Type_Info*** %1820
	%1821 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1819, i32 0, i32 1
	store i64 4, i64* %1821
	%1822 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 1
	%1823 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1822, i32 0, i32 0
	store %..string* %1787, %..string** %1823
	%1824 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1822, i32 0, i32 1
	store i64 4, i64* %1824
	%1825 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 2
	%1826 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1825, i32 0, i32 0
	store i64* %1788, i64** %1826
	%1827 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1825, i32 0, i32 1
	store i64 4, i64* %1827
	%1828 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 3
	%1829 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1828, i32 0, i32 0
	store i8* %1789, i8** %1829
	%1830 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1828, i32 0, i32 1
	store i64 4, i64* %1830
	%1831 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, i32 0, i32 4
	%1832 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1831, i32 0, i32 0
	store %..string* %1790, %..string** %1832
	%1833 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1831, i32 0, i32 1
	store i64 4, i64* %1833
	%1834 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1782, align 8
	%1835 = bitcast {[0 x i64], [88 x i8], i64}* %1778 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %1834, %runtime.Type_Info_Struct* %1835
	%1836 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1778, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %1836
	%1837 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 1
	%1838 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1837, i32 0, i32 3
	%1839 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1837, i32 0, i32 0
	store i64 1, i64* %1839
	%1840 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1837, i32 0, i32 1
	store i64 1, i64* %1840
	%1841 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1837, i32 0, i32 2
	store %..typeid 3602879701896396801, %..typeid* %1841
	; Type_Info_Named
	%1842 = bitcast {[0 x i64], [88 x i8], i64}* %1838 to %runtime.Type_Info_Named*
	%1843 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 2
	%1844 = bitcast %runtime.Type_Info* %1843 to %runtime.Type_Info*
	%1845 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1842, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([15 x i8], [15 x i8]* @str$229, i32 0, i32 0), i64 14}, %..string* %1845
	%1846 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1842, i32 0, i32 1
	store %runtime.Type_Info* %1844, %runtime.Type_Info** %1846
	%1847 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1842, align 8
	%1848 = bitcast {[0 x i64], [88 x i8], i64}* %1838 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1847, %runtime.Type_Info_Named* %1848
	%1849 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1838, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1849
	%1850 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 2
	%1851 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1850, i32 0, i32 3
	%1852 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1850, i32 0, i32 0
	store i64 1, i64* %1852
	%1853 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1850, i32 0, i32 1
	store i64 1, i64* %1853
	%1854 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1850, i32 0, i32 2
	store %..typeid 1297036692682702850, %..typeid* %1854
	; Type_Info_Enum
	%1855 = bitcast {[0 x i64], [88 x i8], i64}* %1851 to %runtime.Type_Info_Enum*
	%1856 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 3
	%1857 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1855, i32 0, i32 0
	store %runtime.Type_Info* %1856, %runtime.Type_Info** %1857
	%1858 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i32 0, i32 0
	%1859 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i32 0, i32 0
	%1860 = bitcast %runtime.Type_Info_Enum_Value* %1859 to i8*
	store i8 0, i8* %1860
	%1861 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1859, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %1861
	store %..string {i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str$22a, i32 0, i32 0), i64 5}, %..string* %1858
	%1862 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i32 0, i32 1
	%1863 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i32 0, i32 1
	%1864 = bitcast %runtime.Type_Info_Enum_Value* %1863 to i8*
	store i8 1, i8* %1864
	%1865 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1863, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %1865
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$22b, i32 0, i32 0), i64 4}, %..string* %1862
	%1866 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i32 0, i32 2
	%1867 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i32 0, i32 2
	%1868 = bitcast %runtime.Type_Info_Enum_Value* %1867 to i8*
	store i8 2, i8* %1868
	%1869 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1867, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %1869
	store %..string {i8* getelementptr inbounds ([9 x i8], [9 x i8]* @str$22c, i32 0, i32 0), i64 8}, %..string* %1866
	%1870 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i32 0, i32 3
	%1871 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i32 0, i32 3
	%1872 = bitcast %runtime.Type_Info_Enum_Value* %1871 to i8*
	store i8 3, i8* %1872
	%1873 = getelementptr inbounds %runtime.Type_Info_Enum_Value, %runtime.Type_Info_Enum_Value* %1871, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %1873
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$22d, i32 0, i32 0), i64 6}, %..string* %1870
	%1874 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1855, i32 0, i32 1
	%1875 = getelementptr inbounds [4 x %..string], [4 x %..string]* @$enum_names-2, i32 0, i32 0
	%1876 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1874, i32 0, i32 0
	store %..string* %1875, %..string** %1876
	%1877 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1874, i32 0, i32 1
	store i64 4, i64* %1877
	%1878 = getelementptr inbounds %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1855, i32 0, i32 2
	%1879 = getelementptr inbounds [4 x %runtime.Type_Info_Enum_Value], [4 x %runtime.Type_Info_Enum_Value]* @$enum_values-2, i32 0, i32 0
	%1880 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %1878, i32 0, i32 0
	store %runtime.Type_Info_Enum_Value* %1879, %runtime.Type_Info_Enum_Value** %1880
	%1881 = getelementptr inbounds {%runtime.Type_Info_Enum_Value*, i64}, {%runtime.Type_Info_Enum_Value*, i64}* %1878, i32 0, i32 1
	store i64 4, i64* %1881
	%1882 = load %runtime.Type_Info_Enum, %runtime.Type_Info_Enum* %1855, align 8
	%1883 = bitcast {[0 x i64], [88 x i8], i64}* %1851 to %runtime.Type_Info_Enum*
	store %runtime.Type_Info_Enum %1882, %runtime.Type_Info_Enum* %1883
	%1884 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1851, i64 0, i32 2 ; UnionTagPtr
	store i64 19, i64* %1884
	%1885 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 5
	%1886 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1885, i32 0, i32 3
	%1887 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1885, i32 0, i32 0
	store i64 16, i64* %1887
	%1888 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1885, i32 0, i32 1
	store i64 8, i64* %1888
	%1889 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1885, i32 0, i32 2
	store %..typeid 1008806316530991109, %..typeid* %1889
	; Type_Info_Slice
	%1890 = bitcast {[0 x i64], [88 x i8], i64}* %1886 to %runtime.Type_Info_Slice*
	%1891 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 6
	%1892 = bitcast %runtime.Type_Info* %1891 to %runtime.Type_Info*
	%1893 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1890, i32 0, i32 0
	store %runtime.Type_Info* %1892, %runtime.Type_Info** %1893
	%1894 = getelementptr inbounds %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1890, i32 0, i32 1
	store i64 16, i64* %1894
	%1895 = load %runtime.Type_Info_Slice, %runtime.Type_Info_Slice* %1890, align 8
	%1896 = bitcast {[0 x i64], [88 x i8], i64}* %1886 to %runtime.Type_Info_Slice*
	store %runtime.Type_Info_Slice %1895, %runtime.Type_Info_Slice* %1896
	%1897 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1886, i64 0, i32 2 ; UnionTagPtr
	store i64 15, i64* %1897
	%1898 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 6
	%1899 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1898, i32 0, i32 3
	%1900 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1898, i32 0, i32 0
	store i64 16, i64* %1900
	%1901 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1898, i32 0, i32 1
	store i64 8, i64* %1901
	%1902 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1898, i32 0, i32 2
	store %..typeid 6, %..typeid* %1902
	; Type_Info_Basic
	%1903 = bitcast {[0 x i64], [88 x i8], i64}* %1899 to %runtime.Type_Info_Any*
	%1904 = load %runtime.Type_Info_Any, %runtime.Type_Info_Any* %1903, align 1
	%1905 = bitcast {[0 x i64], [88 x i8], i64}* %1899 to %runtime.Type_Info_Any*
	store %runtime.Type_Info_Any %1904, %runtime.Type_Info_Any* %1905
	%1906 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1899, i64 0, i32 2 ; UnionTagPtr
	store i64 9, i64* %1906
	%1907 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 7
	%1908 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i32 0, i32 3
	%1909 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i32 0, i32 0
	store i64 8, i64* %1909
	%1910 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i32 0, i32 1
	store i64 8, i64* %1910
	%1911 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1907, i32 0, i32 2
	store %..typeid 720575940379279367, %..typeid* %1911
	; Type_Info_Basic
	%1912 = bitcast {[0 x i64], [88 x i8], i64}* %1908 to %runtime.Type_Info_Pointer*
	%1913 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1912, align 8
	%1914 = bitcast {[0 x i64], [88 x i8], i64}* %1908 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1913, %runtime.Type_Info_Pointer* %1914
	%1915 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1908, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1915
	%1916 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 9
	%1917 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1916, i32 0, i32 3
	%1918 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1916, i32 0, i32 0
	store i64 8, i64* %1918
	%1919 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1916, i32 0, i32 1
	store i64 8, i64* %1919
	%1920 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1916, i32 0, i32 2
	store %..typeid 720575940379279369, %..typeid* %1920
	; Type_Info_Pointer
	%1921 = bitcast {[0 x i64], [88 x i8], i64}* %1917 to %runtime.Type_Info_Pointer*
	%1922 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 6
	%1923 = bitcast %runtime.Type_Info* %1922 to %runtime.Type_Info*
	%1924 = getelementptr inbounds %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1921, i32 0, i32 0
	store %runtime.Type_Info* %1923, %runtime.Type_Info** %1924
	%1925 = load %runtime.Type_Info_Pointer, %runtime.Type_Info_Pointer* %1921, align 8
	%1926 = bitcast {[0 x i64], [88 x i8], i64}* %1917 to %runtime.Type_Info_Pointer*
	store %runtime.Type_Info_Pointer %1925, %runtime.Type_Info_Pointer* %1926
	%1927 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1917, i64 0, i32 2 ; UnionTagPtr
	store i64 11, i64* %1927
	%1928 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 85
	%1929 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1928, i32 0, i32 3
	%1930 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1928, i32 0, i32 0
	store i64 56, i64* %1930
	%1931 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1928, i32 0, i32 1
	store i64 8, i64* %1931
	%1932 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1928, i32 0, i32 2
	store %..typeid 3458764513820541013, %..typeid* %1932
	; Type_Info_Named
	%1933 = bitcast {[0 x i64], [88 x i8], i64}* %1929 to %runtime.Type_Info_Named*
	%1934 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 86
	%1935 = bitcast %runtime.Type_Info* %1934 to %runtime.Type_Info*
	%1936 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1933, i32 0, i32 0
	store %..string {i8* getelementptr inbounds ([21 x i8], [21 x i8]* @str$22e, i32 0, i32 0), i64 20}, %..string* %1936
	%1937 = getelementptr inbounds %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1933, i32 0, i32 1
	store %runtime.Type_Info* %1935, %runtime.Type_Info** %1937
	%1938 = load %runtime.Type_Info_Named, %runtime.Type_Info_Named* %1933, align 8
	%1939 = bitcast {[0 x i64], [88 x i8], i64}* %1929 to %runtime.Type_Info_Named*
	store %runtime.Type_Info_Named %1938, %runtime.Type_Info_Named* %1939
	%1940 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1929, i64 0, i32 2 ; UnionTagPtr
	store i64 1, i64* %1940
	%1941 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 86
	%1942 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1941, i32 0, i32 3
	%1943 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1941, i32 0, i32 0
	store i64 56, i64* %1943
	%1944 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1941, i32 0, i32 1
	store i64 8, i64* %1944
	%1945 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %1941, i32 0, i32 2
	store %..typeid 1152921504606847062, %..typeid* %1945
	; Type_Info_Struct
	%1946 = bitcast {[0 x i64], [88 x i8], i64}* %1942 to %runtime.Type_Info_Struct*
	%1947 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 5
	store i8 0, i8* %1947
	%1948 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 6
	store i8 0, i8* %1948
	%1949 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 7
	store i8 0, i8* %1949
	%1950 = getelementptr inbounds [92 x %runtime.Type_Info*], [92 x %runtime.Type_Info*]* @__$type_info_types_data, i32 0, i32 87
	%1951 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_names_data, i32 0, i32 51
	%1952 = getelementptr inbounds [92 x i64], [92 x i64]* @__$type_info_offsets_data, i32 0, i32 51
	%1953 = getelementptr inbounds [92 x i8], [92 x i8]* @__$type_info_usings_data, i32 0, i32 51
	%1954 = getelementptr inbounds [92 x %..string], [92 x %..string]* @__$type_info_tags_data, i32 0, i32 51
	%1955 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	%1956 = bitcast %runtime.Type_Info* %1955 to %runtime.Type_Info*
	%1957 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1950, i64 0
	%1958 = getelementptr inbounds i64, i64* %1952, i64 0
	%1959 = getelementptr inbounds i8, i8* %1953, i64 0
	%1960 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	store %runtime.Type_Info* %1960, %runtime.Type_Info** %1957
	%1961 = getelementptr inbounds %..string, %..string* %1951, i64 0
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$22f, i32 0, i32 0), i64 9}, %..string* %1961
	store i64 0, i64* %1958
	store i8 0, i8* %1959
	%1962 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%1963 = bitcast %runtime.Type_Info* %1962 to %runtime.Type_Info*
	%1964 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1950, i64 1
	%1965 = getelementptr inbounds i64, i64* %1952, i64 1
	%1966 = getelementptr inbounds i8, i8* %1953, i64 1
	%1967 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %1967, %runtime.Type_Info** %1964
	%1968 = getelementptr inbounds %..string, %..string* %1951, i64 1
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$230, i32 0, i32 0), i64 4}, %..string* %1968
	store i64 16, i64* %1965
	store i8 0, i8* %1966
	%1969 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	%1970 = bitcast %runtime.Type_Info* %1969 to %runtime.Type_Info*
	%1971 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1950, i64 2
	%1972 = getelementptr inbounds i64, i64* %1952, i64 2
	%1973 = getelementptr inbounds i8, i8* %1953, i64 2
	%1974 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 4
	store %runtime.Type_Info* %1974, %runtime.Type_Info** %1971
	%1975 = getelementptr inbounds %..string, %..string* %1951, i64 2
	store %..string {i8* getelementptr inbounds ([7 x i8], [7 x i8]* @str$231, i32 0, i32 0), i64 6}, %..string* %1975
	store i64 24, i64* %1972
	store i8 0, i8* %1973
	%1976 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	%1977 = bitcast %runtime.Type_Info* %1976 to %runtime.Type_Info*
	%1978 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1950, i64 3
	%1979 = getelementptr inbounds i64, i64* %1952, i64 3
	%1980 = getelementptr inbounds i8, i8* %1953, i64 3
	%1981 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 16
	store %runtime.Type_Info* %1981, %runtime.Type_Info** %1978
	%1982 = getelementptr inbounds %..string, %..string* %1951, i64 3
	store %..string {i8* getelementptr inbounds ([10 x i8], [10 x i8]* @str$232, i32 0, i32 0), i64 9}, %..string* %1982
	store i64 32, i64* %1979
	store i8 0, i8* %1980
	%1983 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	%1984 = bitcast %runtime.Type_Info* %1983 to %runtime.Type_Info*
	%1985 = getelementptr inbounds %runtime.Type_Info*, %runtime.Type_Info** %1950, i64 4
	%1986 = getelementptr inbounds i64, i64* %1952, i64 4
	%1987 = getelementptr inbounds i8, i8* %1953, i64 4
	%1988 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 71
	store %runtime.Type_Info* %1988, %runtime.Type_Info** %1985
	%1989 = getelementptr inbounds %..string, %..string* %1951, i64 4
	store %..string {i8* getelementptr inbounds ([5 x i8], [5 x i8]* @str$233, i32 0, i32 0), i64 4}, %..string* %1989
	store i64 48, i64* %1986
	store i8 0, i8* %1987
	%1990 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 0
	%1991 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1990, i32 0, i32 0
	store %runtime.Type_Info** %1950, %runtime.Type_Info*** %1991
	%1992 = getelementptr inbounds {%runtime.Type_Info**, i64}, {%runtime.Type_Info**, i64}* %1990, i32 0, i32 1
	store i64 5, i64* %1992
	%1993 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 1
	%1994 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1993, i32 0, i32 0
	store %..string* %1951, %..string** %1994
	%1995 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %1993, i32 0, i32 1
	store i64 5, i64* %1995
	%1996 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 2
	%1997 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1996, i32 0, i32 0
	store i64* %1952, i64** %1997
	%1998 = getelementptr inbounds {i64*, i64}, {i64*, i64}* %1996, i32 0, i32 1
	store i64 5, i64* %1998
	%1999 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 3
	%2000 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1999, i32 0, i32 0
	store i8* %1953, i8** %2000
	%2001 = getelementptr inbounds {i8*, i64}, {i8*, i64}* %1999, i32 0, i32 1
	store i64 5, i64* %2001
	%2002 = getelementptr inbounds %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, i32 0, i32 4
	%2003 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2002, i32 0, i32 0
	store %..string* %1954, %..string** %2003
	%2004 = getelementptr inbounds {%..string*, i64}, {%..string*, i64}* %2002, i32 0, i32 1
	store i64 5, i64* %2004
	%2005 = load %runtime.Type_Info_Struct, %runtime.Type_Info_Struct* %1946, align 8
	%2006 = bitcast {[0 x i64], [88 x i8], i64}* %1942 to %runtime.Type_Info_Struct*
	store %runtime.Type_Info_Struct %2005, %runtime.Type_Info_Struct* %2006
	%2007 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %1942, i64 0, i32 2 ; UnionTagPtr
	store i64 17, i64* %2007
	%2008 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 87
	%2009 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2008, i32 0, i32 3
	%2010 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2008, i32 0, i32 0
	store i64 1, i64* %2010
	%2011 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2008, i32 0, i32 1
	store i64 1, i64* %2011
	%2012 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2008, i32 0, i32 2
	store %..typeid 504403158265495639, %..typeid* %2012
	; Type_Info_Basic
	%2013 = bitcast {[0 x i64], [88 x i8], i64}* %2009 to %runtime.Type_Info_Boolean*
	%2014 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2013, align 1
	%2015 = bitcast {[0 x i64], [88 x i8], i64}* %2009 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2014, %runtime.Type_Info_Boolean* %2015
	%2016 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2009, i64 0, i32 2 ; UnionTagPtr
	store i64 8, i64* %2016
	%2017 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 88
	%2018 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i32 0, i32 3
	%2019 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i32 0, i32 0
	store i64 2, i64* %2019
	%2020 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i32 0, i32 1
	store i64 2, i64* %2020
	%2021 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2017, i32 0, i32 2
	store %..typeid 504403158265495640, %..typeid* %2021
	; Type_Info_Basic
	%2022 = bitcast {[0 x i64], [88 x i8], i64}* %2018 to %runtime.Type_Info_Boolean*
	%2023 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2022, align 1
	%2024 = bitcast {[0 x i64], [88 x i8], i64}* %2018 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2023, %runtime.Type_Info_Boolean* %2024
	%2025 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2018, i64 0, i32 2 ; UnionTagPtr
	store i64 8, i64* %2025
	%2026 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 89
	%2027 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2026, i32 0, i32 3
	%2028 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2026, i32 0, i32 0
	store i64 4, i64* %2028
	%2029 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2026, i32 0, i32 1
	store i64 4, i64* %2029
	%2030 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2026, i32 0, i32 2
	store %..typeid 504403158265495641, %..typeid* %2030
	; Type_Info_Basic
	%2031 = bitcast {[0 x i64], [88 x i8], i64}* %2027 to %runtime.Type_Info_Boolean*
	%2032 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2031, align 1
	%2033 = bitcast {[0 x i64], [88 x i8], i64}* %2027 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2032, %runtime.Type_Info_Boolean* %2033
	%2034 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2027, i64 0, i32 2 ; UnionTagPtr
	store i64 8, i64* %2034
	%2035 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 90
	%2036 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2035, i32 0, i32 3
	%2037 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2035, i32 0, i32 0
	store i64 8, i64* %2037
	%2038 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2035, i32 0, i32 1
	store i64 8, i64* %2038
	%2039 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2035, i32 0, i32 2
	store %..typeid 504403158265495642, %..typeid* %2039
	; Type_Info_Basic
	%2040 = bitcast {[0 x i64], [88 x i8], i64}* %2036 to %runtime.Type_Info_Boolean*
	%2041 = load %runtime.Type_Info_Boolean, %runtime.Type_Info_Boolean* %2040, align 1
	%2042 = bitcast {[0 x i64], [88 x i8], i64}* %2036 to %runtime.Type_Info_Boolean*
	store %runtime.Type_Info_Boolean %2041, %runtime.Type_Info_Boolean* %2042
	%2043 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2036, i64 0, i32 2 ; UnionTagPtr
	store i64 8, i64* %2043
	%2044 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 91
	%2045 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i32 0, i32 3
	%2046 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i32 0, i32 0
	store i64 4, i64* %2046
	%2047 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i32 0, i32 1
	store i64 4, i64* %2047
	%2048 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2044, i32 0, i32 2
	store %..typeid 216172782113783899, %..typeid* %2048
	; Type_Info_Basic
	%2049 = bitcast {[0 x i64], [88 x i8], i64}* %2045 to %runtime.Type_Info_Float*
	%2050 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %2049, align 1
	%2051 = bitcast {[0 x i64], [88 x i8], i64}* %2045 to %runtime.Type_Info_Float*
	store %runtime.Type_Info_Float %2050, %runtime.Type_Info_Float* %2051
	%2052 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2045, i64 0, i32 2 ; UnionTagPtr
	store i64 4, i64* %2052
	%2053 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 92
	%2054 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2053, i32 0, i32 3
	%2055 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2053, i32 0, i32 0
	store i64 8, i64* %2055
	%2056 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2053, i32 0, i32 1
	store i64 8, i64* %2056
	%2057 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2053, i32 0, i32 2
	store %..typeid 216172782113783900, %..typeid* %2057
	; Type_Info_Basic
	%2058 = bitcast {[0 x i64], [88 x i8], i64}* %2054 to %runtime.Type_Info_Float*
	%2059 = load %runtime.Type_Info_Float, %runtime.Type_Info_Float* %2058, align 1
	%2060 = bitcast {[0 x i64], [88 x i8], i64}* %2054 to %runtime.Type_Info_Float*
	store %runtime.Type_Info_Float %2059, %runtime.Type_Info_Float* %2060
	%2061 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2054, i64 0, i32 2 ; UnionTagPtr
	store i64 4, i64* %2061
	%2062 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 93
	%2063 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2062, i32 0, i32 3
	%2064 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2062, i32 0, i32 0
	store i64 8, i64* %2064
	%2065 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2062, i32 0, i32 1
	store i64 4, i64* %2065
	%2066 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2062, i32 0, i32 2
	store %..typeid 288230376151711837, %..typeid* %2066
	; Type_Info_Basic
	%2067 = bitcast {[0 x i64], [88 x i8], i64}* %2063 to %runtime.Type_Info_Complex*
	%2068 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %2067, align 1
	%2069 = bitcast {[0 x i64], [88 x i8], i64}* %2063 to %runtime.Type_Info_Complex*
	store %runtime.Type_Info_Complex %2068, %runtime.Type_Info_Complex* %2069
	%2070 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2063, i64 0, i32 2 ; UnionTagPtr
	store i64 5, i64* %2070
	%2071 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 94
	%2072 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2071, i32 0, i32 3
	%2073 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2071, i32 0, i32 0
	store i64 16, i64* %2073
	%2074 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2071, i32 0, i32 1
	store i64 8, i64* %2074
	%2075 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2071, i32 0, i32 2
	store %..typeid 288230376151711838, %..typeid* %2075
	; Type_Info_Basic
	%2076 = bitcast {[0 x i64], [88 x i8], i64}* %2072 to %runtime.Type_Info_Complex*
	%2077 = load %runtime.Type_Info_Complex, %runtime.Type_Info_Complex* %2076, align 1
	%2078 = bitcast {[0 x i64], [88 x i8], i64}* %2072 to %runtime.Type_Info_Complex*
	store %runtime.Type_Info_Complex %2077, %runtime.Type_Info_Complex* %2078
	%2079 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2072, i64 0, i32 2 ; UnionTagPtr
	store i64 5, i64* %2079
	%2080 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 95
	%2081 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2080, i32 0, i32 3
	%2082 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2080, i32 0, i32 0
	store i64 16, i64* %2082
	%2083 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2080, i32 0, i32 1
	store i64 4, i64* %2083
	%2084 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2080, i32 0, i32 2
	store %..typeid 95, %..typeid* %2084
	; Type_Info_Basic
	%2085 = bitcast {[0 x i64], [88 x i8], i64}* %2081 to %runtime.Type_Info_Quaternion*
	%2086 = load %runtime.Type_Info_Quaternion, %runtime.Type_Info_Quaternion* %2085, align 1
	%2087 = bitcast {[0 x i64], [88 x i8], i64}* %2081 to %runtime.Type_Info_Quaternion*
	store %runtime.Type_Info_Quaternion %2086, %runtime.Type_Info_Quaternion* %2087
	%2088 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2081, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %2088
	%2089 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 96
	%2090 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2089, i32 0, i32 3
	%2091 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2089, i32 0, i32 0
	store i64 32, i64* %2091
	%2092 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2089, i32 0, i32 1
	store i64 8, i64* %2092
	%2093 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2089, i32 0, i32 2
	store %..typeid 96, %..typeid* %2093
	; Type_Info_Basic
	%2094 = bitcast {[0 x i64], [88 x i8], i64}* %2090 to %runtime.Type_Info_Quaternion*
	%2095 = load %runtime.Type_Info_Quaternion, %runtime.Type_Info_Quaternion* %2094, align 1
	%2096 = bitcast {[0 x i64], [88 x i8], i64}* %2090 to %runtime.Type_Info_Quaternion*
	store %runtime.Type_Info_Quaternion %2095, %runtime.Type_Info_Quaternion* %2096
	%2097 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2090, i64 0, i32 2 ; UnionTagPtr
	store i64 6, i64* %2097
	%2098 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 97
	%2099 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2098, i32 0, i32 3
	%2100 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2098, i32 0, i32 0
	store i64 8, i64* %2100
	%2101 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2098, i32 0, i32 1
	store i64 8, i64* %2101
	%2102 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2098, i32 0, i32 2
	store %..typeid 5044031582654955617, %..typeid* %2102
	; Type_Info_Basic
	%2103 = bitcast {[0 x i64], [88 x i8], i64}* %2099 to %runtime.Type_Info_String*
	%2104 = getelementptr inbounds %runtime.Type_Info_String, %runtime.Type_Info_String* %2103, i32 0, i32 0
	store i8 1, i8* %2104
	%2105 = load %runtime.Type_Info_String, %runtime.Type_Info_String* %2103, align 1
	%2106 = bitcast {[0 x i64], [88 x i8], i64}* %2099 to %runtime.Type_Info_String*
	store %runtime.Type_Info_String %2105, %runtime.Type_Info_String* %2106
	%2107 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2099, i64 0, i32 2 ; UnionTagPtr
	store i64 7, i64* %2107
	%2108 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 98
	%2109 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2108, i32 0, i32 3
	%2110 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2108, i32 0, i32 0
	store i64 2, i64* %2110
	%2111 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2108, i32 0, i32 1
	store i64 2, i64* %2111
	%2112 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2108, i32 0, i32 2
	store %..typeid 4683743612465315938, %..typeid* %2112
	; Type_Info_Basic
	%2113 = bitcast {[0 x i64], [88 x i8], i64}* %2109 to %runtime.Type_Info_Integer*
	%2114 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2113, i32 0, i32 0
	store i8 1, i8* %2114
	%2115 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2113, i32 0, i32 1
	store i8 1, i8* %2115
	%2116 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2113, align 1
	%2117 = bitcast {[0 x i64], [88 x i8], i64}* %2109 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2116, %runtime.Type_Info_Integer* %2117
	%2118 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2109, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2118
	%2119 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 99
	%2120 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2119, i32 0, i32 3
	%2121 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2119, i32 0, i32 0
	store i64 2, i64* %2121
	%2122 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2119, i32 0, i32 1
	store i64 2, i64* %2122
	%2123 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2119, i32 0, i32 2
	store %..typeid 72057594037928035, %..typeid* %2123
	; Type_Info_Basic
	%2124 = bitcast {[0 x i64], [88 x i8], i64}* %2120 to %runtime.Type_Info_Integer*
	%2125 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2124, i32 0, i32 0
	store i8 0, i8* %2125
	%2126 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2124, i32 0, i32 1
	store i8 1, i8* %2126
	%2127 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2124, align 1
	%2128 = bitcast {[0 x i64], [88 x i8], i64}* %2120 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2127, %runtime.Type_Info_Integer* %2128
	%2129 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2120, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2129
	%2130 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 100
	%2131 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2130, i32 0, i32 3
	%2132 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2130, i32 0, i32 0
	store i64 4, i64* %2132
	%2133 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2130, i32 0, i32 1
	store i64 4, i64* %2133
	%2134 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2130, i32 0, i32 2
	store %..typeid 4683743612465315940, %..typeid* %2134
	; Type_Info_Basic
	%2135 = bitcast {[0 x i64], [88 x i8], i64}* %2131 to %runtime.Type_Info_Integer*
	%2136 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2135, i32 0, i32 0
	store i8 1, i8* %2136
	%2137 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2135, i32 0, i32 1
	store i8 1, i8* %2137
	%2138 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2135, align 1
	%2139 = bitcast {[0 x i64], [88 x i8], i64}* %2131 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2138, %runtime.Type_Info_Integer* %2139
	%2140 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2131, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2140
	%2141 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 101
	%2142 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2141, i32 0, i32 3
	%2143 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2141, i32 0, i32 0
	store i64 4, i64* %2143
	%2144 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2141, i32 0, i32 1
	store i64 4, i64* %2144
	%2145 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2141, i32 0, i32 2
	store %..typeid 72057594037928037, %..typeid* %2145
	; Type_Info_Basic
	%2146 = bitcast {[0 x i64], [88 x i8], i64}* %2142 to %runtime.Type_Info_Integer*
	%2147 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2146, i32 0, i32 0
	store i8 0, i8* %2147
	%2148 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2146, i32 0, i32 1
	store i8 1, i8* %2148
	%2149 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2146, align 1
	%2150 = bitcast {[0 x i64], [88 x i8], i64}* %2142 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2149, %runtime.Type_Info_Integer* %2150
	%2151 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2142, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2151
	%2152 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 102
	%2153 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2152, i32 0, i32 3
	%2154 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2152, i32 0, i32 0
	store i64 8, i64* %2154
	%2155 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2152, i32 0, i32 1
	store i64 8, i64* %2155
	%2156 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2152, i32 0, i32 2
	store %..typeid 4683743612465315942, %..typeid* %2156
	; Type_Info_Basic
	%2157 = bitcast {[0 x i64], [88 x i8], i64}* %2153 to %runtime.Type_Info_Integer*
	%2158 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2157, i32 0, i32 0
	store i8 1, i8* %2158
	%2159 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2157, i32 0, i32 1
	store i8 1, i8* %2159
	%2160 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2157, align 1
	%2161 = bitcast {[0 x i64], [88 x i8], i64}* %2153 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2160, %runtime.Type_Info_Integer* %2161
	%2162 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2153, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2162
	%2163 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 103
	%2164 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2163, i32 0, i32 3
	%2165 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2163, i32 0, i32 0
	store i64 8, i64* %2165
	%2166 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2163, i32 0, i32 1
	store i64 8, i64* %2166
	%2167 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2163, i32 0, i32 2
	store %..typeid 72057594037928039, %..typeid* %2167
	; Type_Info_Basic
	%2168 = bitcast {[0 x i64], [88 x i8], i64}* %2164 to %runtime.Type_Info_Integer*
	%2169 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2168, i32 0, i32 0
	store i8 0, i8* %2169
	%2170 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2168, i32 0, i32 1
	store i8 1, i8* %2170
	%2171 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2168, align 1
	%2172 = bitcast {[0 x i64], [88 x i8], i64}* %2164 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2171, %runtime.Type_Info_Integer* %2172
	%2173 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2164, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2173
	%2174 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 104
	%2175 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2174, i32 0, i32 3
	%2176 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2174, i32 0, i32 0
	store i64 2, i64* %2176
	%2177 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2174, i32 0, i32 1
	store i64 2, i64* %2177
	%2178 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2174, i32 0, i32 2
	store %..typeid 4683743612465315944, %..typeid* %2178
	; Type_Info_Basic
	%2179 = bitcast {[0 x i64], [88 x i8], i64}* %2175 to %runtime.Type_Info_Integer*
	%2180 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2179, i32 0, i32 0
	store i8 1, i8* %2180
	%2181 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2179, i32 0, i32 1
	store i8 2, i8* %2181
	%2182 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2179, align 1
	%2183 = bitcast {[0 x i64], [88 x i8], i64}* %2175 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2182, %runtime.Type_Info_Integer* %2183
	%2184 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2175, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2184
	%2185 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 105
	%2186 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2185, i32 0, i32 3
	%2187 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2185, i32 0, i32 0
	store i64 2, i64* %2187
	%2188 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2185, i32 0, i32 1
	store i64 2, i64* %2188
	%2189 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2185, i32 0, i32 2
	store %..typeid 72057594037928041, %..typeid* %2189
	; Type_Info_Basic
	%2190 = bitcast {[0 x i64], [88 x i8], i64}* %2186 to %runtime.Type_Info_Integer*
	%2191 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2190, i32 0, i32 0
	store i8 0, i8* %2191
	%2192 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2190, i32 0, i32 1
	store i8 2, i8* %2192
	%2193 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2190, align 1
	%2194 = bitcast {[0 x i64], [88 x i8], i64}* %2186 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2193, %runtime.Type_Info_Integer* %2194
	%2195 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2186, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2195
	%2196 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 106
	%2197 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2196, i32 0, i32 3
	%2198 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2196, i32 0, i32 0
	store i64 4, i64* %2198
	%2199 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2196, i32 0, i32 1
	store i64 4, i64* %2199
	%2200 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2196, i32 0, i32 2
	store %..typeid 4683743612465315946, %..typeid* %2200
	; Type_Info_Basic
	%2201 = bitcast {[0 x i64], [88 x i8], i64}* %2197 to %runtime.Type_Info_Integer*
	%2202 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2201, i32 0, i32 0
	store i8 1, i8* %2202
	%2203 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2201, i32 0, i32 1
	store i8 2, i8* %2203
	%2204 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2201, align 1
	%2205 = bitcast {[0 x i64], [88 x i8], i64}* %2197 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2204, %runtime.Type_Info_Integer* %2205
	%2206 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2197, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2206
	%2207 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 107
	%2208 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2207, i32 0, i32 3
	%2209 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2207, i32 0, i32 0
	store i64 4, i64* %2209
	%2210 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2207, i32 0, i32 1
	store i64 4, i64* %2210
	%2211 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2207, i32 0, i32 2
	store %..typeid 72057594037928043, %..typeid* %2211
	; Type_Info_Basic
	%2212 = bitcast {[0 x i64], [88 x i8], i64}* %2208 to %runtime.Type_Info_Integer*
	%2213 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2212, i32 0, i32 0
	store i8 0, i8* %2213
	%2214 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2212, i32 0, i32 1
	store i8 2, i8* %2214
	%2215 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2212, align 1
	%2216 = bitcast {[0 x i64], [88 x i8], i64}* %2208 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2215, %runtime.Type_Info_Integer* %2216
	%2217 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2208, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2217
	%2218 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 108
	%2219 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2218, i32 0, i32 3
	%2220 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2218, i32 0, i32 0
	store i64 8, i64* %2220
	%2221 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2218, i32 0, i32 1
	store i64 8, i64* %2221
	%2222 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2218, i32 0, i32 2
	store %..typeid 4683743612465315948, %..typeid* %2222
	; Type_Info_Basic
	%2223 = bitcast {[0 x i64], [88 x i8], i64}* %2219 to %runtime.Type_Info_Integer*
	%2224 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2223, i32 0, i32 0
	store i8 1, i8* %2224
	%2225 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2223, i32 0, i32 1
	store i8 2, i8* %2225
	%2226 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2223, align 1
	%2227 = bitcast {[0 x i64], [88 x i8], i64}* %2219 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2226, %runtime.Type_Info_Integer* %2227
	%2228 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2219, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2228
	%2229 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 109
	%2230 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2229, i32 0, i32 3
	%2231 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2229, i32 0, i32 0
	store i64 8, i64* %2231
	%2232 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2229, i32 0, i32 1
	store i64 8, i64* %2232
	%2233 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2229, i32 0, i32 2
	store %..typeid 72057594037928045, %..typeid* %2233
	; Type_Info_Basic
	%2234 = bitcast {[0 x i64], [88 x i8], i64}* %2230 to %runtime.Type_Info_Integer*
	%2235 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2234, i32 0, i32 0
	store i8 0, i8* %2235
	%2236 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2234, i32 0, i32 1
	store i8 2, i8* %2236
	%2237 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2234, align 1
	%2238 = bitcast {[0 x i64], [88 x i8], i64}* %2230 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2237, %runtime.Type_Info_Integer* %2238
	%2239 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2230, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2239
	%2240 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 110
	%2241 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2240, i32 0, i32 3
	%2242 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2240, i32 0, i32 0
	store i64 16, i64* %2242
	%2243 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2240, i32 0, i32 1
	store i64 8, i64* %2243
	%2244 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2240, i32 0, i32 2
	store %..typeid 4683743612465315950, %..typeid* %2244
	; Type_Info_Basic
	%2245 = bitcast {[0 x i64], [88 x i8], i64}* %2241 to %runtime.Type_Info_Integer*
	%2246 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2245, i32 0, i32 0
	store i8 1, i8* %2246
	%2247 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2245, i32 0, i32 1
	store i8 0, i8* %2247
	%2248 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2245, align 1
	%2249 = bitcast {[0 x i64], [88 x i8], i64}* %2241 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2248, %runtime.Type_Info_Integer* %2249
	%2250 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2241, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2250
	%2251 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 111
	%2252 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2251, i32 0, i32 3
	%2253 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2251, i32 0, i32 0
	store i64 16, i64* %2253
	%2254 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2251, i32 0, i32 1
	store i64 8, i64* %2254
	%2255 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2251, i32 0, i32 2
	store %..typeid 72057594037928047, %..typeid* %2255
	; Type_Info_Basic
	%2256 = bitcast {[0 x i64], [88 x i8], i64}* %2252 to %runtime.Type_Info_Integer*
	%2257 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2256, i32 0, i32 0
	store i8 0, i8* %2257
	%2258 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2256, i32 0, i32 1
	store i8 0, i8* %2258
	%2259 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2256, align 1
	%2260 = bitcast {[0 x i64], [88 x i8], i64}* %2252 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2259, %runtime.Type_Info_Integer* %2260
	%2261 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2252, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2261
	%2262 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 112
	%2263 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2262, i32 0, i32 3
	%2264 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2262, i32 0, i32 0
	store i64 16, i64* %2264
	%2265 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2262, i32 0, i32 1
	store i64 8, i64* %2265
	%2266 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2262, i32 0, i32 2
	store %..typeid 4683743612465315952, %..typeid* %2266
	; Type_Info_Basic
	%2267 = bitcast {[0 x i64], [88 x i8], i64}* %2263 to %runtime.Type_Info_Integer*
	%2268 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2267, i32 0, i32 0
	store i8 1, i8* %2268
	%2269 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2267, i32 0, i32 1
	store i8 1, i8* %2269
	%2270 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2267, align 1
	%2271 = bitcast {[0 x i64], [88 x i8], i64}* %2263 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2270, %runtime.Type_Info_Integer* %2271
	%2272 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2263, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2272
	%2273 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 113
	%2274 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2273, i32 0, i32 3
	%2275 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2273, i32 0, i32 0
	store i64 16, i64* %2275
	%2276 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2273, i32 0, i32 1
	store i64 8, i64* %2276
	%2277 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2273, i32 0, i32 2
	store %..typeid 72057594037928049, %..typeid* %2277
	; Type_Info_Basic
	%2278 = bitcast {[0 x i64], [88 x i8], i64}* %2274 to %runtime.Type_Info_Integer*
	%2279 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2278, i32 0, i32 0
	store i8 0, i8* %2279
	%2280 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2278, i32 0, i32 1
	store i8 1, i8* %2280
	%2281 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2278, align 1
	%2282 = bitcast {[0 x i64], [88 x i8], i64}* %2274 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2281, %runtime.Type_Info_Integer* %2282
	%2283 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2274, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2283
	%2284 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 114
	%2285 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2284, i32 0, i32 3
	%2286 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2284, i32 0, i32 0
	store i64 16, i64* %2286
	%2287 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2284, i32 0, i32 1
	store i64 8, i64* %2287
	%2288 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2284, i32 0, i32 2
	store %..typeid 4683743612465315954, %..typeid* %2288
	; Type_Info_Basic
	%2289 = bitcast {[0 x i64], [88 x i8], i64}* %2285 to %runtime.Type_Info_Integer*
	%2290 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2289, i32 0, i32 0
	store i8 1, i8* %2290
	%2291 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2289, i32 0, i32 1
	store i8 2, i8* %2291
	%2292 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2289, align 1
	%2293 = bitcast {[0 x i64], [88 x i8], i64}* %2285 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2292, %runtime.Type_Info_Integer* %2293
	%2294 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2285, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2294
	%2295 = getelementptr inbounds [116 x %runtime.Type_Info], [116 x %runtime.Type_Info]* @__$type_info_data, i32 0, i32 115
	%2296 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2295, i32 0, i32 3
	%2297 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2295, i32 0, i32 0
	store i64 16, i64* %2297
	%2298 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2295, i32 0, i32 1
	store i64 8, i64* %2298
	%2299 = getelementptr inbounds %runtime.Type_Info, %runtime.Type_Info* %2295, i32 0, i32 2
	store %..typeid 72057594037928051, %..typeid* %2299
	; Type_Info_Basic
	%2300 = bitcast {[0 x i64], [88 x i8], i64}* %2296 to %runtime.Type_Info_Integer*
	%2301 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2300, i32 0, i32 0
	store i8 0, i8* %2301
	%2302 = getelementptr inbounds %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2300, i32 0, i32 1
	store i8 2, i8* %2302
	%2303 = load %runtime.Type_Info_Integer, %runtime.Type_Info_Integer* %2300, align 1
	%2304 = bitcast {[0 x i64], [88 x i8], i64}* %2296 to %runtime.Type_Info_Integer*
	store %runtime.Type_Info_Integer %2303, %runtime.Type_Info_Integer* %2304
	%2305 = getelementptr inbounds {[0 x i64], [88 x i8], i64}, {[0 x i64], [88 x i8], i64}* %2296, i64 0, i32 2 ; UnionTagPtr
	store i64 2, i64* %2305
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$234, i32 0, i32 0), i64 17}, %..string* @fmt.__DIGITS_LOWER
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$235, i32 0, i32 0), i64 17}, %..string* @fmt.__DIGITS_UPPER
	store [5 x %utf8.Accept_Range] [%utf8.Accept_Range {i8 128, i8 191}, %utf8.Accept_Range {i8 160, i8 191}, %utf8.Accept_Range {i8 128, i8 159}, %utf8.Accept_Range {i8 144, i8 191}, %utf8.Accept_Range {i8 128, i8 143}], [5 x %utf8.Accept_Range]* @utf8.accept_ranges
	store [256 x i8] [i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 19, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 35, i8 3, i8 3, i8 52, i8 4, i8 4, i8 4, i8 68, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241], [256 x i8]* @utf8.accept_sizes
	store %strconv.Float_Info {i64 23, i64 8, i64 -127}, %strconv.Float_Info* @strconv._f32_info
	store %strconv.Float_Info {i64 52, i64 11, i64 -1023}, %strconv.Float_Info* @strconv._f64_info
	store %..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$236, i32 0, i32 0), i64 36}, %..string* @strconv.digits
	store %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$237, i32 0, i32 0), i64 17}, %..string* @strings.DIGITS_LOWER
	%2306 = call i64 @os.get_std_handle(i64 -10, %runtime.Context* noalias nonnull nocapture %0) noinline
	store i64 %2306, i64* @os.stdin
	%2307 = call i64 @os.get_std_handle(i64 -11, %runtime.Context* noalias nonnull nocapture %0) noinline
	store i64 %2307, i64* @os.stdout
	%2308 = call i64 @os.get_std_handle(i64 -12, %runtime.Context* noalias nonnull nocapture %0) noinline
	store i64 %2308, i64* @os.stderr
	ret void
}
@__$type_info_data = private global [116 x %runtime.Type_Info] zeroinitializer
@__$type_info_types_data = global [92 x %runtime.Type_Info*] zeroinitializer
@__$type_info_names_data = global [92 x %..string] zeroinitializer
@__$type_info_offsets_data = global [92 x i64] zeroinitializer
@__$type_info_usings_data = global [92 x i8] zeroinitializer
@__$type_info_tags_data = global [92 x %..string] zeroinitializer
@ggv$0 = global %runtime.Context zeroinitializer
@runtime.type_table = global {%runtime.Type_Info*, i64} zeroinitializer
@runtime.args__ = global {i8**, i64} zeroinitializer
@runtime.global_scratch_allocator_data = global %mem.Scratch_Allocator zeroinitializer
@fmt.__DIGITS_LOWER = global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$238, i32 0, i32 0), i64 17}
@fmt.__DIGITS_UPPER = global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$239, i32 0, i32 0), i64 17}
@utf8.accept_ranges = global [5 x %utf8.Accept_Range] [%utf8.Accept_Range {i8 128, i8 191}, %utf8.Accept_Range {i8 160, i8 191}, %utf8.Accept_Range {i8 128, i8 159}, %utf8.Accept_Range {i8 144, i8 191}, %utf8.Accept_Range {i8 128, i8 143}]
@utf8.accept_sizes = global [256 x i8] [i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 240, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 2, i8 19, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 3, i8 35, i8 3, i8 3, i8 52, i8 4, i8 4, i8 4, i8 68, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241, i8 241]
@strconv._f32_info = global %strconv.Float_Info {i64 23, i64 8, i64 -127}
@strconv._f64_info = global %strconv.Float_Info {i64 52, i64 11, i64 -1023}
@strconv.digits = global %..string {i8* getelementptr inbounds ([37 x i8], [37 x i8]* @str$23a, i32 0, i32 0), i64 36}
@strings.DIGITS_LOWER = internal global %..string {i8* getelementptr inbounds ([18 x i8], [18 x i8]* @str$23b, i32 0, i32 0), i64 17}
@os.stdin = global i64 zeroinitializer
@os.stdout = global i64 zeroinitializer
@os.stderr = global i64 zeroinitializer
@csba$0 = global [1 x i8] [i8 zeroinitializer]
@$enum_names-22 = private global [3 x %..string] zeroinitializer
@$enum_values-22 = private global [3 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-38 = private global [6 x %..string] zeroinitializer
@$enum_values-38 = private global [6 x %runtime.Type_Info_Enum_Value] zeroinitializer
@$enum_names-2 = private global [4 x %..string] zeroinitializer
@$enum_values-2 = private global [4 x %runtime.Type_Info_Enum_Value] zeroinitializer
@str$0 = private global [11 x i8] c"0123456789\00"
@str$1 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$2 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$3 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$4 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$5 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$6 = private global [11 x i8] c"0123456789\00"
@str$7 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$8 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$9 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$a = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$b = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$c = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$d = private global [4 x i8] c"nil\00"
@str$e = private global [4 x i8] c"int\00"
@str$f = private global [5 x i8] c"uint\00"
@str$10 = private global [8 x i8] c"uintptr\00"
@str$11 = private global [5 x i8] c"rune\00"
@str$12 = private global [8 x i8] c"complex\00"
@str$13 = private global [7 x i8] c"string\00"
@str$14 = private global [5 x i8] c"bool\00"
@str$15 = private global [4 x i8] c"any\00"
@str$16 = private global [7 x i8] c"typeid\00"
@str$17 = private global [7 x i8] c"rawptr\00"
@str$18 = private global [2 x i8] c"\5E\00"
@str$19 = private global [5 x i8] c"proc\00"
@str$1a = private global [3 x i8] c"\28\29\00"
@str$1b = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$1c = private global [2 x i8] c"\28\00"
@str$1d = private global [3 x i8] c"\2C\20\00"
@str$1e = private global [2 x i8] c"\29\00"
@str$1f = private global [5 x i8] c"\20-\3E\20\00"
@str$20 = private global [2 x i8] c"\28\00"
@str$21 = private global [3 x i8] c"\2C\20\00"
@str$22 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$23 = private global [3 x i8] c"\3A\20\00"
@str$24 = private global [2 x i8] c"\29\00"
@str$25 = private global [2 x i8] c"\5B\00"
@str$26 = private global [2 x i8] c"\5D\00"
@str$27 = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$28 = private global [3 x i8] c"\5B\5D\00"
@str$29 = private global [5 x i8] c"map\5B\00"
@str$2a = private global [8 x i8] c"struct\20\00"
@str$2b = private global [9 x i8] c"\23packed\20\00"
@str$2c = private global [12 x i8] c"\23raw_union\20\00"
@str$2d = private global [8 x i8] c"\23align\20\00"
@str$2e = private global [3 x i8] c"\2C\20\00"
@str$2f = private global [3 x i8] c"\3A\20\00"
@str$30 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$31 = private global [8 x i8] c"union\20\7B\00"
@str$32 = private global [3 x i8] c"\2C\20\00"
@str$33 = private global [2 x i8] c"\7D\00"
@str$34 = private global [6 x i8] c"enum\20\00"
@str$35 = private global [3 x i8] c"\20\7B\00"
@str$36 = private global [3 x i8] c"\2C\20\00"
@str$37 = private global [2 x i8] c"\7D\00"
@str$38 = private global [11 x i8] c"bit_field\20\00"
@str$39 = private global [8 x i8] c"\23align\20\00"
@str$3a = private global [3 x i8] c"\20\7B\00"
@str$3b = private global [3 x i8] c"\2C\20\00"
@str$3c = private global [3 x i8] c"\3A\20\00"
@str$3d = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$3e = private global [2 x i8] c"\7D\00"
@str$3f = private global [9 x i8] c"bit_set\5B\00"
@str$40 = private global [3 x i8] c"..\00"
@str$41 = private global [3 x i8] c"..\00"
@str$42 = private global [3 x i8] c"\3B\20\00"
@str$43 = private global [8 x i8] c"opaque\20\00"
@str$44 = private global [19 x i8] c"intrinsics.x86_mmx\00"
@str$45 = private global [19 x i8] c"intrinsics.vector\28\00"
@str$46 = private global [3 x i8] c"\2C\20\00"
@str$47 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$48 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$49 = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$4a = private global [67 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Finternal.odin\00"
@str$4b = private global [8 x i8] c"\20Index\20\00"
@str$4c = private global [27 x i8] c"\20is\20out\20of\20bounds\20range\200\3A\00"
@str$4d = private global [25 x i8] c"\20Invalid\20slice\20indices\3A\20\00"
@str$4e = private global [2 x i8] c"\3A\00"
@str$4f = private global [2 x i8] c"\3A\00"
@str$50 = private global [32 x i8] c"\20Invalid\20dynamic\20array\20values\3A\20\00"
@str$51 = private global [2 x i8] c"\3A\00"
@str$52 = private global [2 x i8] c"\3A\00"
@str$53 = private global [30 x i8] c"\20Invalid\20type\20assertion\20from\20\00"
@str$54 = private global [5 x i8] c"\20to\20\00"
@str$55 = private global [33 x i8] c"\20Invalid\20slice\20length\20for\20make\3A\20\00"
@str$56 = private global [45 x i8] c"\20Invalid\20dynamic\20array\20parameters\20for\20make\3A\20\00"
@str$57 = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$58 = private global [2 x i8] c"\20\00"
@str$59 = private global [3 x i8] c"\3A\20\00"
@str$5a = private global [18 x i8] c"Runtime\20assertion\00"
@str$5b = private global [6 x i8] c"Panic\00"
@str$5c = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$5d = private global [5 x i8] c"main\00"
@str$5e = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$5f = private global [5 x i8] c"main\00"
@str$60 = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$61 = private global [5 x i8] c"main\00"
@str$62 = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$63 = private global [5 x i8] c"main\00"
@str$64 = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$65 = private global [5 x i8] c"main\00"
@str$66 = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$67 = private global [5 x i8] c"main\00"
@str$68 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$69 = private global [3 x i8] c"\25\21\00"
@str$6a = private global [6 x i8] c"\3Cnil\3E\00"
@str$6b = private global [5 x i8] c"true\00"
@str$6c = private global [6 x i8] c"false\00"
@str$6d = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$6e = private global [9 x i8] c"_fmt_int\00"
@str$6f = private global [54 x i8] c"_fmt_int\3A\20buffer\20overrun.\20Width\20and\20precision\20too\20big\00"
@str$70 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$71 = private global [9 x i8] c"_fmt_int\00"
@str$72 = private global [31 x i8] c"_fmt_int\3A\20unknown\20base\2C\20whoops\00"
@str$73 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$74 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$75 = private global [13 x i8] c"_fmt_int_128\00"
@str$76 = private global [54 x i8] c"_fmt_int\3A\20buffer\20overrun.\20Width\20and\20precision\20too\20big\00"
@str$77 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$78 = private global [13 x i8] c"_fmt_int_128\00"
@str$79 = private global [31 x i8] c"_fmt_int\3A\20unknown\20base\2C\20whoops\00"
@str$7a = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$7b = private global [3 x i8] c"U\2B\00"
@str$7c = private global [3 x i8] c"U\2B\00"
@str$7d = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$7e = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$7f = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$80 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$81 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$82 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$83 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$84 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$85 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$86 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$87 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$88 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$89 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$8a = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$8b = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$8c = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$8d = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$8e = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$8f = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$90 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$91 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$92 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$93 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$94 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$95 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$96 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$97 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$98 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$99 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$9a = private global [10 x i8] c"fmt_float\00"
@str$9b = private global [21 x i8] c"Unhandled\20float\20size\00"
@str$9c = private global [3 x i8] c"0h\00"
@str$9d = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$9e = private global [3 x i8] c"0x\00"
@str$9f = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a0 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a1 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a2 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a3 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a4 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a5 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a6 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a7 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a8 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$a9 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$aa = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ab = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ac = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ad = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ae = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$af = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b0 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b1 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b2 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b3 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b4 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b5 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b6 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$b7 = private global [6 x i8] c"\3Cnil\3E\00"
@str$b8 = private global [19 x i8] c"\21\25\28BAD\20ENUM\20VALUE\29\00"
@str$b9 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ba = private global [12 x i8] c"fmt_bit_set\00"
@str$bb = private global [22 x i8] c"unknown\20bit_size\20size\00"
@str$bc = private global [3 x i8] c"\2C\20\00"
@str$bd = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$be = private global [11 x i8] c"bit_field\7B\00"
@str$bf = private global [3 x i8] c"\2C\20\00"
@str$c0 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c1 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c2 = private global [4 x i8] c"\20\3D\20\00"
@str$c3 = private global [4 x i8] c"nil\00"
@str$c4 = private global [6 x i8] c"\3Cnil\3E\00"
@str$c5 = private global [3 x i8] c"\7B\7D\00"
@str$c6 = private global [3 x i8] c"\2C\20\00"
@str$c7 = private global [4 x i8] c"\20\3D\20\00"
@str$c8 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$c9 = private global [6 x i8] c"any\7B\7D\00"
@str$ca = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$cb = private global [3 x i8] c"\2C\0A\00"
@str$cc = private global [6 x i8] c"\3Cnil\3E\00"
@str$cd = private global [6 x i8] c"\3Cnil\3E\00"
@str$ce = private global [3 x i8] c"\2C\20\00"
@str$cf = private global [3 x i8] c"\2C\20\00"
@str$d0 = private global [21 x i8] c"intrinsics.x86_mmx\3C\3E\00"
@str$d1 = private global [3 x i8] c"\2C\20\00"
@str$d2 = private global [3 x i8] c"\2C\20\00"
@str$d3 = private global [5 x i8] c"map\5B\00"
@str$d4 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$d5 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$d6 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$d7 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$d8 = private global [3 x i8] c"\2C\20\00"
@str$d9 = private global [2 x i8] c"\3D\00"
@str$da = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$db = private global [12 x i8] c"\28raw_union\29\00"
@str$dc = private global [3 x i8] c"\2C\20\00"
@str$dd = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$de = private global [4 x i8] c"\20\3D\20\00"
@str$df = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$e0 = private global [6 x i8] c"any\7B\7D\00"
@str$e1 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$e2 = private global [3 x i8] c"\2C\0A\00"
@str$e3 = private global [4 x i8] c"nil\00"
@str$e4 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$e5 = private global [10 x i8] c"fmt_value\00"
@str$e6 = private global [23 x i8] c"Invalid\20union\20tag\20type\00"
@str$e7 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$e8 = private global [10 x i8] c"fmt_value\00"
@str$e9 = private global [4 x i8] c"nil\00"
@str$ea = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$eb = private global [4 x i8] c"nil\00"
@str$ec = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Ffmt\2Ffmt.odin\00"
@str$ed = private global [4 x i8] c"nil\00"
@str$ee = private global [4 x i8] c"\20\40\20\00"
@str$ef = private global [6 x i8] c"\3Cnil\3E\00"
@str$f0 = private global [58 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fmem.odin\00"
@str$f1 = private global [22 x i8] c"align_forward_uintptr\00"
@str$f2 = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$f3 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$f4 = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$f5 = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$f6 = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$f7 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$f8 = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$f9 = private global [23 x i8] c"scratch_allocator_proc\00"
@str$fa = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$fb = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$fc = private global [23 x i8] c"scratch_allocator_proc\00"
@str$fd = private global [65 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fmem\2Fallocators.odin\00"
@str$fe = private global [56 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$ff = private global [3 x i8] c"\5Ca\00"
@str$100 = private global [3 x i8] c"\5Cb\00"
@str$101 = private global [3 x i8] c"\5Ce\00"
@str$102 = private global [3 x i8] c"\5Cf\00"
@str$103 = private global [3 x i8] c"\5Cn\00"
@str$104 = private global [3 x i8] c"\5Cr\00"
@str$105 = private global [3 x i8] c"\5Ct\00"
@str$106 = private global [3 x i8] c"\5Cv\00"
@str$107 = private global [3 x i8] c"\5Cx\00"
@str$108 = private global [3 x i8] c"00\00"
@str$109 = private global [56 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fos\2Fos.odin\00"
@str$10a = private global [20 x i8] c"heap_allocator_proc\00"
@str$10b = private global [64 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fos\2Fos_windows.odin\00"
@str$10c = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$10d = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$10e = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$10f = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$110 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$111 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$112 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$113 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$114 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$115 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$116 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$117 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$118 = private global [68 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Funicode\2Futf8\2Futf8.odin\00"
@str$119 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$11a = private global [13 x i8] c"generic_ftoa\00"
@str$11b = private global [26 x i8] c"strconv\3A\20invalid\20bit_size\00"
@str$11c = private global [4 x i8] c"NaN\00"
@str$11d = private global [5 x i8] c"-Inf\00"
@str$11e = private global [5 x i8] c"\2BInf\00"
@str$11f = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$120 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$121 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$122 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$123 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$124 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$125 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$126 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$127 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$128 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$129 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$12a = private global [20 x i8] c"is_integer_negative\00"
@str$12b = private global [42 x i8] c"is_integer_negative\3A\20Unknown\20integer\20size\00"
@str$12c = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$12d = private global [12 x i8] c"append_bits\00"
@str$12e = private global [44 x i8] c"strconv\3A\20illegal\20base\20passed\20to\20append_bits\00"
@str$12f = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$130 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$131 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$132 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$133 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$134 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$135 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$136 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$137 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$138 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$139 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$13a = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$13b = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$13c = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$13d = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$13e = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$13f = private global [24 x i8] c"is_integer_negative_128\00"
@str$140 = private global [42 x i8] c"is_integer_negative\3A\20Unknown\20integer\20size\00"
@str$141 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$142 = private global [16 x i8] c"append_bits_128\00"
@str$143 = private global [44 x i8] c"strconv\3A\20illegal\20base\20passed\20to\20append_bits\00"
@str$144 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$145 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$146 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$147 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$148 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$149 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$14a = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$14b = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$14c = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$14d = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$14e = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$14f = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$150 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$151 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$152 = private global [72 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrconv\2Fgeneric_float.odin\00"
@str$153 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$154 = private global [11 x i8] c"write_byte\00"
@str$155 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$156 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$157 = private global [12 x i8] c"write_bytes\00"
@str$158 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$159 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$15a = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$15b = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$15c = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$15d = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$15e = private global [4 x i8] c"\5Ca\22\00"
@str$15f = private global [4 x i8] c"\5Cb\22\00"
@str$160 = private global [4 x i8] c"\5Ce\22\00"
@str$161 = private global [4 x i8] c"\5Cf\22\00"
@str$162 = private global [4 x i8] c"\5Cn\22\00"
@str$163 = private global [4 x i8] c"\5Cr\22\00"
@str$164 = private global [4 x i8] c"\5Ct\22\00"
@str$165 = private global [4 x i8] c"\5Cv\22\00"
@str$166 = private global [3 x i8] c"\5Cx\00"
@str$167 = private global [3 x i8] c"00\00"
@str$168 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$169 = private global [3 x i8] c"\5Ca\00"
@str$16a = private global [3 x i8] c"\5Cb\00"
@str$16b = private global [3 x i8] c"\5Ce\00"
@str$16c = private global [3 x i8] c"\5Cf\00"
@str$16d = private global [3 x i8] c"\5Cn\00"
@str$16e = private global [3 x i8] c"\5Cr\00"
@str$16f = private global [3 x i8] c"\5Ct\00"
@str$170 = private global [3 x i8] c"\5Cv\00"
@str$171 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$172 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$173 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$174 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fstrings\2Fbuilder.odin\00"
@str$175 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$176 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$177 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$178 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$179 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$17a = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$17b = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$17c = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$17d = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$17e = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$17f = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$180 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$181 = private global [11 x i8] c"shift_left\00"
@str$182 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$183 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$184 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$185 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$186 = private global [66 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fdecimal\2Fdecimal.odin\00"
@str$187 = private global [4 x i8] c"nil\00"
@str$188 = private global [4 x i8] c"int\00"
@str$189 = private global [5 x i8] c"uint\00"
@str$18a = private global [8 x i8] c"uintptr\00"
@str$18b = private global [3 x i8] c"le\00"
@str$18c = private global [3 x i8] c"be\00"
@str$18d = private global [5 x i8] c"rune\00"
@str$18e = private global [8 x i8] c"complex\00"
@str$18f = private global [8 x i8] c"cstring\00"
@str$190 = private global [7 x i8] c"string\00"
@str$191 = private global [5 x i8] c"bool\00"
@str$192 = private global [4 x i8] c"any\00"
@str$193 = private global [7 x i8] c"typeid\00"
@str$194 = private global [7 x i8] c"rawptr\00"
@str$195 = private global [2 x i8] c"\5E\00"
@str$196 = private global [5 x i8] c"proc\00"
@str$197 = private global [3 x i8] c"\28\29\00"
@str$198 = private global [64 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Freflect\2Ftypes.odin\00"
@str$199 = private global [2 x i8] c"\28\00"
@str$19a = private global [3 x i8] c"\2C\20\00"
@str$19b = private global [2 x i8] c"\29\00"
@str$19c = private global [5 x i8] c"\20-\3E\20\00"
@str$19d = private global [2 x i8] c"\28\00"
@str$19e = private global [3 x i8] c"\2C\20\00"
@str$19f = private global [64 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Freflect\2Ftypes.odin\00"
@str$1a0 = private global [3 x i8] c"\3A\20\00"
@str$1a1 = private global [2 x i8] c"\29\00"
@str$1a2 = private global [2 x i8] c"\5B\00"
@str$1a3 = private global [2 x i8] c"\5D\00"
@str$1a4 = private global [10 x i8] c"\5Bdynamic\5D\00"
@str$1a5 = private global [3 x i8] c"\5B\5D\00"
@str$1a6 = private global [5 x i8] c"map\5B\00"
@str$1a7 = private global [8 x i8] c"struct\20\00"
@str$1a8 = private global [9 x i8] c"\23packed\20\00"
@str$1a9 = private global [12 x i8] c"\23raw_union\20\00"
@str$1aa = private global [8 x i8] c"\23align\20\00"
@str$1ab = private global [3 x i8] c"\2C\20\00"
@str$1ac = private global [3 x i8] c"\3A\20\00"
@str$1ad = private global [64 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Freflect\2Ftypes.odin\00"
@str$1ae = private global [7 x i8] c"union\20\00"
@str$1af = private global [8 x i8] c"\23align\20\00"
@str$1b0 = private global [3 x i8] c"\2C\20\00"
@str$1b1 = private global [6 x i8] c"enum\20\00"
@str$1b2 = private global [3 x i8] c"\20\7B\00"
@str$1b3 = private global [3 x i8] c"\2C\20\00"
@str$1b4 = private global [11 x i8] c"bit_field\20\00"
@str$1b5 = private global [8 x i8] c"\23align\20\00"
@str$1b6 = private global [3 x i8] c"\20\7B\00"
@str$1b7 = private global [3 x i8] c"\2C\20\00"
@str$1b8 = private global [3 x i8] c"\3A\20\00"
@str$1b9 = private global [64 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Freflect\2Ftypes.odin\00"
@str$1ba = private global [9 x i8] c"bit_set\5B\00"
@str$1bb = private global [3 x i8] c"..\00"
@str$1bc = private global [3 x i8] c"..\00"
@str$1bd = private global [3 x i8] c"\3B\20\00"
@str$1be = private global [8 x i8] c"opaque\20\00"
@str$1bf = private global [19 x i8] c"intrinsics.x86_mmx\00"
@str$1c0 = private global [19 x i8] c"intrinsics.vector\28\00"
@str$1c1 = private global [3 x i8] c"\2C\20\00"
@str$1c2 = private global [73 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2Fgit-projects\2Fthor\2Fsrc\2Flinkedlist.odin\00"
@str$1c3 = private global [7 x i8] c"insert\00"
@str$1c4 = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1c5 = private global [12 x i8] c"append_elem\00"
@str$1c6 = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1c7 = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1c8 = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1c9 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$1ca = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1cb = private global [12 x i8] c"append_elem\00"
@str$1cc = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1cd = private global [13 x i8] c"append_elems\00"
@str$1ce = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1cf = private global [63 x i8] c"C\3A\2FUsers\2Fdjama\2FDesktop\2Fprogramming\2FOdin\2Fcore\2Fruntime\2Fcore.odin\00"
@str$1d0 = private global [22 x i8] c"reserve_dynamic_array\00"
@str$1d1 = private global [10 x i8] c"Type_Info\00"
@str$1d2 = private global [5 x i8] c"size\00"
@str$1d3 = private global [6 x i8] c"align\00"
@str$1d4 = private global [3 x i8] c"id\00"
@str$1d5 = private global [8 x i8] c"variant\00"
@str$1d6 = private global [16 x i8] c"Type_Info_Named\00"
@str$1d7 = private global [5 x i8] c"name\00"
@str$1d8 = private global [5 x i8] c"base\00"
@str$1d9 = private global [18 x i8] c"Type_Info_Integer\00"
@str$1da = private global [7 x i8] c"signed\00"
@str$1db = private global [11 x i8] c"endianness\00"
@str$1dc = private global [20 x i8] c"Platform_Endianness\00"
@str$1dd = private global [9 x i8] c"Platform\00"
@str$1de = private global [7 x i8] c"Little\00"
@str$1df = private global [4 x i8] c"Big\00"
@str$1e0 = private global [15 x i8] c"Type_Info_Rune\00"
@str$1e1 = private global [16 x i8] c"Type_Info_Float\00"
@str$1e2 = private global [18 x i8] c"Type_Info_Complex\00"
@str$1e3 = private global [21 x i8] c"Type_Info_Quaternion\00"
@str$1e4 = private global [17 x i8] c"Type_Info_String\00"
@str$1e5 = private global [11 x i8] c"is_cstring\00"
@str$1e6 = private global [18 x i8] c"Type_Info_Boolean\00"
@str$1e7 = private global [14 x i8] c"Type_Info_Any\00"
@str$1e8 = private global [18 x i8] c"Type_Info_Type_Id\00"
@str$1e9 = private global [18 x i8] c"Type_Info_Pointer\00"
@str$1ea = private global [5 x i8] c"elem\00"
@str$1eb = private global [20 x i8] c"Type_Info_Procedure\00"
@str$1ec = private global [7 x i8] c"params\00"
@str$1ed = private global [8 x i8] c"results\00"
@str$1ee = private global [9 x i8] c"variadic\00"
@str$1ef = private global [11 x i8] c"convention\00"
@str$1f0 = private global [19 x i8] c"Calling_Convention\00"
@str$1f1 = private global [8 x i8] c"Invalid\00"
@str$1f2 = private global [5 x i8] c"Odin\00"
@str$1f3 = private global [12 x i8] c"Contextless\00"
@str$1f4 = private global [2 x i8] c"C\00"
@str$1f5 = private global [4 x i8] c"Std\00"
@str$1f6 = private global [5 x i8] c"Fast\00"
@str$1f7 = private global [16 x i8] c"Type_Info_Array\00"
@str$1f8 = private global [5 x i8] c"elem\00"
@str$1f9 = private global [10 x i8] c"elem_size\00"
@str$1fa = private global [6 x i8] c"count\00"
@str$1fb = private global [24 x i8] c"Type_Info_Dynamic_Array\00"
@str$1fc = private global [5 x i8] c"elem\00"
@str$1fd = private global [10 x i8] c"elem_size\00"
@str$1fe = private global [16 x i8] c"Type_Info_Slice\00"
@str$1ff = private global [16 x i8] c"Type_Info_Tuple\00"
@str$200 = private global [6 x i8] c"types\00"
@str$201 = private global [6 x i8] c"names\00"
@str$202 = private global [17 x i8] c"Type_Info_Struct\00"
@str$203 = private global [6 x i8] c"types\00"
@str$204 = private global [6 x i8] c"names\00"
@str$205 = private global [8 x i8] c"offsets\00"
@str$206 = private global [7 x i8] c"usings\00"
@str$207 = private global [5 x i8] c"tags\00"
@str$208 = private global [10 x i8] c"is_packed\00"
@str$209 = private global [13 x i8] c"is_raw_union\00"
@str$20a = private global [13 x i8] c"custom_align\00"
@str$20b = private global [16 x i8] c"Type_Info_Union\00"
@str$20c = private global [9 x i8] c"variants\00"
@str$20d = private global [11 x i8] c"tag_offset\00"
@str$20e = private global [9 x i8] c"tag_type\00"
@str$20f = private global [13 x i8] c"custom_align\00"
@str$210 = private global [7 x i8] c"no_nil\00"
@str$211 = private global [15 x i8] c"Type_Info_Enum\00"
@str$212 = private global [5 x i8] c"base\00"
@str$213 = private global [6 x i8] c"names\00"
@str$214 = private global [7 x i8] c"values\00"
@str$215 = private global [21 x i8] c"Type_Info_Enum_Value\00"
@str$216 = private global [14 x i8] c"Type_Info_Map\00"
@str$217 = private global [4 x i8] c"key\00"
@str$218 = private global [6 x i8] c"value\00"
@str$219 = private global [17 x i8] c"generated_struct\00"
@str$21a = private global [20 x i8] c"Type_Info_Bit_Field\00"
@str$21b = private global [6 x i8] c"names\00"
@str$21c = private global [5 x i8] c"bits\00"
@str$21d = private global [8 x i8] c"offsets\00"
@str$21e = private global [18 x i8] c"Type_Info_Bit_Set\00"
@str$21f = private global [5 x i8] c"elem\00"
@str$220 = private global [11 x i8] c"underlying\00"
@str$221 = private global [6 x i8] c"lower\00"
@str$222 = private global [6 x i8] c"upper\00"
@str$223 = private global [17 x i8] c"Type_Info_Opaque\00"
@str$224 = private global [22 x i8] c"Type_Info_Simd_Vector\00"
@str$225 = private global [5 x i8] c"elem\00"
@str$226 = private global [10 x i8] c"elem_size\00"
@str$227 = private global [6 x i8] c"count\00"
@str$228 = private global [11 x i8] c"is_x86_mmx\00"
@str$229 = private global [15 x i8] c"Allocator_Mode\00"
@str$22a = private global [6 x i8] c"Alloc\00"
@str$22b = private global [5 x i8] c"Free\00"
@str$22c = private global [9 x i8] c"Free_All\00"
@str$22d = private global [7 x i8] c"Resize\00"
@str$22e = private global [21 x i8] c"Source_Code_Location\00"
@str$22f = private global [10 x i8] c"file_path\00"
@str$230 = private global [5 x i8] c"line\00"
@str$231 = private global [7 x i8] c"column\00"
@str$232 = private global [10 x i8] c"procedure\00"
@str$233 = private global [5 x i8] c"hash\00"
@str$234 = private global [18 x i8] c"0123456789abcdefx\00"
@str$235 = private global [18 x i8] c"0123456789ABCDEFX\00"
@str$236 = private global [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"
@str$237 = private global [18 x i8] c"0123456789abcdefx\00"
@str$238 = private global [18 x i8] c"0123456789abcdefx\00"
@str$239 = private global [18 x i8] c"0123456789ABCDEFX\00"
@str$23a = private global [37 x i8] c"0123456789abcdefghijklmnopqrstuvwxyz\00"
@str$23b = private global [18 x i8] c"0123456789abcdefx\00"
attributes #0 = {nounwind uwtable}
attributes #1 = {nounwind alwaysinline uwtable}
attributes #2 = {nounwind noinline optnone uwtable}
attributes #3 = {nounwind readnone}
